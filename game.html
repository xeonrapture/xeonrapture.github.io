<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>XR Campaigns</title>
  <link rel="stylesheet" href="/shared/style.css">
  <style>
    .assigned-character-list {
      display: grid;
      gap: 0.75rem;
    }

    .assigned-character-card {
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 0.8rem 0.9rem;
      background: rgba(12, 19, 36, 0.75);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.22);
    }

    .assigned-character-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 0.5rem;
      margin-bottom: 0.55rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 0.45rem;
    }

    .assigned-character-name {
      font-weight: 700;
      text-decoration: none;
    }

    .assigned-character-role {
      font-size: 0.75rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      opacity: 0.8;
    }

    .assigned-character-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(118px, 1fr));
      gap: 0.45rem;
    }

    .assigned-stat {
      border: 1px solid rgba(255, 255, 255, 0.14);
      border-radius: 9px;
      padding: 0.35rem 0.45rem;
      background: rgba(255, 255, 255, 0.04);
      display: flex;
      justify-content: space-between;
      gap: 0.35rem;
      font-size: 0.84rem;
    }

    .assigned-stat-label {
      opacity: 0.72;
    }

    .assigned-stat-value {
      font-weight: 700;
      font-family: var(--mono-font, ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace);
    }
  </style>
</head>
<body class="wr-scope">
  <div id="nav"></div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="/shared/auth.js"></script>
  <script src="/shared/nav.js"></script>

  <main class="wrap">
    <h1>Campaigns</h1>
    <p class="muted">This page is shared between GMs and players. Everyone can view party characters in read-only mode.</p>

    <section class="card wr-mt-1">
      <h2>Create Campaign</h2>
      <label>Campaign name
        <input id="newCampaignName" type="text" maxlength="80" placeholder="Weekend Run" />
      </label>
      <button id="createCampaignBtn" type="button">Create Campaign</button>
    </section>

    <section class="card wr-mt-1">
      <h2>Your Campaigns</h2>
      <select id="gameSelect"></select>
      <div id="gameStatus" class="mono muted wr-mt-0-5"></div>
    </section>

    <section class="card wr-mt-1">
      <h2>Players</h2>
      <div id="memberList" class="mono muted">Loading members...</div>
      <div id="gmControls" class="wr-mt-1 hidden">
        <h3>GM Campaign Controls</h3>
        <label>Invite player from friends list
          <select id="inviteFriendSelect">
            <option value="">-- Select friend --</option>
          </select>
        </label>
        <button id="invitePlayerBtn" type="button">Invite to Campaign</button>
      </div>
    </section>

    <section class="card wr-mt-1">
      <h2>Assigned Characters (Read-only)</h2>
      <div id="characterList" class="assigned-character-list muted">No characters assigned yet.</div>
    </section>

    <section id="playerCharacterControls" class="card wr-mt-1 hidden">
      <h2>Your Character for this Campaign</h2>
      <p class="muted">Pick which of your webrunning characters you are playing in this campaign.</p>
      <label>Character
        <select id="playerCharacterSelect"></select>
      </label>
      <button id="savePlayerCharacterBtn" type="button">Save Character Selection</button>
      <div id="playerCharacterStatus" class="mono muted wr-mt-0-5"></div>
    </section>
  </main>

  <script>
    const sb = window.supabaseClient;
    const gameSelect = document.getElementById("gameSelect");
    const gameStatus = document.getElementById("gameStatus");
    const createCampaignBtn = document.getElementById("createCampaignBtn");
    const newCampaignName = document.getElementById("newCampaignName");
    const memberList = document.getElementById("memberList");
    const characterList = document.getElementById("characterList");
    const gmControls = document.getElementById("gmControls");
    const playerCharacterControls = document.getElementById("playerCharacterControls");
    const playerCharacterSelect = document.getElementById("playerCharacterSelect");
    const savePlayerCharacterBtn = document.getElementById("savePlayerCharacterBtn");
    const playerCharacterStatus = document.getElementById("playerCharacterStatus");
    const invitePlayerBtn = document.getElementById("invitePlayerBtn");
    const inviteFriendSelect = document.getElementById("inviteFriendSelect");

    let currentUser = null;
    let memberships = [];
    let playerCharacters = [];
    let friends = [];
    let realtimeChannels = [];

    async function requireUser() {
      const { data: { user } } = await sb.auth.getUser();
      if (!user) {
        window.location.href = "/login.html";
        throw new Error("No user");
      }
      return user;
    }

    function selectedGameId() {
      return gameSelect.value || null;
    }

    async function loadGames() {
      currentUser = await requireUser();
      const { data, error } = await sb
        .from("campaign_members")
        .select("campaign_id, role, campaigns(id, name, gm_user_id)")
        .eq("user_id", currentUser.id)
        .order("joined_at", { ascending: true });

      if (error) {
        gameStatus.textContent = `Failed to load campaigns: ${error.message}`;
        return;
      }

      memberships = data || [];
      gameSelect.innerHTML = "";
      if (!memberships.length) {
        gameSelect.innerHTML = "<option value=''>No campaigns yet</option>";
        gameStatus.textContent = "Accept a campaign invite from Notifications to join.";
        memberList.textContent = "No game selected.";
        characterList.textContent = "No game selected.";
        playerCharacterControls.classList.add("hidden");
        playerCharacterSelect.innerHTML = "";
        playerCharacterStatus.textContent = "";
        return;
      }

      memberships.forEach(m => {
        const option = document.createElement("option");
        option.value = m.campaign_id;
        option.textContent = `${m.campaigns?.name || "Unnamed Campaign"} (${m.role.toUpperCase()})`;
        gameSelect.appendChild(option);
      });

      await loadGameDetails();
    }

    async function areFriends(userIdA, userIdB) {
      const [a, b] = [userIdA, userIdB].sort();
      const { data, error } = await sb
        .from("friendships")
        .select("id")
        .eq("user_a", a)
        .eq("user_b", b)
        .maybeSingle();

      if (error) {
        throw error;
      }
      return !!data;
    }

    async function loadFriendInviteOptions() {
      currentUser = currentUser || await requireUser();
      const { data, error } = await sb
        .from("friendships")
        .select("user_a, user_b, created_at")
        .or(`user_a.eq.${currentUser.id},user_b.eq.${currentUser.id}`)
        .order("created_at", { ascending: false });

      inviteFriendSelect.innerHTML = "<option value=''>-- Select friend --</option>";

      if (error) {
        gameStatus.textContent = `Failed to load friends: ${error.message}`;
        return;
      }

      const friendIds = (data || []).map(row => row.user_a === currentUser.id ? row.user_b : row.user_a);
      if (!friendIds.length) {
        friends = [];
        return;
      }

      const { data: profiles, error: profileError } = await sb
        .from("profile_directory")
        .select("id, username")
        .in("id", friendIds);

      if (profileError) {
        gameStatus.textContent = `Failed to load friend usernames: ${profileError.message}`;
        return;
      }

      const byId = Object.fromEntries((profiles || []).map(profile => [profile.id, profile]));
      friends = friendIds
        .map(id => byId[id])
        .filter(Boolean);

      friends.forEach(friend => {
        const option = document.createElement("option");
        option.value = friend.id;
        option.textContent = friend.username || friend.id;
        inviteFriendSelect.appendChild(option);
      });
    }

    async function loadGameDetails() {
      const campaignId = selectedGameId();
      if (!campaignId) return;

      const membership = memberships.find(m => String(m.campaign_id) === String(campaignId));
      const isGm = membership?.role === "gm";
      const isPlayer = membership?.role === "player";
      gmControls.classList.toggle("hidden", !isGm);
      playerCharacterControls.classList.toggle("hidden", !isPlayer);
      gameStatus.textContent = isGm ? "You are the GM for this game." : "You are a player in this game.";

      if (isPlayer) {
        await loadPlayerCharacterOptions(campaignId);
      } else {
        playerCharacterSelect.innerHTML = "";
        playerCharacterStatus.textContent = "";
      }

      const { data: members, error: membersError } = await sb
        .from("campaign_members")
        .select("user_id, role")
        .eq("campaign_id", campaignId)
        .order("joined_at", { ascending: true });

      if (membersError) {
        memberList.textContent = `Failed to load players: ${membersError.message}`;
      } else {
        const ids = (members || []).map(m => m.user_id);
        let profiles = [];
        if (ids.length) {
          const { data: pData } = await sb.from("profile_directory").select("id, username").in("id", ids);
          profiles = pData || [];
        }
        const byId = Object.fromEntries(profiles.map(p => [p.id, p.username || "(no username)"]));
        memberList.innerHTML = (members || []).map(m => {
          const role = m.role === "gm" ? "GM" : "Player";
          return `<div>• ${byId[m.user_id] || m.user_id} — ${role}</div>`;
        }).join("") || "No members yet.";
      }

      const { data: assignments, error: assignmentError } = await sb
        .from("campaign_character_assignments")
        .select("character_id, user_id, webrunning_characters(id, name, base_stats)")
        .eq("campaign_id", campaignId)
        .order("assigned_at", { ascending: true });

      if (assignmentError) {
        characterList.textContent = `Failed to load characters: ${assignmentError.message}`;
      } else if (!(assignments || []).length) {
        characterList.textContent = "No characters assigned to this game yet.";
      } else {
        characterList.innerHTML = assignments.map(row => {
          const c = row.webrunning_characters;
          const link = `/webrunning-2.0/webrunning-character.html?id=${row.character_id}&campaign_id=${campaignId}&readonly=1`;
          const stats = c?.base_stats || {};
          const statTiles = [
            ["Lv", stats.level ?? 1],
            ["XP", stats.xp ?? 0],
            ["Luck", stats.luck ?? 0],
            ["HP", `${stats.current_hp ?? stats.hp ?? 0}/${stats.hp ?? 0}`],
            ["Energy", stats.energy_cap ?? 0],
            ["Essence", stats.essence ?? 0],
            ["Power", stats.power ?? 0],
            ["Defense", stats.defense ?? 0],
            ["Speed", stats.speed ?? 0],
            ["Int", stats.intelligence ?? 0]
          ];
          return `
            <article class="assigned-character-card">
              <div class="assigned-character-header">
                <a class="assigned-character-name" href="${link}">${c?.name || "Unnamed character"}</a>
                <span class="assigned-character-role muted">Read-only</span>
              </div>
              <div class="assigned-character-stats">
                ${statTiles.map(([label, value]) => `<div class="assigned-stat"><span class="assigned-stat-label">${label}</span><span class="assigned-stat-value">${value}</span></div>`).join("")}
              </div>
            </article>
          `;
        }).join("");
      }
    }

    function clearRealtimeSubscriptions() {
      realtimeChannels.forEach(channel => sb.removeChannel(channel));
      realtimeChannels = [];
    }

    function subscribeCampaignRealtime() {
      clearRealtimeSubscriptions();
      if (!currentUser?.id) return;

      const refreshAll = () => {
        loadGames();
        loadFriendInviteOptions();
      };

      const membershipChannel = sb
        .channel(`campaign-members-${currentUser.id}`)
        .on("postgres_changes", {
          event: "*",
          schema: "public",
          table: "campaign_members"
        }, refreshAll)
        .subscribe();

      const inviteChannel = sb
        .channel(`campaign-invites-${currentUser.id}`)
        .on("postgres_changes", {
          event: "*",
          schema: "public",
          table: "campaign_invites"
        }, refreshAll)
        .subscribe();

      const assignmentChannel = sb
        .channel(`campaign-assignments-${currentUser.id}`)
        .on("postgres_changes", {
          event: "*",
          schema: "public",
          table: "campaign_character_assignments"
        }, () => loadGameDetails())
        .subscribe();

      const charactersChannel = sb
        .channel(`webrunning-characters-${currentUser.id}`)
        .on("postgres_changes", {
          event: "UPDATE",
          schema: "public",
          table: "webrunning_characters"
        }, () => loadGameDetails())
        .subscribe();

      const friendshipsChannel = sb
        .channel(`friendships-${currentUser.id}`)
        .on("postgres_changes", {
          event: "*",
          schema: "public",
          table: "friendships"
        }, () => loadFriendInviteOptions())
        .subscribe();

      realtimeChannels.push(membershipChannel, inviteChannel, assignmentChannel, charactersChannel, friendshipsChannel);
    }

    async function loadPlayerCharacterOptions(campaignId) {
      const [{ data: chars, error: charsError }, { data: assignment, error: assignmentError }] = await Promise.all([
        sb
          .from("webrunning_characters")
          .select("id, name, base_stats")
          .eq("user_id", currentUser.id)
          .order("created_at", { ascending: true }),
        sb
          .from("campaign_character_assignments")
          .select("id, character_id")
          .eq("campaign_id", campaignId)
          .eq("user_id", currentUser.id)
          .maybeSingle()
      ]);

      if (charsError) {
        playerCharacterStatus.textContent = `Failed to load your characters: ${charsError.message}`;
        return;
      }

      if (assignmentError) {
        playerCharacterStatus.textContent = `Failed to load your assignment: ${assignmentError.message}`;
        return;
      }

      playerCharacters = chars || [];
      playerCharacterSelect.innerHTML = "";

      const noneOption = document.createElement("option");
      noneOption.value = "";
      noneOption.textContent = "-- No character selected --";
      playerCharacterSelect.appendChild(noneOption);

      playerCharacters.forEach(character => {
        const option = document.createElement("option");
        option.value = character.id;
        option.textContent = `${character.name || "Unnamed character"} (Lv ${character.base_stats?.level || 1})`;
        playerCharacterSelect.appendChild(option);
      });

      playerCharacterSelect.value = assignment?.character_id || "";

      if (!playerCharacters.length) {
        playerCharacterStatus.textContent = "You have no webrunning characters yet. Create one in Character Manager first.";
        return;
      }

      playerCharacterStatus.textContent = assignment?.character_id
        ? "Your current campaign character is selected below."
        : "No campaign character selected yet.";
    }

    invitePlayerBtn.onclick = async () => {
      const campaignId = selectedGameId();
      const inviteeId = inviteFriendSelect.value;
      if (!campaignId || !inviteeId) {
        gameStatus.textContent = "Pick a game and select a friend to invite.";
        return;
      }

      const friendProfile = friends.find(friend => String(friend.id) === String(inviteeId));
      if (!friendProfile) {
        gameStatus.textContent = "Selected friend was not found. Refresh and try again.";
        return;
      }

      if (friendProfile.id === currentUser.id) {
        gameStatus.textContent = "You are already in this campaign as the GM.";
        return;
      }

      try {
        const friendMatch = await areFriends(currentUser.id, friendProfile.id);
        if (!friendMatch) {
          gameStatus.textContent = "You can only invite users who are already your friend.";
          return;
        }
      } catch (error) {
        gameStatus.textContent = `Failed to verify friendship: ${error.message}`;
        return;
      }

      const { error: inviteError } = await sb.from("campaign_invites").insert({
        campaign_id: campaignId,
        inviter_user_id: currentUser.id,
        invitee_user_id: friendProfile.id,
        status: "pending"
      });

      if (inviteError) {
        gameStatus.textContent = `Failed to invite: ${inviteError.message}`;
        return;
      }

      gameStatus.textContent = `Sent campaign invite to ${friendProfile.username || "your friend"}.`;
      inviteFriendSelect.value = "";
    };

    createCampaignBtn.onclick = async () => {
      const name = newCampaignName.value.trim();

      if (!name) {
        gameStatus.textContent = "Enter a campaign name first.";
        return;
      }

      const { data: insertedCampaign, error: campaignError } = await sb
        .from("campaigns")
        .insert({
          name,
          gm_user_id: currentUser.id,
          status: "active"
        })
        .select("id, name")
        .single();

      if (campaignError || !insertedCampaign) {
        gameStatus.textContent = `Failed to create campaign: ${campaignError?.message || "Unknown error"}`;
        return;
      }

      const { error: gmMembershipError } = await sb
        .from("campaign_members")
        .insert({
          campaign_id: insertedCampaign.id,
          user_id: currentUser.id,
          role: "gm"
        });

      if (gmMembershipError) {
        gameStatus.textContent = `Campaign created, but failed to register you as GM: ${gmMembershipError.message}`;
        return;
      }

      gameStatus.textContent = `Campaign "${insertedCampaign.name}" created.`;
      newCampaignName.value = "";
      await loadGames();
      gameSelect.value = insertedCampaign.id;
      await loadGameDetails();
    };

    savePlayerCharacterBtn.onclick = async () => {
      const campaignId = selectedGameId();
      if (!campaignId) {
        playerCharacterStatus.textContent = "Select a campaign first.";
        return;
      }

      const selectedCharacterId = playerCharacterSelect.value || null;

      if (!selectedCharacterId) {
        const { error } = await sb
          .from("campaign_character_assignments")
          .delete()
          .eq("campaign_id", campaignId)
          .eq("user_id", currentUser.id);

        if (error) {
          playerCharacterStatus.textContent = `Failed to clear selection: ${error.message}`;
          return;
        }

        playerCharacterStatus.textContent = "Cleared your character selection for this campaign.";
        await loadGameDetails();
        return;
      }

      const selectedCharacter = playerCharacters.find(character => String(character.id) === String(selectedCharacterId));
      if (!selectedCharacter) {
        playerCharacterStatus.textContent = "Invalid character selection.";
        return;
      }

      const { error: deleteError } = await sb
        .from("campaign_character_assignments")
        .delete()
        .eq("campaign_id", campaignId)
        .eq("user_id", currentUser.id);

      if (deleteError) {
        playerCharacterStatus.textContent = `Failed to save character selection: ${deleteError.message}`;
        return;
      }

      const { error: insertError } = await sb.from("campaign_character_assignments").insert({
        campaign_id: campaignId,
        user_id: currentUser.id,
        character_id: selectedCharacterId
      });

      if (insertError) {
        playerCharacterStatus.textContent = `Failed to save character selection: ${insertError.message}`;
        return;
      }

      playerCharacterStatus.textContent = `Selected ${selectedCharacter.name || "your character"} for this campaign.`;
      await loadGameDetails();
    };

    gameSelect.addEventListener("change", loadGameDetails);

    async function initializePage() {
      await loadGames();
      await loadFriendInviteOptions();
      subscribeCampaignRealtime();
    }

    window.addEventListener("beforeunload", clearRealtimeSubscriptions);

    initializePage();
  </script>
</body>
</html>
