<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>XRRPG Characters</title>
  <link rel="stylesheet" href="/shared/style.css">
</head>
<body class="wr-scope">
  <div id="nav"></div>
  <main class="wrap">
    <h1>XRRPG Character Manager</h1>
    <div class="character-actions">
      <button id="newCharacterBtn" aria-label="New character" title="New character"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 5v14"></path><path d="M5 12h14"></path></svg></button>
      <button id="importCharacterBtn" aria-label="Import character" title="Import character JSON"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3v12"></path><path d="M8 11l4 4 4-4"></path><path d="M4 20h16"></path></svg></button>
      <input id="importCharacterInput" type="file" accept="application/json,.json" class="hidden" />
    </div>
    <table class="table-full">
      <thead>
        <tr>
          <th><button type="button" class="table-sort" data-sort="name">Name</button></th>
          <th><button type="button" class="table-sort" data-sort="level">Lvl</button></th>
          <th><button type="button" class="table-sort" data-sort="class">Class Path</button></th>
          <th><button type="button" class="table-sort" data-sort="vigor">Vig</button></th>
          <th><button type="button" class="table-sort" data-sort="endurance">End</button></th>
          <th><button type="button" class="table-sort" data-sort="intuition">Intu</button></th>
          <th><button type="button" class="table-sort" data-sort="wit">Wit</button></th>
          <th></th>
        </tr>
      </thead>
      <tbody id="charTable"><tr><td colspan="8">Loading…</td></tr></tbody>
    </table>
  </main>

  <div id="charModal" class="xr-modal hidden">
    <div class="xr-modal-backdrop"></div>
    <div class="xr-modal-card">
      <h2>Create XRRPG Character</h2>
      <p id="wizardStepLabel" class="muted">Step 1 / 3</p>

      <div data-step="1" class="wizard-step xrrpg-form-grid">
        <label>Name <input id="nameInput" maxlength="48" /></label>
        <label>Species <a class="xrrpg-help-link" href="https://xeonrapture.com/xr/XRRPG+2.0/XRRPG+2.0+Core+Rules#Species" target="_blank" rel="noopener noreferrer">rules</a>
          <select id="speciesInput"></select>
        </label>
      </div>

      <div data-step="2" class="wizard-step hidden">
        <div class="xrrpg-row">
          <strong>Stat Setup</strong>
          <a class="xrrpg-help-link" href="https://xeonrapture.com/xr/XRRPG+2.0/XRRPG+2.0+Core+Rules#Stats" target="_blank" rel="noopener noreferrer">rules</a>
        </div>
        <p class="muted xrrpg-subtitle">Pick chroma first.<br> For non-Clear chroma, your main bonus stat is automatic: <br>Red → Vigor, Blue → Endurance, Green → Intuition, Grey → Wit.</p>
        <div class="xrrpg-inline-fields">
          <label>Chroma <a class="xrrpg-help-link" href="https://xeonrapture.com/xr/XRRPG+2.0/XRRPG+2.0+Core+Rules#Chroma" target="_blank" rel="noopener noreferrer">rules</a>
            <select id="chromaInput">
              <option>Red</option><option>Blue</option><option>Green</option><option>Grey</option><option>Clear</option>
            </select>
          </label>
          <label>Preset
            <select id="statPresetSelect">
              <option value="plus2">+2 to chroma stat and +1 to a different stat</option>
              <option value="plus3">+3 chroma stat, +1 to one stat, and -1 to one stat</option>
              <option value="dual2">+2 to two chroma stats and -1 to one stat</option>
              <option value="clear">Clear chroma (+1 to three stats)</option>
            </select>
          </label>
          <label id="bonusStatWrap">+1 bonus stat <select id="bonusStat"></select></label>
          <label id="secondBonusStatWrap">Second +2 stat <select id="secondBonusStat"></select></label>
          <label id="thirdBonusStatWrap" class="hidden">Third +1 stat <select id="thirdBonusStat"></select></label>
          <label id="penaltyStatWrap">Penalty stat <select id="penaltyStat"></select></label>
        </div>
      </div>

      <div data-step="3" class="wizard-step xrrpg-form-grid hidden">
        <label>Starting class <a class="xrrpg-help-link" href="https://xeonrapture.com/xr/XRRPG+2.0/XRRPG+2.0+Core+Rules#Classes" target="_blank" rel="noopener noreferrer">rules</a>
          <select id="classInput"></select>
        </label>
        <div id="classIntro" class="muted"></div>
        <div>
          <label>Starting class ability choices</label>
          <div id="startingAbilityChoices" class="xrrpg-notes-stack"></div>
          <button id="addStartingAbilityBtn" type="button" class="wr-mt-0-5">Add custom ability choice</button>
        </div>
        <label>Skill 1 <a class="xrrpg-help-link" href="https://xeonrapture.com/xr/XRRPG+2.0/XRRPG+2.0+Core+Rules#Skills" target="_blank" rel="noopener noreferrer">rules</a>
          <input id="skill1" maxlength="48" placeholder="Stealth" />
        </label>
        <label>Skill 1 Plus
          <select id="skill1Bonus"><option value="2">+2 (General)</option><option value="3">+3 (Specific)</option></select>
        </label>
        <label>Skill 2
          <input id="skill2" maxlength="48" placeholder="Investigation" />
        </label>
        <label>Skill 2 Plus
          <select id="skill2Bonus"><option value="2">+2 (General)</option><option value="3">+3 (Specific)</option></select>
        </label>
      </div>

      <div class="xr-modal-actions">
        <button id="prevStepBtn" type="button">Back</button>
        <button id="nextStepBtn" type="button">Next</button>
        <button id="saveBtn" type="button" class="hidden">Create</button>
      </div>
      <div id="modalMsg" class="mono muted"></div>
    </div>
  </div>

  <div id="loadingOverlay" class="xr-loading-overlay" aria-live="polite" aria-busy="true">
    <div class="xr-loading-spinner" aria-hidden="true"></div>
    <div id="loadingOverlayText" class="mono">Loading characters…</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="/shared/auth.js"></script>
  <script src="/shared/nav.js"></script>
  <script src="/xrrpg-2.0/class-abilities.js"></script>
  <script>
    window.__useLocalLoadingOverlay = true;
    const sb = window.supabaseClient;
    const table = document.getElementById('charTable');
    const classNames = [
      'Warrior','Mentalist','Tank','Druid','Elementalist','Summoner','Mystic','Alchemist','Physic','Possessor','Bard','Enchanter','Sorcerer','Warlock','Cleric','Demititan','Emitter Specialist','Dronemaster','Brawler','Explosives Expert','Gunslinger','Swordmaster'
    ];
    const classAbilities = window.XRRPG_CLASS_ABILITIES || {};
    const CLASS_SUMMARIES = {
      'Warrior': 'Adept frontline striker with tiered basic/advanced powers.',
      'Mentalist': 'Adept mind specialist with scaling control powers.',
      'Tank': 'Adept defender with strong mitigation at higher tiers.',
      'Druid': 'Adept nature/healing specialist with escalating support.',
      'Elementalist': 'Spiritualist element manipulator with tier and range scaling.',
      'Summoner': 'Spiritualist summoner who grows spirit options each level.',
      'Mystic': 'Spiritualist with spirit roster upgrades and more spirit spells.',
      'Alchemist': 'Magician potion specialist scaling brews and mixes.',
      'Physic': 'Magician spellcaster with increasing spell tier and concentration.',
      'Possessor': 'Magician spirit-servant caster with increasing spell access.',
      'Bard': 'Magician support caster with scaling spells and concentration.',
      'Enchanter': 'Magician substance mage with chaos/concentration scaling.',
      'Sorcerer': 'Mage specialization path that unlocks more powers by class level.',
      'Warlock': 'Mage pact caster with dark, risky tiered powers.',
      'Cleric': 'Mage pact support/healer with tiered utility powers.',
      'Demititan': 'Mage element shifter with explicit multi-level element upgrades.',
      'Emitter Specialist': 'Technologist area-control specialist with higher emitter limits.',
      'Dronemaster': 'Technologist drone commander with stronger drone scaling.',
      'Brawler': 'Technologist suit brawler with more installed effects per level.',
      'Explosives Expert': 'Technologist bomber with larger blasts and output/day.',
      'Gunslinger': 'Technologist gun crafter with more effects per gun per level.',
      'Swordmaster': 'Technologist sword/beam fighter with stronger attack scaling.'
    };
    const speciesOptions = ['Humans','Drokk','Exoziniks','Kaldi','Pbosh','Rtolka','Cyclops','Walua','Osadona','Oro'];
    let currentUser = null;
    let characters = [];
    let sortState = { key: 'name', direction: 'asc' };

    function setLoading(message = 'Loading…') {
      const overlay = document.getElementById('loadingOverlay');
      const text = document.getElementById('loadingOverlayText');
      if (text) text.textContent = message;
      if (overlay) overlay.classList.remove('hidden');
    }

    function clearLoading() {
      const overlay = document.getElementById('loadingOverlay');
      if (overlay) overlay.classList.add('hidden');
    }

    async function withLoading(message, task) {
      setLoading(message);
      try {
        return await task();
      } finally {
        clearLoading();
      }
    }

    const stats = ['vigor','endurance','intuition','wit'];
    const bonusStat = document.getElementById('bonusStat');
    const penaltyStat = document.getElementById('penaltyStat');
    const secondBonusStat = document.getElementById('secondBonusStat');
    const thirdBonusStat = document.getElementById('thirdBonusStat');
    const statPresetSelect = document.getElementById('statPresetSelect');
    [bonusStat, penaltyStat, secondBonusStat, thirdBonusStat].forEach(select => {
      stats.forEach(stat => {
        const opt = document.createElement('option');
        opt.value = stat;
        opt.textContent = stat[0].toUpperCase() + stat.slice(1);
        select.appendChild(opt);
      });
    });

    const speciesInput = document.getElementById('speciesInput');
    const chromaInput = document.getElementById('chromaInput');
    speciesOptions.forEach(name => {
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      speciesInput.appendChild(opt);
    });

    function updateStatSetupVisibility() {
      const preset = statPresetSelect.value;
      document.getElementById('penaltyStatWrap').classList.toggle('hidden', !(preset === 'plus3' || preset === 'dual2'));
      document.getElementById('secondBonusStatWrap').classList.toggle('hidden', !(preset === 'dual2' || preset === 'clear'));
      document.getElementById('thirdBonusStatWrap').classList.toggle('hidden', preset !== 'clear');
    }
    statPresetSelect.addEventListener('change', updateStatSetupVisibility);
    updateStatSetupVisibility();

    function validateStatSelections() {
      const chroma = chromaInput.value;
      const chromaMap = { Red: 'vigor', Blue: 'endurance', Green: 'intuition', Grey: 'wit' };
      const preset = statPresetSelect.value;
      const usedStats = [];
      const take = (value) => {
        if (!value) return;
        usedStats.push(value);
      };
      if (preset !== 'clear' && chromaMap[chroma]) {
        take(chromaMap[chroma]);
      }
      if (preset === 'plus2') {
        take(bonusStat.value);
      } else if (preset === 'plus3') {
        take(bonusStat.value);
        take(penaltyStat.value);
      } else if (preset === 'dual2') {
        take(secondBonusStat.value);
        take(penaltyStat.value);
      } else {
        usedStats.length = 0;
        take(bonusStat.value);
        take(secondBonusStat.value);
        take(thirdBonusStat.value);
      }

      const seen = new Set();
      for (const stat of usedStats) {
        if (seen.has(stat)) {
          return { valid: false, message: 'Each stat choice must be unique. Remove duplicate stat selections before continuing.' };
        }
        seen.add(stat);
      }
      return { valid: true, message: '' };
    }

    const classInput = document.getElementById('classInput');
    classNames.forEach(name => {
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      classInput.appendChild(opt);
    });


    function addStartingAbilityChoice(value = '') {
      const wrap = document.getElementById('startingAbilityChoices');
      const row = document.createElement('label');
      row.className = 'xrrpg-row';
      row.innerHTML = '<input class="starting-ability-choice" maxlength="80" placeholder="Ability name" /> <button type="button" class="remove-starting-ability-btn">Remove</button>';
      row.querySelector('.starting-ability-choice').value = value;
      row.querySelector('.remove-starting-ability-btn').onclick = () => row.remove();
      wrap.appendChild(row);
    }

    function tierText(tiers = {}, tier) {
      const tierNum = Number(tier);
      const candidates = [
        String(tierNum),
        `tier_${tierNum}`,
        `tier${tierNum}`,
        `tier ${tierNum}`,
        `Tier ${tierNum}`,
        `Tier ${['I', 'II', 'III'][tierNum - 1] || tierNum}`,
        ['I', 'II', 'III'][tierNum - 1] || String(tierNum)
      ];
      const keys = Object.keys(tiers || {});
      const match = keys.find(key => candidates.some(candidate => key.toLowerCase() === String(candidate).toLowerCase()));
      return String(match ? tiers[match] : '').trim();
    }

    function parsedTierAbilities(cls, tier) {
      return (classAbilities[cls] || []).filter(item => {
        const name = String(item?.name || '').trim();
        if (!name || /^\d+$/.test(name)) return false;
        return !!tierText(item?.tiers || {}, tier) || Object.keys(item?.tiers || {}).some(key => String(key).replace(/\D/g, '') === String(tier));
      });
    }

    function renderStartingClassDetails() {
      const cls = classInput.value;
      document.getElementById('classIntro').textContent = CLASS_SUMMARIES[cls] || 'Class summary unavailable.';
      const abilities = parsedTierAbilities(cls, 1);
      const wrap = document.getElementById('startingAbilityChoices');
      if (!abilities.length) {
        wrap.innerHTML = '<div class="muted">No parsed tier-1 abilities for this class. Add your choice manually.</div>';
        addStartingAbilityChoice();
        return;
      }
      wrap.innerHTML = abilities.map(item => `<label><input type="checkbox" class="starting-ability-option" value="${item.name.replace(/"/g, '&quot;')}" /> ${item.name} <span class="muted">${tierText(item.tiers || {}, 1)}</span></label>`).join('');
      addStartingAbilityChoice();
    }

    function gatherStartingAbilityChoices() {
      const checked = Array.from(document.querySelectorAll('.starting-ability-option:checked')).map(input => input.value.trim()).filter(Boolean);
      const typed = Array.from(document.querySelectorAll('.starting-ability-choice')).map(input => input.value.trim()).filter(Boolean);
      return [...new Set([...checked, ...typed])];
    }

    async function requireUser() {
      const { data: { user } } = await sb.auth.getUser();
      if (!user) throw new Error('No user');
      return user;
    }

    function normalizeBaseStats(baseStats) {
      if (!baseStats || typeof baseStats !== 'object') return {};
      const normalized = { ...baseStats };
      if (normalized.stamina === undefined && normalized.stamina_used !== undefined) {
        normalized.stamina = normalized.stamina_used;
      }
      if (Object.prototype.hasOwnProperty.call(normalized, 'stamina_used')) {
        delete normalized.stamina_used;
      }
      return normalized;
    }

    function valueForSort(character, key) {
      const s = character.base_stats || {};
      if (key === 'name') return (character.name || '').toLowerCase();
      if (key === 'level') return Number(s.level || 1);
      if (key === 'class') return (character.class_progression?.map(c => c.class).join(' / ') || '').toLowerCase();
      return Number(s[key] || 0);
    }

    function sortedCharacters() {
      const dir = sortState.direction === 'asc' ? 1 : -1;
      return [...characters].sort((a, b) => {
        const av = valueForSort(a, sortState.key);
        const bv = valueForSort(b, sortState.key);
        if (av < bv) return -1 * dir;
        if (av > bv) return 1 * dir;
        return 0;
      });
    }

    function render() {
      if (!characters.length) {
        table.innerHTML = "<tr><td colspan='8'>No XRRPG characters yet.</td></tr>";
        return;
      }
      table.innerHTML = '';
      sortedCharacters().forEach(c => {
        const s = c.base_stats || {};
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${c.name}</td>
          <td>${s.level || 1}</td>
          <td>${(c.class_progression || []).map(p => `${p.class} T${p.tier}`).join(', ') || '—'}</td>
          <td>${s.vigor || 0}</td>
          <td>${s.endurance || 0}</td>
          <td>${s.intuition || 0}</td>
          <td>${s.wit || 0}</td>
          <td class="actions">
            <a class="action-btn" href="/xrrpg-2.0/xrrpg-character.html?id=${c.id}" title="Edit" aria-label="Edit"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 20l4-1 9-9-3-3-9 9-1 4z"></path><path d="M13 7l3 3"></path></svg></a>
            <button class="action-btn" onclick="exportCharacter('${c.id}')" title="Export" aria-label="Export"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 14V3"></path><path d="M8 7l4-4 4 4"></path><path d="M4 14v6h16v-6"></path></svg></button>
            <button class="action-btn" onclick="deleteCharacter('${c.id}')" title="Delete" aria-label="Delete"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 7h16"></path><path d="M9 7V4h6v3"></path><path d="M7 7l1 13h8l1-13"></path><path d="M10 11v6M14 11v6"></path></svg></button>
          </td>
        `;
        table.appendChild(row);
      });
    }

    async function loadCharacters() {
      try {
        currentUser = await requireUser();
        const { data, error } = await sb.from('xrrpg_characters')
          .select('id, name, base_stats, class_progression, created_at')
          .eq('user_id', currentUser.id)
          .order('created_at', { ascending: true });
        if (error) throw error;
        characters = (data || []).map(character => ({
          ...character,
          base_stats: normalizeBaseStats(character.base_stats)
        }));
        render();
      } catch (error) {
        table.innerHTML = `<tr><td colspan='8'>Failed to load: ${error.message}</td></tr>`;
      }
    }

    function cleanFileName(name) {
      return String(name || 'xrrpg-character').toLowerCase().replace(/[^a-z0-9_-]+/g, '-').replace(/^-+|-+$/g, '') || 'xrrpg-character';
    }

    function triggerJsonDownload(filename, dataObj) {
      const blob = new Blob([JSON.stringify(dataObj, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    async function exportCharacter(characterId) {
      const char = characters.find(item => item.id === characterId);
      if (!char) return;
      triggerJsonDownload(`${cleanFileName(char.name)}.json`, {
        export_version: 1,
        exported_at: new Date().toISOString(),
        character: {
          ...char,
          base_stats: normalizeBaseStats(char.base_stats)
        }
      });
    }

    async function importCharacterFromPayload(payload) {
      const importedCharacter = payload?.character;
      if (!importedCharacter || typeof importedCharacter !== 'object') throw new Error('Invalid character payload.');
      const name = String(importedCharacter.name || '').trim();
      if (!name) throw new Error('Imported character needs a name.');
      const base_stats = normalizeBaseStats(importedCharacter.base_stats && typeof importedCharacter.base_stats === 'object' ? importedCharacter.base_stats : {});
      const class_progression = Array.isArray(importedCharacter.class_progression) ? importedCharacter.class_progression : [];
      const skills = Array.isArray(importedCharacter.skills) ? importedCharacter.skills : [];
      const notes = typeof importedCharacter.notes === 'string' ? importedCharacter.notes : '';
      const { error } = await sb.from('xrrpg_characters').insert({ user_id: currentUser.id, name, base_stats, class_progression, skills, notes });
      if (error) throw error;
      await withLoading('Refreshing character list…', loadCharacters);
    }

    async function deleteCharacter(characterId) {
      const char = characters.find(item => item.id === characterId);
      if (!char) return;
      if (!window.confirm(`Delete ${char.name || 'this character'}? This cannot be undone.`)) return;
      const { error } = await sb.from('xrrpg_characters').delete().eq('id', characterId).eq('user_id', currentUser.id);
      if (error) {
        alert(error.message);
        return;
      }
      await withLoading('Refreshing character list…', loadCharacters);
    }

    window.exportCharacter = exportCharacter;
    window.deleteCharacter = deleteCharacter;

    function buildStatsFromWizard() {
      const chroma = document.getElementById('chromaInput').value;
      const chromaMap = { Red: 'vigor', Blue: 'endurance', Green: 'intuition', Grey: 'wit' };
      const main = chromaMap[chroma] || 'vigor';
      const preset = statPresetSelect.value;
      const result = { vigor: 0, endurance: 0, intuition: 0, wit: 0 };
      if (preset === 'plus2') {
        result[main] += 2;
        result[bonusStat.value] += 1;
      } else if (preset === 'plus3') {
        result[main] += 3;
        result[bonusStat.value] += 1;
        result[penaltyStat.value] -= 1;
      } else if (preset === 'dual2') {
        result[main] += 2;
        result[secondBonusStat.value] += 2;
        result[penaltyStat.value] -= 1;
      } else {
        result[bonusStat.value] += 1;
        result[secondBonusStat.value] += 1;
        result[thirdBonusStat.value] += 1;
      }
      const max_hp = 10 + result.vigor + (2 * result.endurance);
      const stamina_total = 10 + result.intuition + result.wit;
      return {
        ...result,
        level: 1,
        hp: max_hp,
        current_hp: max_hp,
        mastery_die: 'd4',
        injuries: [],
        stamina: 0,
        stamina_max: stamina_total,
        stamina_total,
        stamina_exhaustion_limit: stamina_total,
        powerful_item_limit: chroma === 'Clear' ? 2 : 0,
        powerful_item_max: chroma === 'Clear' ? 2 : 0,
        party_tier: 1,
        xenic_decay_level: 0,
        times_cleansed: 0
      };
    }

    let wizardStep = 1;
    const modal = document.getElementById('charModal');
    const wizardStepLabel = document.getElementById('wizardStepLabel');
    function setStep(step) {
      wizardStep = Math.max(1, Math.min(3, step));
      wizardStepLabel.textContent = `Step ${wizardStep} / 3`;
      document.querySelectorAll('.wizard-step').forEach(el => {
        el.classList.toggle('hidden', Number(el.dataset.step) !== wizardStep);
      });
      document.getElementById('prevStepBtn').classList.toggle('hidden', wizardStep === 1);
      document.getElementById('nextStepBtn').classList.toggle('hidden', wizardStep === 3);
      document.getElementById('saveBtn').classList.toggle('hidden', wizardStep !== 3);
      if (wizardStep === 3) renderStartingClassDetails();
    }

    document.getElementById('newCharacterBtn').onclick = () => { modal.classList.remove('hidden'); setStep(1); };
    classInput.onchange = () => renderStartingClassDetails();
    document.getElementById('addStartingAbilityBtn').onclick = () => addStartingAbilityChoice();
    modal.querySelector('.xr-modal-backdrop').onclick = () => modal.classList.add('hidden');
    document.getElementById('prevStepBtn').onclick = () => setStep(wizardStep - 1);
    document.getElementById('nextStepBtn').onclick = () => {
      const msg = document.getElementById('modalMsg');
      if (wizardStep === 1 && !document.getElementById('nameInput').value.trim()) {
        msg.textContent = 'Name required before continuing.';
        return;
      }
      if (wizardStep === 2) {
        const validation = validateStatSelections();
        if (!validation.valid) {
          msg.textContent = validation.message;
          return;
        }
      }
      msg.textContent = '';
      setStep(wizardStep + 1);
    };

    document.querySelectorAll('.table-sort').forEach(button => {
      button.onclick = () => {
        const key = button.dataset.sort;
        if (sortState.key === key) {
          sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
        } else {
          sortState = { key, direction: 'asc' };
        }
        render();
      };
    });

    document.getElementById('saveBtn').onclick = async () => {
      const name = document.getElementById('nameInput').value.trim();
      const species = document.getElementById('speciesInput').value.trim();
      const chroma = document.getElementById('chromaInput').value;
      const skill1 = document.getElementById('skill1').value.trim();
      const skill2 = document.getElementById('skill2').value.trim();
      const cls = classInput.value;
      const msg = document.getElementById('modalMsg');
      msg.textContent = '';
      if (!name) { msg.textContent = 'Name required.'; return; }
      try {
        const validation = validateStatSelections();
        if (!validation.valid) { msg.textContent = validation.message; return; }
        currentUser = currentUser || await requireUser();
        const base_stats = buildStatsFromWizard();
        const class_progression = [{ class: cls, tier: 1, level_acquired: 1 }];
        const startingChoices = gatherStartingAbilityChoices();
        if (!startingChoices.length) {
          msg.textContent = 'Pick at least one starting class ability choice.';
          return;
        }
        const skills = [];
        if (skill1) skills.push({ name: skill1, bonus: Number(document.getElementById('skill1Bonus').value) });
        if (skill2) skills.push({ name: skill2, bonus: Number(document.getElementById('skill2Bonus').value) });

        const { data, error } = await sb.from('xrrpg_characters').insert({
          user_id: currentUser.id,
          name,
          base_stats: {
            ...base_stats,
            species,
            chroma,
            class_ability_choices: {
              [`${cls}-T1-L1-0`]: startingChoices
            }
          },
          class_progression,
          skills
        }).select('id').single();
        if (error) throw error;

        modal.classList.add('hidden');
        await withLoading('Refreshing character list…', loadCharacters);
        window.location.href = `/xrrpg-2.0/xrrpg-character.html?id=${data.id}`;
      } catch (error) {
        msg.textContent = error.message;
      }
    };

    const importCharacterBtn = document.getElementById('importCharacterBtn');
    const importCharacterInput = document.getElementById('importCharacterInput');

    importCharacterBtn.onclick = async () => {
      try {
        currentUser = currentUser || await requireUser();
      } catch (_error) {
        return;
      }
      importCharacterInput.value = "";
      importCharacterInput.click();
    };

    importCharacterInput.onchange = async (event) => {
      const file = event.target.files?.[0];
      if (!file) return;
      try {
        currentUser = currentUser || await requireUser();
        const payload = JSON.parse(await file.text());
        await importCharacterFromPayload(payload);
      } catch (error) {
        alert(error.message || 'Failed to import character.');
      }
    };

    withLoading('Loading characters…', loadCharacters);
  </script>
</body>
</html>
