<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>XRRPG Character Sheet</title>
  <link rel="stylesheet" href="/shared/style.css">
</head>
<body class="wr-scope">
  <div id="nav"></div>
  <main class="wrap sheet">
    <header>
      <div style="display:flex; align-items:center; gap:0.5rem; justify-content:space-between; flex-wrap:wrap;">
        <a class="action-btn" href="/xrrpg-2.0/xrrpg-character-manager.html" aria-label="Back to XRRPG character manager">
          <span aria-hidden="true">←</span>
          <span>Back to XRRPG Character Manager</span>
        </a>
      </div>
      <h1>XRRPG Character Sheet</h1>
      <div id="ownershipNotice" class="mono muted hidden"></div>
    </header>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>Character</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
      <div class="collapsible-body">
        <div class="sheet-actions">
          <label>Name <input id="nameInput" maxlength="48" /></label>
          <label>Species <input id="speciesInput" maxlength="48" /></label>
          <label>Chroma <input id="chromaInput" maxlength="16" /></label>
        </div>
      </div>
    </section>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>Core Stats</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
      <div class="collapsible-body">
        <div class="xrrpg-core-stats-grid">
        <div class="xrrpg-core-stats-card">
          <h3>Level & Mastery</h3>
          <div class="xrrpg-stat-line xrrpg-stat-line--compact">
            <label title="Character level from 1 to 9.">Level <input id="levelInput" type="number" min="1" max="9" /></label>
            <label title="Mastery die used for class actions.">Mastery Die <input id="masteryDieInput" /></label>
          </div>
        </div>
        <div class="xrrpg-core-stats-card">
          <h3>Stamina</h3>
          <div class="xrrpg-stat-line xrrpg-stat-line--compact">
            <label title="Current stamina consumed.">Stamina <input id="staminaUsedInput" type="number" min="0" /></label>
            <label title="Maximum stamina available for class abilities.">Stamina Max <input id="staminaTotalInput" type="number" min="0" /></label>
          </div>
        </div>
      </div>
      <div class="xrrpg-core-stats-card xrrpg-core-stats-card--full">
        <h3>Basic Stats</h3>
        <div class="xrrpg-stat-line xrrpg-stat-line--compact">
          <label title="Vigor supports movement, power, and will.">Vigor <input id="vigorInput" type="number" /></label>
          <label title="Endurance supports resilience and toughness.">Endurance <input id="enduranceInput" type="number" /></label>
          <label title="Intuition supports dexterity, perception, and charisma.">Intuition <input id="intuitionInput" type="number" /></label>
          <label title="Wit supports logic, innovation, and memory.">Wit <input id="witInput" type="number" /></label>
        </div>
      </div>
        <div class="xrrpg-row" style="margin-top:0.8rem;">
          <button id="levelUpBtn" type="button">Level Up (Class/Tier)</button>
        </div>
        <div id="status" class="mono muted"></div>
      </div>
    </section>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>Health & Injuries</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
      <div class="collapsible-body">
        <div class="stat-inputs">
        <label title="Maximum HP from your build and progression.">Max HP <input id="hpInput" type="number" /></label>
        <label title="Current HP after damage/healing.">Current HP <input id="currentHpInput" type="number" /></label>
      </div>
        <div class="xrrpg-row" style="margin-top:0.8rem;">
          <button id="takeInjuryBtn" type="button">Take Injury</button>
        </div>
        <div id="injuryTracker" class="xrrpg-injury-tracker"></div>
      </div>
    </section>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>Resource Tracking</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
      <div class="collapsible-body">
        <div class="xrrpg-resource-grid">
        <div class="xrrpg-resource-card">
          <h3>Powerful Items</h3>
          <div class="xrrpg-resource-fields">
            <label title="Max number of powerful items you can actively use.">Powerful Item Limit <input id="powerfulItemLimitInput" type="number" min="0" /></label>
            <label title="Absolute cap for powerful item upgrades.">Powerful Item Max Tier <input id="powerfulItemMaxInput" type="number" min="0" /></label>
          </div>
        </div>
        <div class="xrrpg-resource-card">
          <h3>Xenic Decay</h3>
          <div class="xrrpg-resource-fields">
            <label title="Current xenic decay level.">Xenic Decay Level <input id="xenicDecayInput" type="number" min="0" /></label>
            <label title="Total number of decay cleanses.">Times Cleansed <input id="timesCleansedInput" type="number" min="0" /></label>
          </div>
        </div>
        <div class="xrrpg-resource-card">
          <h3>Party</h3>
          <div class="xrrpg-resource-fields">
            <label title="Party progression tier used for group actions.">Party Tier <input id="partyTierInput" type="number" min="1" /></label>
          </div>
        </div>
        </div>
      </div>
    </section>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>Skills</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
      <div class="collapsible-body">
        <div id="skillList" class="mono muted">No skills saved.</div>
        <div class="xrrpg-row" style="margin-top:0.5rem; gap:0.5rem;"><button id="addSkillBtn" type="button">Add Skill</button></div>
      </div>
    </section>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>Class Details</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
      <div class="collapsible-body">
        <div id="classAbilityList" class="ability-list"></div>
      </div>
    </section>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>Character Notes</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
      <div class="collapsible-body">
        <div class="xrrpg-notes-stack">
        <label>Appearance<textarea id="appearanceInput"></textarea></label>
        <label>Personality<textarea id="personalityInput"></textarea></label>
        <label>Motivation<textarea id="motivationInput"></textarea></label>
        <label>BACKSTORY<textarea id="backstoryInput"></textarea></label>
        <label>Extra Notes<textarea id="extraNotesInput"></textarea></label>
        </div>
      </div>
    </section>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>History</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
      <div class="collapsible-body">
        <table class="table-full">
        <thead>
          <tr>
            <th><button type="button" class="table-sort" data-sort="created_at">Date</button></th>
            <th><button type="button" class="table-sort" data-sort="event_type">Type</button></th>
            <th><button type="button" class="table-sort" data-sort="event_label">Event</button></th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="historyTable"><tr><td colspan="4">Loading…</td></tr></tbody>
        </table>
      </div>
    </section>
  </main>

  <div id="loadingOverlay" class="xr-loading-overlay" aria-live="polite" aria-busy="true">
    <div class="xr-loading-spinner" aria-hidden="true"></div>
    <div id="loadingOverlayText" class="mono">Loading character sheet…</div>
  </div>

  <div id="levelModal" class="xr-modal hidden">
    <div class="xr-modal-backdrop"></div>
    <div class="xr-modal-card">
      <h2>Level Up</h2>
      <p class="muted">Pick a class level. Existing class levels advance to new tier (I → II → III).</p>
      <label>Class
        <select id="levelClassSelect"></select>
      </label>
      <div id="levelClassSummary" class="muted"></div>
      <div id="levelBenefitSummary" class="muted"></div>
      <div>
        <label>Ability choices for this level</label>
        <div id="levelAbilityChoices" class="xrrpg-notes-stack"></div>
        <button id="addLevelAbilityBtn" type="button" class="wr-mt-0-5">Add Ability Choice</button>
      </div>
      <p class="muted">Pick abilities here while leveling up. The Abilities area lists these choices automatically.</p>
      <div id="levelStatRow" class="xrrpg-notes-stack">
        <label>Stat increase target #1
          <select id="levelStatBoostSelect1">
            <option value="">-- Select stat --</option>
            <option value="vigor">Vigor</option>
            <option value="endurance">Endurance</option>
            <option value="intuition">Intuition</option>
            <option value="wit">Wit</option>
          </select>
        </label>
        <label id="levelStatBoostSelect2Wrap" class="hidden">Stat increase target #2
          <select id="levelStatBoostSelect2">
            <option value="">-- Select stat --</option>
            <option value="vigor">Vigor</option>
            <option value="endurance">Endurance</option>
            <option value="intuition">Intuition</option>
            <option value="wit">Wit</option>
          </select>
        </label>
      </div>
      <div id="levelSkillRow" class="xrrpg-notes-stack">
        <label>Skill upgrade type
          <select id="levelSkillModeSelect">
            <option value="add">Add new skill</option>
            <option value="plus1">+1 to existing skill</option>
          </select>
        </label>
        <label id="levelSkillNewWrap">New skill name
          <input id="levelSkillNewInput" placeholder="Stealth" maxlength="48" />
        </label>
        <label id="levelSkillExistingWrap" class="hidden">Existing skill
          <select id="levelSkillExistingSelect">
            <option value="">-- Select existing skill --</option>
          </select>
        </label>
      </div>
      <div class="xr-modal-actions">
        <button id="confirmLevelBtn" type="button">Apply</button>
        <button id="cancelLevelBtn" type="button">Cancel</button>
      </div>
      <div id="levelMsg" class="mono muted"></div>
    </div>
  </div>

  <div id="injuryModal" class="xr-modal hidden">
    <div class="xr-modal-backdrop"></div>
    <div class="xr-modal-card">
      <h2>Take Injury</h2>
      <p class="muted">Minor: 1 DMG + next Action -2. Severe: 2 DMG + lose 1 Stamina. Critical: 3 DMG + -1 all Actions until healed.</p>
      <div class="stat-inputs">
        <label>Injury type
          <select id="injuryTypeInput">
            <option value="minor">Minor</option>
            <option value="severe">Severe</option>
            <option value="critical">Critical</option>
          </select>
        </label>
        <label>Injury label
          <input id="injuryLabelInput" maxlength="64" placeholder="Bruised / Lacerated / Bleeding Out" />
        </label>
      </div>
      <div class="xr-modal-actions">
        <button id="confirmInjuryBtn" type="button">Apply Injury</button>
        <button id="cancelInjuryBtn" type="button">Cancel</button>
      </div>
      <div id="injuryMsg" class="mono muted"></div>
    </div>
  </div>

  <div id="skillModal" class="xr-modal hidden">
    <div class="xr-modal-backdrop"></div>
    <div class="xr-modal-card">
      <h2>Add Skill</h2>
      <div class="xrrpg-notes-stack">
        <label>Skill name
          <input id="skillModalName" maxlength="48" placeholder="Stealth" />
        </label>
        <label>Skill bonus
          <select id="skillModalBonus"><option value="2">+2 (General)</option><option value="3">+3 (Specific)</option></select>
        </label>
      </div>
      <div class="xr-modal-actions">
        <button id="saveSkillModalBtn" type="button">Save Skill</button>
        <button id="cancelSkillModalBtn" type="button">Cancel</button>
      </div>
      <div id="skillModalMsg" class="mono muted"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="/shared/auth.js"></script>
  <script src="/shared/nav.js"></script>
  <script src="/xrrpg-2.0/class-abilities.js"></script>
  <script>
    window.__useLocalLoadingOverlay = true;
    const sb = window.supabaseClient;
    const params = new URLSearchParams(window.location.search);
    const characterId = params.get('id');
    const classNames = [
      'Warrior','Mentalist','Tank','Druid','Elementalist','Summoner','Mystic','Alchemist','Physic','Possessor','Bard','Enchanter','Sorcerer','Warlock','Cleric','Demititan','Emitter Specialist','Dronemaster','Brawler','Explosives Expert','Gunslinger','Swordmaster'
    ];
    const historyTable = document.getElementById('historyTable');
    let currentUser = null;
    let character = null;
    let history = [];
    let historySort = { key: 'created_at', direction: 'desc' };
    let isRendering = false;
    let autosaveTimer = null;
    let canEdit = false;
    const classAbilities = window.XRRPG_CLASS_ABILITIES || {};
    const ADEPT_CLASSES = new Set(['Warrior', 'Mentalist', 'Tank', 'Druid']);
    const ADEPT_CHROMA_REQUIREMENTS = {
      Warrior: 'Red',
      Tank: 'Blue',
      Druid: 'Green',
      Mentalist: 'Grey'
    };
    const CLASS_SUMMARIES = {
      'Warrior': 'Adept frontline striker. Tiered basic/advanced powers; each class level raises your power tiers.',
      'Mentalist': 'Adept mind specialist. Tiered control/mental powers that scale by class tier.',
      'Tank': 'Adept defender with scaling mitigation and control powers.',
      'Druid': 'Adept nature/healing specialist with escalating support and survivability powers.',
      'Elementalist': 'Spiritualist element manipulator. Class levels unlock higher technique tiers and longer range.',
      'Summoner': 'Spiritualist spirit commander. Class levels increase spirit options and summons.',
      'Mystic': 'Spiritualist with spirit roster upgrades and broader spirit spell access as levels increase.',
      'Alchemist': 'Magician potion specialist. More brews/day, known recipes, and mixes per class level.',
      'Physic': 'Magician spellcaster. Class level raises max spell tier, known spells, and concentration limits.',
      'Possessor': 'Magician taboo caster with servants. Class levels increase spell tier and servant options.',
      'Bard': 'Magician support caster with scaling spell tier, spell count, and concentration.',
      'Enchanter': 'Magician substance mage. Class level raises spell tier and chaos/concentration features.',
      'Sorcerer': 'Mage specialization path. Higher class levels unlock more specialization powers.',
      'Warlock': 'Mage pact caster with risky dark powers split by level bands.',
      'Cleric': 'Mage pact support class with healing/protection powers split by level bands.',
      'Demititan': 'Mage element body-shifter with explicit multi-level element progression.',
      'Emitter Specialist': 'Technologist zoning/shielding expert. Higher class level raises emitter limits.',
      'Dronemaster': 'Technologist drone commander. Higher class level boosts drone count/durability.',
      'Brawler': 'Technologist suit brawler. Higher class level increases installed and known effects.',
      'Explosives Expert': 'Technologist AOE bomber. Higher class level increases blast scale and output/day.',
      'Gunslinger': 'Technologist firearm crafter. Higher class level raises gadget tier and gun effects.',
      'Swordmaster': 'Technologist melee/beam fighter. Higher class level raises damage and attack shapes.'
    };
    const LEVELING_RULES = {
      1: { stamina_base: 12, skill_mode: 'add_or_plus1', stat_points: 0, stat_bonus: 1, skill_points: 0, powerful_item_limit: 2, powerful_item_max: 1 },
      2: { stamina_base: 14, skill_mode: 'stat', stat_points: 1, stat_bonus: 1, skill_points: 0, powerful_item_limit: 3, powerful_item_max: 1 },
      3: { stamina_base: 16, skill_mode: 'skill_plus2', stat_points: 0, stat_bonus: 1, skill_points: 2, powerful_item_limit: 3, powerful_item_max: 1 },
      4: { stamina_base: 18, skill_mode: 'stat', stat_points: 1, stat_bonus: 1, skill_points: 0, powerful_item_limit: 4, powerful_item_max: 2 },
      5: { stamina_base: 20, skill_mode: 'add_or_plus1', stat_points: 0, stat_bonus: 1, skill_points: 0, powerful_item_limit: 5, powerful_item_max: 2 },
      6: { stamina_base: 22, skill_mode: 'stat', stat_points: 1, stat_bonus: 1, skill_points: 0, powerful_item_limit: 6, powerful_item_max: 2 },
      7: { stamina_base: 24, skill_mode: 'skill_plus2', stat_points: 0, stat_bonus: 1, skill_points: 2, powerful_item_limit: 7, powerful_item_max: 3 },
      8: { stamina_base: 25, skill_mode: 'stat', stat_points: 1, stat_bonus: 1, skill_points: 0, powerful_item_limit: 8, powerful_item_max: 3 },
      9: { stamina_base: 30, skill_mode: 'stat', stat_points: 1, stat_bonus: 2, skill_points: 0, powerful_item_limit: 9, powerful_item_max: 3 }
    };

    function setLoading(message = 'Loading…') {
      const overlay = document.getElementById('loadingOverlay');
      const text = document.getElementById('loadingOverlayText');
      if (text) text.textContent = message;
      if (overlay) overlay.classList.remove('hidden');
    }

    function clearLoading() {
      const overlay = document.getElementById('loadingOverlay');
      if (overlay) overlay.classList.add('hidden');
    }

    async function withLoading(message, task) {
      setLoading(message);
      try {
        return await task();
      } finally {
        clearLoading();
      }
    }

    function applyOwnershipPermissions() {
      const ownershipNotice = document.getElementById('ownershipNotice');
      const readOnly = !canEdit;
      ownershipNotice.classList.toggle('hidden', !readOnly);
      ownershipNotice.textContent = readOnly ? 'Read-only mode: You can view this character, but only the owner can edit it.' : '';

      const editableIds = [
        'nameInput','speciesInput','chromaInput','levelInput','masteryDieInput','vigorInput','enduranceInput','intuitionInput','witInput',
        'staminaTotalInput','staminaUsedInput','hpInput','currentHpInput','powerfulItemLimitInput','powerfulItemMaxInput',
        'partyTierInput','xenicDecayInput','timesCleansedInput','appearanceInput','personalityInput','motivationInput','backstoryInput','extraNotesInput',
        'levelUpBtn','takeInjuryBtn','addSkillBtn','confirmLevelBtn','confirmInjuryBtn','saveSkillModalBtn','addLevelAbilityBtn'
      ];
      editableIds.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.disabled = readOnly;
      });
    }

    classNames.forEach(name => {
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      document.getElementById('levelClassSelect').appendChild(opt);
    });

    async function requireUser() {
      const { data: { user } } = await sb.auth.getUser();
      if (!user) throw new Error('No user');
      return user;
    }

    function toMasteryDie(level) {
      if (level >= 9) return 'd12';
      if (level >= 7) return 'd10';
      if (level >= 5) return 'd8';
      if (level >= 3) return 'd6';
      return 'd4';
    }

    function parseNotes() {
      if (!character?.notes) return {};
      try {
        return JSON.parse(character.notes);
      } catch (_error) {
        return { extra: character.notes };
      }
    }

    function readNotesFromInputs() {
      return JSON.stringify({
        appearance: document.getElementById('appearanceInput').value.trim(),
        personality: document.getElementById('personalityInput').value.trim(),
        motivation: document.getElementById('motivationInput').value.trim(),
        backstory: document.getElementById('backstoryInput').value.trim(),
        extra: document.getElementById('extraNotesInput').value.trim()
      });
    }

    function normalizeBaseStats(baseStats) {
      if (!baseStats || typeof baseStats !== 'object') return {};
      const normalized = { ...baseStats };
      if (normalized.stamina === undefined && normalized.stamina_used !== undefined) {
        normalized.stamina = normalized.stamina_used;
      }
      if (Object.prototype.hasOwnProperty.call(normalized, 'stamina_used')) {
        delete normalized.stamina_used;
      }
      return normalized;
    }

    function readStatsFromInputs() {
      return {
        ...character.base_stats,
        species: document.getElementById('speciesInput').value.trim(),
        chroma: document.getElementById('chromaInput').value.trim(),
        level: Number(document.getElementById('levelInput').value) || 1,
        hp: Number(document.getElementById('hpInput').value) || 0,
        current_hp: Number(document.getElementById('currentHpInput').value) || 0,
        vigor: Number(document.getElementById('vigorInput').value) || 0,
        endurance: Number(document.getElementById('enduranceInput').value) || 0,
        intuition: Number(document.getElementById('intuitionInput').value) || 0,
        wit: Number(document.getElementById('witInput').value) || 0,
        mastery_die: document.getElementById('masteryDieInput').value.trim() || 'd4',
        stamina_max: Number(document.getElementById('staminaTotalInput').value) || 0,
        stamina_total: Number(document.getElementById('staminaTotalInput').value) || 0,
        stamina: Number(document.getElementById('staminaUsedInput').value) || 0,
        powerful_item_limit: Number(document.getElementById('powerfulItemLimitInput').value) || 0,
        powerful_item_max: Number(document.getElementById('powerfulItemMaxInput').value) || 0,
        party_tier: Number(document.getElementById('partyTierInput').value) || 1,
        xenic_decay_level: Number(document.getElementById('xenicDecayInput').value) || 0,
        times_cleansed: Number(document.getElementById('timesCleansedInput').value) || 0
      };
    }

    function injurySummary(injuries) {
      return {
        minor: injuries.filter(injury => injury.type === 'minor'),
        severe: injuries.filter(injury => injury.type === 'severe'),
        critical: injuries.filter(injury => injury.type === 'critical')
      };
    }

    function injuryDebuff(type) {
      if (type === 'minor') return 'Debuff: next Action is -2.';
      if (type === 'severe') return 'Debuff: lose 1 Stamina.';
      return 'Debuff: -1 to all Actions until healed.';
    }

    function addLevelAbilityChoice(value = '') {
      const wrap = document.getElementById('levelAbilityChoices');
      const row = document.createElement('label');
      row.className = 'xrrpg-row';
      row.innerHTML = '<input class="level-ability-choice" maxlength="80" placeholder="Ability name" /> <button type="button" class="remove-level-ability-btn">Remove</button>';
      row.querySelector('.level-ability-choice').value = value;
      row.querySelector('.remove-level-ability-btn').onclick = () => row.remove();
      wrap.appendChild(row);
    }

    function readLevelAbilityChoices() {
      return Array.from(document.querySelectorAll('.level-ability-choice'))
        .map(input => input.value.trim())
        .filter(Boolean);
    }
    function cloneCharacterState() {
      return {
        name: character.name,
        notes: character.notes,
        base_stats: JSON.parse(JSON.stringify(character.base_stats || {})),
        class_progression: JSON.parse(JSON.stringify(character.class_progression || [])),
        skills: JSON.parse(JSON.stringify(character.skills || []))
      };
    }

    function levelRule(level) {
      return LEVELING_RULES[level] || LEVELING_RULES[9];
    }

    function tierText(tiers = {}, tier) {
      const tierNum = Number(tier);
      const candidates = [
        String(tierNum),
        `tier_${tierNum}`,
        `tier${tierNum}`,
        `tier ${tierNum}`,
        `Tier ${tierNum}`,
        `Tier ${['I', 'II', 'III'][tierNum - 1] || tierNum}`,
        ['I', 'II', 'III'][tierNum - 1] || String(tierNum)
      ];
      const keys = Object.keys(tiers || {});
      const match = keys.find(key => candidates.some(candidate => key.toLowerCase() === String(candidate).toLowerCase()));
      return String(match ? tiers[match] : '').trim();
    }

    function parsedTierAbilities(cls, tier) {
      return (classAbilities[cls] || []).filter(item => {
        const name = String(item?.name || '').trim();
        if (!name || /^\d+$/.test(name)) return false;
        return !!tierText(item?.tiers || {}, tier) || Object.keys(item?.tiers || {}).some(key => String(key).replace(/\D/g, '') === String(tier));
      });
    }

    function abilityByName(cls, name) {
      const target = String(name || '').replace(/\s*\(auto\)\s*$/i, '').trim().toLowerCase();
      if (!target) return null;
      return (classAbilities[cls] || []).find(item => String(item?.name || '').trim().toLowerCase() === target) || null;
    }

    function abilityDetailText(cls, name, tier) {
      const ability = abilityByName(cls, name);
      if (!ability) return '';
      return tierText(ability.tiers || {}, tier);
    }

    function findChosenAdeptAdvancedAbility(chosenAbilities, progression, className, currentIndex) {
      for (let i = currentIndex; i >= 0; i -= 1) {
        const row = progression[i];
        if (row.class !== className) continue;
        const rowKey = `${row.class}-T${row.tier}-L${row.level_acquired}-${i}`;
        const rowChoices = Array.isArray(chosenAbilities[rowKey]) ? chosenAbilities[rowKey] : [];
        const chosen = rowChoices.find(choice => {
          const text = String(choice || '').trim();
          if (!text) return false;
          if (/auto-upgraded/i.test(text)) return false;
          if (/\(auto\)$/i.test(text)) return false;
          return !!abilityByName(className, text);
        });
        if (chosen) return chosen;
      }
      return '';
    }

    function staminaMaxForLevel(level, intuition, wit) {
      const base = levelRule(level).stamina_base;
      return base + Number(intuition || 0) + Number(wit || 0);
    }

    function isAdeptClass(cls) {
      return ADEPT_CLASSES.has(String(cls || '').trim());
    }

    function classChromaRequirement(cls) {
      return ADEPT_CHROMA_REQUIREMENTS[String(cls || '').trim()] || null;
    }

    function validateClassChromaRequirement(cls, chroma) {
      const required = classChromaRequirement(cls);
      if (!required || chroma === required) return { valid: true, message: '' };
      return {
        valid: false,
        message: `${cls} can only be selected by ${required} chroma characters.`
      };
    }

    function adeptBasicAbilityName(cls) {
      const basic = (classAbilities[cls] || []).find(item => {
        const tiers = item?.tiers || {};
        return Object.prototype.hasOwnProperty.call(tiers, '0') && !!tierText(tiers, 1);
      });
      return String(basic?.name || '').trim();
    }

    function syncLevelClassOptionsByChroma() {
      const chroma = String(character?.base_stats?.chroma || '').trim();
      const select = document.getElementById('levelClassSelect');
      Array.from(select.options).forEach(option => {
        const required = classChromaRequirement(option.value);
        option.disabled = !!required && chroma !== required;
      });
      if (select.selectedOptions[0]?.disabled) {
        const fallback = Array.from(select.options).find(option => !option.disabled);
        if (fallback) select.value = fallback.value;
      }
    }

    function requiredAdeptAbilityChoices(tier) {
      if (tier === 1) return 1;
      if (tier >= 4) return 1;
      return 0;
    }

    function parsedAdeptAdvancedAbilities(cls) {
      const basic = adeptBasicAbilityName(cls);
      const byName = new Map();
      [1, 2, 3].forEach(tier => {
        parsedTierAbilities(cls, tier)
          .filter(item => item.name !== basic)
          .forEach(item => {
            const name = String(item.name || '').trim();
            if (!name || byName.has(name)) return;
            byName.set(name, item);
          });
      });
      return Array.from(byName.values());
    }

    function renderLevelAbilityOptions() {
      const cls = document.getElementById('levelClassSelect').value;
      const progression = character.class_progression || [];
      const level = Math.min(9, Number(character.base_stats?.level || 1) + 1);
      const tier = progression.filter(item => item.class === cls).length + 1;
      const rule = levelRule(level);
      const adeptClass = isAdeptClass(cls);
      const benefitBits = [];
      if (rule.stat_points > 0) {
        const totalStatGain = Number(rule.stat_points || 0) * Number(rule.stat_bonus || 1);
        if (Number(rule.stat_bonus || 1) > 1 && Number(rule.stat_points || 0) === 1) {
          benefitBits.push(`+${totalStatGain} to one stat`);
        } else {
          benefitBits.push(`+${totalStatGain} stat`);
        }
      }
      if (rule.skill_mode === 'add_or_plus1') benefitBits.push('add a skill or +1 to an existing skill');
      if (rule.skill_mode === 'skill_plus2') benefitBits.push('+2 to one skill');
      if (adeptClass && tier === 1) {
        benefitBits.push('Adept basic ability (auto) + choose 1 advanced ability');
      } else if (adeptClass && tier <= 3) {
        benefitBits.push(`existing advanced adept ability scales to tier ${tier} automatically`);
      } else if (adeptClass && tier >= 4) {
        benefitBits.push('choose 1 advanced adept ability (no tier restrictions)');
      }
      document.getElementById('levelClassSummary').textContent = CLASS_SUMMARIES[cls] || 'Class summary unavailable.';
      document.getElementById('levelBenefitSummary').textContent = `This level up goes to Character Level ${level} and grants: ${benefitBits.join(', ') || 'class progression only'}.`;
      document.getElementById('levelStatRow').classList.toggle('hidden', rule.stat_points === 0);
      document.getElementById('levelSkillRow').classList.toggle('hidden', !['add_or_plus1', 'skill_plus2'].includes(rule.skill_mode));
      document.getElementById('levelStatBoostSelect2Wrap').classList.toggle('hidden', rule.stat_points < 2);
      syncSkillUpgradeUi(rule.skill_mode);
      const abilities = adeptClass && tier >= 4
        ? parsedAdeptAdvancedAbilities(cls)
        : parsedTierAbilities(cls, tier);
      const choiceWrap = document.getElementById('levelAbilityChoices');
      const requiredChoices = adeptClass ? requiredAdeptAbilityChoices(tier) : 1;
      if (adeptClass && requiredChoices === 0) {
        choiceWrap.innerHTML = `<div class="muted">Adept progression at Tiers 2-3 does not grant a new advanced ability pick. Your existing advanced adept power automatically scales to Tier ${tier}.</div>`;
        document.getElementById('levelMsg').textContent = `Advancing ${cls} to Tier ${tier}.`;
        return;
      }
      if (!abilities.length) {
        choiceWrap.innerHTML = '<div class="muted">No parsed class abilities found for this class/tier. Add manual ability entries below.</div>';
        addLevelAbilityChoice();
        return;
      }
      let filtered = abilities;
      if (adeptClass && tier === 1) {
        const basicAbility = adeptBasicAbilityName(cls);
        filtered = abilities.filter(item => item.name !== basicAbility);
        if (basicAbility) {
          choiceWrap.innerHTML = `<div class="muted">Basic ability gained automatically: <strong>${basicAbility}</strong>. Choose one advanced adept power below.</div>`;
        }
      } else if (adeptClass && tier >= 4) {
        choiceWrap.innerHTML = '<div class="muted">Tier 4+ adept picks are unrestricted. Choose any advanced adept power below, or type a custom one.</div>';
      }
      if (!filtered.length) {
        choiceWrap.innerHTML += '<div class="muted">No parsed class abilities found for this class/tier. Add manual ability entries below.</div>';
        addLevelAbilityChoice();
        document.getElementById('levelMsg').textContent = `Advancing ${cls} to Tier ${tier}.`;
        return;
      }
      choiceWrap.innerHTML += filtered.map(item => `<label><input type="checkbox" class="level-ability-option" value="${item.name.replace(/"/g,'&quot;')}" /> ${item.name} <span class="muted">${tierText(item.tiers || {}, tier)}</span></label>`).join('');
      addLevelAbilityChoice();
      document.getElementById('levelMsg').textContent = `Advancing ${cls} to Tier ${tier}.`;
    }

    function syncSkillUpgradeUi(skillMode) {
      const isVisible = ['add_or_plus1', 'skill_plus2'].includes(skillMode);
      if (!isVisible) return;
      const skills = character.skills || [];
      const existingSelect = document.getElementById('levelSkillExistingSelect');
      const modeSelect = document.getElementById('levelSkillModeSelect');
      const newWrap = document.getElementById('levelSkillNewWrap');
      const existingWrap = document.getElementById('levelSkillExistingWrap');
      const mode = skillMode === 'skill_plus2' ? 'plus1' : modeSelect.value;
      modeSelect.value = mode;
      existingSelect.innerHTML = '<option value="">-- Select existing skill --</option>';
      skills.forEach(skill => {
        const option = document.createElement('option');
        option.value = skill.name || '';
        option.textContent = `${skill.name || 'Unnamed Skill'} (+${Number(skill.bonus || 0)})`;
        existingSelect.appendChild(option);
      });
      modeSelect.disabled = skillMode === 'skill_plus2';
      newWrap.classList.toggle('hidden', mode !== 'add');
      existingWrap.classList.toggle('hidden', mode === 'add');
    }

    function gatherLevelChoices() {
      const checked = Array.from(document.querySelectorAll('.level-ability-option:checked')).map(input => input.value.trim()).filter(Boolean);
      const typed = readLevelAbilityChoices();
      return [...new Set([...checked, ...typed])];
    }


    function renderSkillList() {
      const skills = character.skills || [];
      const wrap = document.getElementById('skillList');
      if (!skills.length) {
        wrap.innerHTML = 'No skills saved.';
        return;
      }
      wrap.innerHTML = skills.map((skill, index) => `
        <div class="xrrpg-row" style="gap:0.5rem; align-items:center; margin-bottom:0.3rem;">
          <input data-skill-name="${index}" value="${(skill.name || '').replace(/"/g, '&quot;')}" maxlength="48" />
          <input data-skill-bonus="${index}" type="number" min="0" max="9" value="${Number(skill.bonus || 0)}" style="width:70px;" />
          <button type="button" data-skill-delete="${index}">Delete</button>
        </div>
      `).join('');
      wrap.querySelectorAll('[data-skill-name], [data-skill-bonus]').forEach(input => {
        input.disabled = !canEdit;
        input.oninput = () => updateSkill(Number(input.dataset.skillName ?? input.dataset.skillBonus));
      });
      wrap.querySelectorAll('[data-skill-delete]').forEach(btn => {
        btn.disabled = !canEdit;
        btn.onclick = () => removeSkill(Number(btn.dataset.skillDelete));
      });
    }

    function renderInjuryTracker() {
      const injuries = Array.isArray(character?.base_stats?.injuries) ? character.base_stats.injuries : [];
      const grouped = injurySummary(injuries);
      const wrap = document.getElementById('injuryTracker');
      wrap.innerHTML = ['minor', 'severe', 'critical'].map(type => {
        const rows = grouped[type].length
          ? grouped[type].map((injury, idx) => {
            const resolveBtn = (type === 'minor' || type === 'severe') && !injury.debuff_resolved
              ? `<button type="button" data-resolve-type="${type}" data-resolve-index="${idx}">Resolve Debuff</button>`
              : '';
            const debuffText = (type === 'minor' || type === 'severe') && injury.debuff_resolved ? 'Debuff resolved.' : injuryDebuff(type);
            return `<div class="xrrpg-injury-item"><div><strong>${injury.label || 'Unnamed injury'}</strong><div class="muted">${debuffText}</div></div><div class="xrrpg-row"><button type="button" data-heal-type="${type}" data-heal-index="${idx}">Heal</button>${resolveBtn}</div></div>`;
          }).join('')
          : '<div class="muted">None</div>';
        return `<div class="xrrpg-injury-group"><h3>${type[0].toUpperCase() + type.slice(1)}</h3>${rows}</div>`;
      }).join('');

      wrap.querySelectorAll('[data-heal-type]').forEach(button => {
        button.disabled = !canEdit;
        button.onclick = () => healInjury(button.dataset.healType, Number(button.dataset.healIndex));
      });
      wrap.querySelectorAll('[data-resolve-type]').forEach(button => {
        button.disabled = !canEdit;
        button.onclick = () => resolveInjuryDebuff(button.dataset.resolveType, Number(button.dataset.resolveIndex));
      });
    }

    function renderCharacter() {
      isRendering = true;
      const s = character.base_stats || {};
      const notes = parseNotes();
      document.getElementById('nameInput').value = character.name || '';
      document.getElementById('speciesInput').value = s.species || '';
      document.getElementById('chromaInput').value = s.chroma || '';
      document.getElementById('levelInput').value = s.level || 1;
      document.getElementById('hpInput').value = s.hp || 0;
      document.getElementById('currentHpInput').value = s.current_hp ?? s.hp ?? 0;
      document.getElementById('vigorInput').value = s.vigor || 0;
      document.getElementById('enduranceInput').value = s.endurance || 0;
      document.getElementById('intuitionInput').value = s.intuition || 0;
      document.getElementById('witInput').value = s.wit || 0;
      document.getElementById('masteryDieInput').value = s.mastery_die || 'd4';
      document.getElementById('staminaTotalInput').value = s.stamina_max ?? s.stamina_total ?? (10 + (s.intuition || 0) + (s.wit || 0));
      document.getElementById('staminaUsedInput').value = s.stamina ?? s.stamina_used ?? 0;
      document.getElementById('powerfulItemLimitInput').value = s.powerful_item_limit || 0;
      document.getElementById('powerfulItemMaxInput').value = s.powerful_item_max || 0;
      document.getElementById('partyTierInput').value = s.party_tier || 1;
      document.getElementById('xenicDecayInput').value = s.xenic_decay_level || 0;
      document.getElementById('timesCleansedInput').value = s.times_cleansed || 0;

      document.getElementById('appearanceInput').value = notes.appearance || '';
      document.getElementById('personalityInput').value = notes.personality || '';
      document.getElementById('motivationInput').value = notes.motivation || '';
      document.getElementById('backstoryInput').value = notes.backstory || '';
      document.getElementById('extraNotesInput').value = notes.extra || '';

      renderInjuryTracker();

      const chosenAbilities = s.class_ability_choices || {};
      const abilityWrap = document.getElementById('classAbilityList');
      if (!(character.class_progression || []).length) {
        abilityWrap.innerHTML = '<div class="muted">No class abilities yet.</div>';
      } else {
        const toAbilityBullets = (text) => {
          if (!text || !text.trim()) return [];
          return text
            .replace(/\r\n/g, '\n')
            .split('\n')
            .map(line => line.trim())
            .filter(Boolean)
            .flatMap(line => line
              .replace(/^[-*]\s*/, '')
              .split(/(?<=\.)\s+|\s*[;•]\s+|\s+(?=Can\s|Cannot\s|Gain\s|Gains\s|Get\s|Gets\s|May\s|Heal\s|Feel\s|See\s|Summon\s|Create\s|Use\s|Become\s|Choose\s|Attack\s|Deal\s)/)
            )
            .map(part => part.trim())
            .filter(Boolean);
        };

        const renderAdeptAbilityBlock = (label, name, detailText, fallbackText) => {
          if (!name) return `<h5 class="class-ability-subtitle">${label}</h5><div class="muted">${fallbackText}</div>`;
          const bullets = toAbilityBullets(detailText);
          return `<h5 class="class-ability-subtitle">${label}</h5><div class="muted"><strong>${name}</strong></div>${bullets.length ? `<ul>${bullets.map(line => `<li>${line}</li>`).join('')}</ul>` : '<div class="muted">No details recorded.</div>'}`;
        };

        abilityWrap.innerHTML = character.class_progression.map((entry, idx) => {
          const key = `${entry.class}-T${entry.tier}-L${entry.level_acquired}-${idx}`;
          const adeptClass = isAdeptClass(entry.class);
          const chosen = Array.isArray(chosenAbilities[key]) && chosenAbilities[key].length
            ? `<div class="muted">Chosen on level up: ${chosenAbilities[key].join(', ')}</div>`
            : '<div class="muted">Chosen on level up: none recorded</div>';
          if (adeptClass) {
            const adeptTier = Math.min(3, Number(entry.tier) || 1);
            const basicAbility = adeptBasicAbilityName(entry.class);
            const basicDetail = basicAbility ? abilityDetailText(entry.class, basicAbility, adeptTier) : '';
            const advancedAbility = findChosenAdeptAdvancedAbility(chosenAbilities, character.class_progression || [], entry.class, idx);
            const advancedDetail = advancedAbility ? abilityDetailText(entry.class, advancedAbility, adeptTier) : '';
            const details = [
              renderAdeptAbilityBlock('Basic', basicAbility, basicDetail, 'none recorded'),
              renderAdeptAbilityBlock('Advanced', advancedAbility, advancedDetail, 'none recorded')
            ];
            return `<section class="card collapsible section-card" data-collapsible><div class="collapsible-header"><h4 class="class-detail-card-title">${entry.class} Tier ${entry.tier} Abilities</h4><button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button></div><div class="collapsible-body">${chosen}${details.join('')}</div></section>`;
          }
          const available = (classAbilities[entry.class] || [])
            .filter(ability => ability.tiers && Object.prototype.hasOwnProperty.call(ability.tiers, String(entry.tier)))
            .map(ability => {
              const detailBullets = toAbilityBullets(ability.tiers[String(entry.tier)] || '');
              const detailHtml = detailBullets.length
                ? `<ul>${detailBullets.map(line => `<li>${line}</li>`).join('')}</ul>`
                : '<div class="muted">No details recorded.</div>';
              return `<li><strong>${ability.name}</strong>${detailHtml}</li>`;
            });
          const availableHtml = available.length ? `<ul>${available.join('')}</ul>` : '<div class="muted">Available: add manually for this class tier.</div>';
          return `<section class="card collapsible section-card" data-collapsible><div class="collapsible-header"><h4 class="class-detail-card-title">${entry.class} Tier ${entry.tier} Abilities</h4><button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button></div><div class="collapsible-body">${chosen}<h5 class="class-ability-subtitle">Available</h5>${availableHtml}</div></section>`;
        }).join('');
      }

      initCollapsibles(abilityWrap);

      renderSkillList();
      applyOwnershipPermissions();
      isRendering = false;
    }

    function updateCollapsibleButton(section) {
      const button = section?.querySelector(':scope > .collapsible-header .collapse-toggle') || section?.querySelector('.collapse-toggle');
      if (!button) return;
      const collapsed = section.classList.contains('collapsed');
      button.innerHTML = collapsed
        ? '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><circle cx="12" cy="12" r="2.5"></circle></svg>'
        : '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg>';
      button.setAttribute('aria-label', collapsed ? 'Show section' : 'Hide section');
      button.setAttribute('title', collapsed ? 'Show section' : 'Hide section');
    }

    function initCollapsibles(root = document) {
      root.querySelectorAll('[data-collapsible]').forEach(section => {
        const button = section.querySelector(':scope > .collapsible-header .collapse-toggle') || section.querySelector('.collapse-toggle');
        if (!button || button.dataset.boundCollapse === '1') {
          updateCollapsibleButton(section);
          return;
        }
        updateCollapsibleButton(section);
        button.dataset.boundCollapse = '1';
        button.addEventListener('click', () => {
          section.classList.toggle('collapsed');
          updateCollapsibleButton(section);
        });
      });
    }

    function renderHistory() {
      if (!history.length) {
        historyTable.innerHTML = '<tr><td colspan="4">No history yet.</td></tr>';
        return;
      }
      const dir = historySort.direction === 'asc' ? 1 : -1;
      const sorted = [...history].sort((a,b) => {
        const av = String(a[historySort.key] ?? '');
        const bv = String(b[historySort.key] ?? '');
        if (av < bv) return -1 * dir;
        if (av > bv) return 1 * dir;
        return 0;
      });
      historyTable.innerHTML = sorted.map(row => `
        <tr>
          <td>${new Date(row.created_at).toLocaleString()}</td>
          <td>${row.event_type}</td>
          <td>${row.event_label}</td>
          <td><button type="button" data-undo-id="${row.id}" ${row.event_payload?.undo && canEdit ? '' : 'disabled'}>Undo</button></td>
        </tr>
      `).join('');
    }

    async function loadCharacter() {
      currentUser = await requireUser();
      const { data, error } = await sb.from('xrrpg_characters')
        .select('id, user_id, name, base_stats, class_progression, skills, notes')
        .eq('id', characterId)
        .single();
      if (error) throw error;
      character = { ...data, base_stats: normalizeBaseStats(data.base_stats) };
      canEdit = character.user_id === currentUser.id;
      if (JSON.stringify(character.base_stats || {}) !== JSON.stringify(data.base_stats || {}) && canEdit) {
        await sb.from('xrrpg_characters')
          .update({ base_stats: character.base_stats, updated_at: new Date().toISOString() })
          .eq('id', characterId)
          .eq('user_id', currentUser.id);
      }
      renderCharacter();
    }

    async function loadHistory() {
      const { data, error } = await sb.from('xrrpg_history')
        .select('id, event_type, event_label, created_at, event_payload')
        .eq('character_id', characterId)
        .order('created_at', { ascending: false });
      if (error) throw error;
      history = data || [];
      renderHistory();
    }

    async function addHistory(eventType, eventLabel, eventPayload = {}) {
      if (!canEdit) return;
      await sb.from('xrrpg_history').insert({
        character_id: characterId,
        user_id: currentUser.id,
        event_type: eventType,
        event_label: eventLabel,
        event_payload: eventPayload
      });
      await loadHistory();
    }

    async function persistCharacterDraft() {
      if (!canEdit) return;
      const name = document.getElementById('nameInput').value.trim();
      const base_stats = readStatsFromInputs();
      const notes = readNotesFromInputs();
      const { error } = await sb.from('xrrpg_characters')
        .update({ name, notes, base_stats, updated_at: new Date().toISOString() })
        .eq('id', characterId)
        .eq('user_id', currentUser.id);
      if (error) {
        document.getElementById('status').textContent = error.message;
        return;
      }
      character.name = name;
      character.base_stats = base_stats;
      character.notes = notes;
      document.getElementById('status').textContent = 'Saved automatically.';
    }

    function scheduleAutosave() {
      if (!canEdit || isRendering || !character) return;
      if (autosaveTimer) window.clearTimeout(autosaveTimer);
      autosaveTimer = window.setTimeout(() => { persistCharacterDraft(); }, 350);
    }

    const levelModal = document.getElementById('levelModal');
    document.getElementById('levelUpBtn').onclick = () => {
      if (!canEdit) return;
      levelModal.classList.remove('hidden');
      document.getElementById('levelMsg').textContent = '';
      document.getElementById('levelAbilityChoices').innerHTML = '';
      document.getElementById('levelStatBoostSelect1').value = '';
      document.getElementById('levelStatBoostSelect2').value = '';
      document.getElementById('levelSkillModeSelect').value = 'add';
      document.getElementById('levelSkillNewInput').value = '';
      document.getElementById('levelSkillExistingSelect').value = '';
      syncLevelClassOptionsByChroma();
      renderLevelAbilityOptions();
    };
    levelModal.querySelector('.xr-modal-backdrop').onclick = () => levelModal.classList.add('hidden');
    document.getElementById('cancelLevelBtn').onclick = () => levelModal.classList.add('hidden');
    document.getElementById('levelClassSelect').onchange = () => renderLevelAbilityOptions();
    document.getElementById('levelSkillModeSelect').onchange = () => syncSkillUpgradeUi(levelRule(Math.min(9, Number(character.base_stats?.level || 1) + 1)).skill_mode);

    document.getElementById('confirmLevelBtn').onclick = async () => {
      if (!canEdit) return;
      await withLoading('Applying level up…', async () => {
      const cls = document.getElementById('levelClassSelect').value;
      const progression = [...(character.class_progression || [])];
      const currentLevel = Number(character.base_stats?.level || 1);
      const level = Math.min(9, currentLevel + 1);
      const entryCount = progression.filter(item => item.class === cls).length;
      const tier = entryCount + 1;
      progression.push({ class: cls, tier, level_acquired: level });
      const choices = gatherLevelChoices();
      const adeptClass = isAdeptClass(cls);
      const classChromaValidation = validateClassChromaRequirement(cls, String(character.base_stats?.chroma || '').trim());
      if (!classChromaValidation.valid) {
        document.getElementById('levelMsg').textContent = classChromaValidation.message;
        return;
      }
      const requiredChoices = adeptClass ? requiredAdeptAbilityChoices(tier) : 1;
      if (choices.length < requiredChoices) {
        const msg = requiredChoices === 1
          ? 'Add at least one ability choice for this level.'
          : `Add at least ${requiredChoices} ability choices for this level.`;
        document.getElementById('levelMsg').textContent = msg;
        return;
      }
      if (adeptClass && tier === 1 && choices.length !== 1) {
        document.getElementById('levelMsg').textContent = 'Adept classes automatically gain their basic ability and must pick exactly one advanced power at tier 1.';
        return;
      }
      const key = `${cls}-T${tier}-L${level}-${progression.length - 1}`;
      const adeptBasic = adeptBasicAbilityName(cls);
      const savedChoices = adeptClass && tier === 1
        ? [`${adeptBasic || 'Basic Ability'} (auto)`, ...choices]
        : (adeptClass && tier <= 3)
          ? [`Advanced adept ability auto-upgraded to Tier ${tier}`]
          : choices;

      const prevState = cloneCharacterState();
      const before = character.base_stats || {};
      const rule = levelRule(level);
      const base_stats = {
        ...before,
        level,
        mastery_die: toMasteryDie(level),
        stamina_max: staminaMaxForLevel(level, before.intuition, before.wit),
        stamina_total: staminaMaxForLevel(level, before.intuition, before.wit),
        powerful_item_limit: rule.powerful_item_limit,
        powerful_item_max: rule.powerful_item_max,
        class_ability_choices: {
          ...(character.base_stats?.class_ability_choices || {}),
          [key]: savedChoices
        }
      };
      const skills = [...(character.skills || [])];
      const skillUpgradeMode = document.getElementById('levelSkillModeSelect').value;
      const levelSkillTarget = skillUpgradeMode === 'add'
        ? document.getElementById('levelSkillNewInput').value.trim()
        : document.getElementById('levelSkillExistingSelect').value.trim();
      if (rule.skill_mode === 'add_or_plus1') {
        if (!levelSkillTarget) {
          document.getElementById('levelMsg').textContent = 'This level requires a skill target for add/+1.';
          return;
        }
        const idx = skills.findIndex(skill => (skill.name || '').toLowerCase() === levelSkillTarget.toLowerCase());
        if (skillUpgradeMode === 'plus1') {
          if (idx < 0) {
            document.getElementById('levelMsg').textContent = 'Choose an existing skill for +1.';
            return;
          }
          skills[idx] = { ...skills[idx], bonus: Number(skills[idx].bonus || 0) + 1 };
        } else {
          if (idx >= 0) {
            document.getElementById('levelMsg').textContent = 'That skill already exists. Use +1 instead.';
            return;
          }
          skills.push({ name: levelSkillTarget, bonus: 2 });
        }
      }
      if (rule.skill_mode === 'skill_plus2') {
        if (!levelSkillTarget) {
          document.getElementById('levelMsg').textContent = 'This level requires a skill target to receive +2.';
          return;
        }
        const idx = skills.findIndex(skill => (skill.name || '').toLowerCase() === levelSkillTarget.toLowerCase());
        if (idx < 0) {
          document.getElementById('levelMsg').textContent = 'Skill +2 levels require an existing skill name.';
          return;
        }
        skills[idx] = { ...skills[idx], bonus: Number(skills[idx].bonus || 0) + 2 };
      }
      if (rule.stat_points > 0) {
        const statTargets = [
          document.getElementById('levelStatBoostSelect1').value,
          document.getElementById('levelStatBoostSelect2').value
        ].filter(Boolean);
        if (statTargets.length < rule.stat_points) {
          document.getElementById('levelMsg').textContent = `This level needs ${rule.stat_points} stat increase(s).`;
          return;
        }
        for (let i = 0; i < rule.stat_points; i += 1) {
          const stat = statTargets[i];
          if (!['vigor', 'endurance', 'intuition', 'wit'].includes(stat)) continue;
          base_stats[stat] = Math.min(5, Number(base_stats[stat] || 0) + Number(rule.stat_bonus || 1));
        }
        base_stats.stamina_max = staminaMaxForLevel(level, base_stats.intuition, base_stats.wit);
        base_stats.stamina_total = base_stats.stamina_max;
      }
      const { error } = await sb.from('xrrpg_characters')
        .update({ class_progression: progression, base_stats, skills, updated_at: new Date().toISOString() })
        .eq('id', characterId)
        .eq('user_id', currentUser.id);
      if (error) {
        document.getElementById('levelMsg').textContent = error.message;
        return;
      }

      await addHistory('level_up', `Level ${level}: ${cls} advanced to Tier ${tier}.`, { class: cls, tier, level, abilities: savedChoices, undo: { character: prevState } });
      levelModal.classList.add('hidden');
      document.getElementById('levelAbilityChoices').innerHTML = '';
      await loadCharacter();
      document.getElementById('status').textContent = `Level up applied: ${cls} Tier ${tier}.`;
      });
    };

    async function resolveInjuryDebuff(type, index) {
      if (!canEdit) return;
      return withLoading('Updating injury…', async () => {
      const base_stats = { ...(character.base_stats || {}) };
      const injuries = Array.isArray(base_stats.injuries) ? [...base_stats.injuries] : [];
      const matchingIndexes = injuries.map((injury, injuryIndex) => ({ injury, injuryIndex })).filter(row => row.injury.type === type);
      const target = matchingIndexes[index];
      if (!target) return;
      injuries[target.injuryIndex] = { ...injuries[target.injuryIndex], debuff_resolved: true };
      base_stats.injuries = injuries;
      const previousState = cloneCharacterState();
      const { error } = await sb.from('xrrpg_characters').update({ base_stats, updated_at: new Date().toISOString() }).eq('id', characterId).eq('user_id', currentUser.id);
      if (error) {
        document.getElementById('status').textContent = error.message;
        return;
      }
      await addHistory('resolve_debuff', `Resolved ${type} injury debuff.`, { type, undo: { character: previousState } });
      await loadCharacter();
      document.getElementById('status').textContent = `${type} debuff resolved.`;
      });
    }

    async function healInjury(type, index) {
      if (!canEdit) return;
      return withLoading('Healing injury…', async () => {
      const base_stats = { ...(character.base_stats || {}) };
      const injuries = Array.isArray(base_stats.injuries) ? [...base_stats.injuries] : [];
      const matchingIndexes = injuries
        .map((injury, injuryIndex) => ({ injury, injuryIndex }))
        .filter(row => row.injury.type === type);
      const target = matchingIndexes[index];
      if (!target) return;
      const [removed] = injuries.splice(target.injuryIndex, 1);
      base_stats.injuries = injuries;
      const healedAmount = Number(removed?.damage || 0);
      const maxHp = Number(base_stats.hp || 0);
      const currentHp = Number(base_stats.current_hp ?? maxHp);
      base_stats.current_hp = Math.min(maxHp, currentHp + healedAmount);

      const previousState = cloneCharacterState();
      const { error } = await sb.from('xrrpg_characters')
        .update({ base_stats, updated_at: new Date().toISOString() })
        .eq('id', characterId)
        .eq('user_id', currentUser.id);
      if (error) {
        document.getElementById('status').textContent = error.message;
        return;
      }
      await addHistory('heal_injury', `Healed ${type} injury: ${removed.label || 'unnamed'} (+${Number(removed.damage || 0)} HP).`, { type, label: removed.label || '', healed_hp: Number(removed.damage || 0), undo: { character: previousState } });
      await loadCharacter();
      document.getElementById('status').textContent = `Healed ${type} injury.`;
      });
    }

    document.getElementById('addLevelAbilityBtn').onclick = () => addLevelAbilityChoice();

    const injuryModal = document.getElementById('injuryModal');
    document.getElementById('takeInjuryBtn').onclick = () => {
      if (!canEdit) return;
      injuryModal.classList.remove('hidden');
    };
    injuryModal.querySelector('.xr-modal-backdrop').onclick = () => injuryModal.classList.add('hidden');
    document.getElementById('cancelInjuryBtn').onclick = () => injuryModal.classList.add('hidden');

    document.getElementById('confirmInjuryBtn').onclick = async () => {
      if (!canEdit) return;
      await withLoading('Applying injury…', async () => {
      const type = document.getElementById('injuryTypeInput').value;
      const label = document.getElementById('injuryLabelInput').value.trim();
      const damageByType = { minor: 1, severe: 2, critical: 3 };
      const damage = damageByType[type] || 1;
      const base_stats = { ...(character.base_stats || {}) };
      const currentHp = Number(base_stats.current_hp ?? base_stats.hp ?? 0);
      base_stats.current_hp = Math.max(0, currentHp - damage);
      if (!Array.isArray(base_stats.injuries)) base_stats.injuries = [];
      base_stats.injuries.push({ type, label, damage, at: new Date().toISOString() });

      const previousState = cloneCharacterState();
      const { error } = await sb.from('xrrpg_characters')
        .update({ base_stats, updated_at: new Date().toISOString() })
        .eq('id', characterId)
        .eq('user_id', currentUser.id);
      if (error) {
        document.getElementById('injuryMsg').textContent = error.message;
        return;
      }

      await addHistory('injury', `${type.toUpperCase()} injury: ${label || 'unnamed'} (${damage} dmg). ${injuryDebuff(type)}`, { type, label, damage, debuff: injuryDebuff(type), undo: { character: previousState } });
      injuryModal.classList.add('hidden');
      await loadCharacter();
      document.getElementById('status').textContent = `Applied ${type} injury (${damage} dmg).`;
      });
    };


    async function persistSkills(nextSkills, historyLabel, trackHistory = true) {
      if (!canEdit) return;
      const previousState = cloneCharacterState();
      const { error } = await sb.from('xrrpg_characters')
        .update({ skills: nextSkills, updated_at: new Date().toISOString() })
        .eq('id', characterId)
        .eq('user_id', currentUser.id);
      if (error) {
        document.getElementById('status').textContent = error.message;
        return;
      }
      character.skills = nextSkills;
      renderSkillList();
      if (trackHistory) {
        await addHistory('skills', historyLabel, { undo: { character: previousState } });
      }
      document.getElementById('status').textContent = 'Saved automatically.';
    }

    const skillUpdateTimers = {};

    async function updateSkill(index) {
      if (!canEdit) return;
      const skills = [...(character.skills || [])];
      if (!skills[index]) return;
      const name = document.querySelector(`[data-skill-name="${index}"]`).value.trim();
      const bonus = Number(document.querySelector(`[data-skill-bonus="${index}"]`).value) || 0;
      if (!name) return;
      skills[index] = { name, bonus };
      if (skillUpdateTimers[index]) window.clearTimeout(skillUpdateTimers[index]);
      skillUpdateTimers[index] = window.setTimeout(() => {
        persistSkills(skills, `Updated skill ${name} (+${bonus}).`, false);
      }, 300);
    }

    async function removeSkill(index) {
      if (!canEdit) return;
      const skills = [...(character.skills || [])];
      const removed = skills.splice(index, 1)[0];
      await withLoading('Removing skill…', async () => {
        await persistSkills(skills, `Removed skill ${removed?.name || 'unnamed'}.`);
      });
    }

    const skillModal = document.getElementById('skillModal');
    document.getElementById('addSkillBtn').onclick = () => {
      if (!canEdit) return;
      document.getElementById('skillModalMsg').textContent = '';
      document.getElementById('skillModalName').value = '';
      document.getElementById('skillModalBonus').value = '2';
      skillModal.classList.remove('hidden');
    };
    skillModal.querySelector('.xr-modal-backdrop').onclick = () => skillModal.classList.add('hidden');
    document.getElementById('cancelSkillModalBtn').onclick = () => skillModal.classList.add('hidden');
    document.getElementById('saveSkillModalBtn').onclick = async () => {
      if (!canEdit) return;
      const name = document.getElementById('skillModalName').value.trim();
      const bonus = Number(document.getElementById('skillModalBonus').value) || 2;
      if (!name) {
        document.getElementById('skillModalMsg').textContent = 'Skill name is required.';
        return;
      }
      const skills = [...(character.skills || []), { name, bonus }];
      await withLoading('Saving skill…', async () => {
        await persistSkills(skills, `Added skill ${name} (+${bonus}).`);
      });
      skillModal.classList.add('hidden');
    };

    async function undoHistoryEvent(historyId) {
      if (!canEdit) return;
      return withLoading('Undoing history event…', async () => {
      const row = history.find(item => item.id === historyId);
      const snapshot = row?.event_payload?.undo?.character;
      if (!snapshot) return;
      const { error } = await sb.from('xrrpg_characters').update({
        name: snapshot.name,
        notes: snapshot.notes,
        base_stats: snapshot.base_stats,
        class_progression: snapshot.class_progression,
        skills: snapshot.skills,
        updated_at: new Date().toISOString()
      }).eq('id', characterId).eq('user_id', currentUser.id);
      if (error) {
        document.getElementById('status').textContent = error.message;
        return;
      }
      await addHistory('undo', `Undid: ${row.event_label}`, {});
      await loadCharacter();
      document.getElementById('status').textContent = 'Undo applied.';
      });
    }

    document.querySelectorAll('.table-sort').forEach(button => {
      button.onclick = () => {
        const key = button.dataset.sort;
        if (historySort.key === key) {
          historySort.direction = historySort.direction === 'asc' ? 'desc' : 'asc';
        } else {
          historySort = { key, direction: 'asc' };
        }
        renderHistory();
      };
    });

    (async () => {
      try {
        initCollapsibles();
        await withLoading('Loading character sheet…', async () => {
          await loadCharacter();
          await loadHistory();
        });
        const autosaveTargets = [
          'nameInput','speciesInput','chromaInput','levelInput','masteryDieInput','vigorInput','enduranceInput','intuitionInput','witInput',
          'staminaTotalInput','staminaUsedInput','hpInput','currentHpInput','powerfulItemLimitInput','powerfulItemMaxInput',
          'xenicDecayInput','timesCleansedInput','partyTierInput','appearanceInput','personalityInput','motivationInput','backstoryInput','extraNotesInput'
        ];
        autosaveTargets.forEach(id => {
          const el = document.getElementById(id);
          if (!el) return;
          el.addEventListener('input', scheduleAutosave);
          el.addEventListener('change', scheduleAutosave);
        });
      } catch (error) {
        document.getElementById('status').textContent = error.message;
      }
    })();
  </script>
</body>
</html>
