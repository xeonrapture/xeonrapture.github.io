<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Webrunning Character Sheet</title>
  <link rel="stylesheet" href="/shared/style.css">
</head>
<body class="wr-scope">
  <div id="nav"></div>

  <main class="wrap sheet">
    <header>
      <a class="action-btn" href="/webrunning-2.0/webrunning-character-manager.html" aria-label="Back to character manager">
        <span aria-hidden="true">←</span>
        <span>Back to Character Manager</span>
      </a>
      <h1>Webrunning Character Sheet</h1>
      <p>Use this page to track your character stats, gear, and progression.</p>
    </header>

    <section class="card">
      <h2>Character</h2>
      <div class="sheet-actions">
        <label>
          <span class="muted">Character Name</span>
          <input id="characterName" type="text" maxlength="32" placeholder="Character name" />
        </label>
        <button id="saveCharacter" type="button" aria-label="Save character" title="Save character"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M5 4h12l2 2v14H5z"></path><path d="M8 4v6h8V4"></path><path d="M8 16h8"></path></svg></button>
        <button id="levelUpButton" type="button" aria-label="Level up" title="Level up"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 19V5"></path><path d="M7 10l5-5 5 5"></path></svg><span>Level Up</span></button>
      </div>
    </section>

    <section class="card">
      <h2>Core Info</h2>
      <div class="stats-grid core-info">
        <dl>
          <dt>Name:</dt>
          <dd id="displayName"></dd>
          <dt title="Your progression rank Level affects luck caps and core growth">Level:</dt>
          <dd id="displayLevel">1</dd>
          <dt title="Gain XP from clearing nodes Reaching thresholds levels you up">XP:</dt>
          <dd>
            <input id="inputXp" type="number" min="0" value="0" />
          </dd>
          <dt title="Luck improves generated gear quality and reroll outcomes It is level-capped unless boosted by effects">Luck:</dt>
          <dd id="displayLuck">1</dd>
        </dl>
        <dl>
          <dt title="HP is your life total At 0 HP you become a cyberghost It scales with level and some gear">Max HP:</dt>
          <dd id="displayHp">10</dd>
          <dt>Current HP:</dt>
          <dd>
            <input id="inputCurrentHp" type="number" min="0" value="10" />
          </dd>
          <dt title="How much total Energy you can hold at once At cap, choose which colors to keep">Energy Cap:</dt>
          <dd id="displayEnergyCap">5</dd>
          <dt>Essence:</dt>
          <dd>
            <input id="inputEssence" type="number" min="0" value="0" />
          </dd>
        </dl>
      </div>
      <div class="stat-inputs" style="margin-top: 0.75rem;">
        <label title="Red Energy powers Red gear actives Red gear boosts offense (Attack Plus / Damage Plus) and is usually volatile, with burn, push, and pull effects">Energy (Red)
          <input id="inputEnergyRed" type="number" min="0" value="0" />
        </label>
        <label title="Blue Energy powers Blue gear actives Blue gear boosts durability (HP / Defense DC / Armor) and can freeze, protect allies, or draw aggro">Energy (Blue)
          <input id="inputEnergyBlue" type="number" min="0" value="0" />
        </label>
        <label title="Green Energy powers Green gear actives Green gear boosts mobility (Initiative / Movement / Range) and supports healing, poison, and ranged pressure">Energy (Green)
          <input id="inputEnergyGreen" type="number" min="0" value="0" />
        </label>
        <label title="Gray Energy powers Gray gear actives Gray gear boosts utility (Perception / Hacking) and excels at AoE, darkness, and ally-active enabling">Energy (Gray)
          <input id="inputEnergyGray" type="number" min="0" value="0" />
        </label>
      </div>
    </section>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>Stats</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
      <div class="collapsible-body section-stack">
        <section class="card section-card">
          <h3>Basic Stats</h3>
          <div class="stat-inputs">
            <label title="Power adds to physical-strength adventuring checks and generates Red Energy each combat Start Phase">Power
              <input id="inputPower" type="number" min="0" value="0" />
            </label>
            <label title="Defense adds to resistance adventuring checks and generates Blue Energy each combat Start Phase">Defense
              <input id="inputDefense" type="number" min="0" value="0" />
            </label>
            <label title="Speed adds to dexterity/speed adventuring checks and generates Green Energy each combat Start Phase">Speed
              <input id="inputSpeed" type="number" min="0" value="0" />
            </label>
            <label title="Intelligence adds to smarts checks and generates Gray Energy each combat Start Phase">Intelligence
              <input id="inputIntelligence" type="number" min="0" value="0" />
            </label>
          </div>
        </section>

        <section class="card collapsible section-card" data-collapsible>
          <div class="collapsible-header">
            <h3>Secondary Stats</h3>
            <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
          </div>
          <div class="collapsible-body">
            <p class="muted">Tied to Basic Stats and increased by equipping gear.</p>
            <div class="stats-grid">
              <dl>
                <dt title="Calculated as Power">Attack Plus:</dt>
                <dd id="displayAttackPlus">0</dd>
                <dt title="Calculated as Power">Damage Plus:</dt>
                <dd id="displayDamagePlus">0</dd>
                <dt>Attack Damage Limit:</dt>
                <dd id="displayAttackDamageLimit">0</dd>
                <dt>Combo Damage Limit:</dt>
                <dd id="displayComboDamageLimit">0</dd>
                <dt title="Calculated as Defense + 10">Defense DC:</dt>
                <dd id="displayDefenseDc">10</dd>
                <dt title="Calculated as Defense">Armor:</dt>
                <dd id="displayArmor">0</dd>
                <dt title="Calculated as Speed">Initiative:</dt>
                <dd id="displayInitiative">0</dd>
                <dt title="Calculated as (Speed × 2) + 10">Movement Speed:</dt>
                <dd id="displayMovementSpeed">10</dd>
                <dt title="Calculated as Speed + 5">Range:</dt>
                <dd id="displayRange">5</dd>
                <dt title="Calculated as Intelligence × 2">Perception:</dt>
                <dd id="displayPerception">0</dd>
                <dt title="Calculated as Perception">AOE Range:</dt>
                <dd id="displayAoeRange">0</dd>
                <dt title="Calculated as Intelligence">Hacking:</dt>
                <dd id="displayHacking">0</dd>
              </dl>
            </div>
          </div>
        </section>

        <section class="card collapsible section-card" data-collapsible>
          <div class="collapsible-header">
            <h3>Neutral Buffs</h3>
            <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
          </div>
          <div class="collapsible-body">
            <div class="stats-grid">
              <dl>
                <dt title="How many total inventory gear slots you can hold">Inventory Slots:</dt>
                <dd id="displayInventorySlots">10</dd>
                <dt title="How many kernel gear slots you can equip">Kernel Slots:</dt>
                <dd id="displayKernelSlots">1</dd>
                <dt title="Start Phase: convert this much energy into the item color each turn">Energy Conversion:</dt>
                <dd>0</dd>
                <dt title="Extra XP each group member gains when nodes are cleared">Group XP Gain:</dt>
                <dd>0</dd>
                <dt title="HP restored each time you move to a new node">HP Regen:</dt>
                <dd>0</dd>
                <dt title="Multiplier for essence/credits gained when selling gear">Resell Value:</dt>
                <dd>0</dd>
              </dl>
              <dl id="adventuringPlusesColumn" class="hidden">
                <dt>Adventuring Pluses:</dt>
                <dd id="displayAdventuringPluses"></dd>
              </dl>
            </div>
          </div>
        </section>

        <section class="card collapsible section-card" data-collapsible>
          <div class="collapsible-header">
            <h3>Status Effects</h3>
            <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
          </div>
          <div class="collapsible-body">
            <div class="stat-inputs">
              <label title="Burn increases damage taken modifier by +1 per stack">Burn
                <input id="inputStatusBurn" type="number" min="0" value="0" />
              </label>
              <label title="Freeze lowers Defense DC and Armor by -1 per stack each">Freeze
                <input id="inputStatusFreeze" type="number" min="0" value="0" />
              </label>
              <label title="Poison lowers Attack Plus and Damage Plus by -1 per stack each">Poison
                <input id="inputStatusPoison" type="number" min="0" value="0" />
              </label>
            </div>
            <br>
            <div class="stats-grid">
              <dl>
                <dt>Damage Taken Modifier:</dt>
                <dd id="displayDamageTaken">+0</dd>
                <dt>Defense DC Modifier:</dt>
                <dd id="displayStatusDefenseDc">+0</dd>
                <dt>Armor Modifier:</dt>
                <dd id="displayStatusArmor">+0</dd>
                <dt>Attack Plus Modifier:</dt>
                <dd id="displayStatusAttackPlus">+0</dd>
                <dt>Damage Plus Modifier:</dt>
                <dd id="displayStatusDamagePlus">+0</dd>
              </dl>
            </div>
          </div>
        </section>

        <section id="tempBuffSection" class="card collapsible section-card hidden" data-collapsible>
          <div class="collapsible-header">
            <h3>Active Temp Buffs</h3>
            <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
          </div>
          <div class="collapsible-body">
            <div class="gear-generator-actions">
              <span class="muted" id="tempBuffSummary">No active temporary consumable buffs.</span>
              <button id="clearTempBuffs" type="button" class="hidden" aria-label="Clear temporary buffs" title="Clear temporary buffs"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M3 14l7-7a2 2 0 0 1 3 0l8 8a2 2 0 0 1 0 3l-3 3H10z"></path><path d="M12 20l6-6"></path><path d="M3 21h7"></path></svg><span>Clear Buffs</span></button>
            </div>
          </div>
        </section>
      </div>
    </section>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>Abilities</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
      <div class="collapsible-body">
        <div id="abilitiesList" class="ability-section"></div>
      </div>
    </section>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>Gear</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
      <div class="collapsible-body section-stack">
        <section class="card collapsible section-card" data-collapsible>
          <div class="collapsible-header">
            <h3>Gear Generator</h3>
            <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
          </div>
          <div class="collapsible-body">
            <p class="muted">Click <a href="https://publish.obsidian.md/xeonrapture/xr/XRRPG+2.0/Sub-RPGs/Webrunning+2.0/Gear+Generation/Gear+Generation+and+Modification">here</a> for an explanation of gear generation.</p>
            <p class="muted">Generate gear with your current luck plus a bonus and add it to your inventory or equip it.</p>
            <p class="muted">If luck goes over your level cap, generation still uses the cap and includes a luck-limit reminder.</p>
            <div class="gear-generator-actions">
              <button id="openGearGenerator" type="button" class="hidden" aria-label="Generate gear" title="Generate gear"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="3"></circle><path d="M12 3v3M12 18v3M3 12h3M18 12h3M5.6 5.6l2.1 2.1M16.3 16.3l2.1 2.1M18.4 5.6l-2.1 2.1M7.7 16.3l-2.1 2.1"></path></svg><span>Generate Gear</span></button>
              <span id="gearGeneratorStatus" class="mono muted"></span>
            </div>
          </div>
        </section>

        <section class="card collapsible section-card" data-collapsible>
      <div class="collapsible-header">
        <h2>Gear Slots</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
      <div class="collapsible-body">
        <div id="equippedSlots" class="gear-grid"></div>
      </div>
        </section>

        <section class="card collapsible section-card" data-collapsible>
      <div class="collapsible-header">
        <h2>Inventory Slots</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
        <div class="collapsible-body">
        <div class="gear-controls">
          <div class="gear-controls-section">
            <div class="gear-controls-row">
              <label>
                Sort By
                <select id="gearSortField">
                  <option value="rarity">Rarity</option>
                  <option value="type">Gear Type</option>
                  <option value="color">Color</option>
                  <option value="name">Name</option>
                </select>
              </label>
              <label>
                Direction
                <select id="gearSortDirection">
                  <option value="asc">Ascending</option>
                  <option value="desc">Descending</option>
                </select>
              </label>
            </div>
          </div>
          <div class="gear-controls-divider" role="presentation"></div>
          <div class="gear-controls-section">
            <div class="gear-controls-row">
              <label>
                Filter Rarity
                <select id="gearFilterRarity">
                  <option value="">All</option>
                </select>
              </label>
              <label>
                Filter Gear Type
                <select id="gearFilterType">
                  <option value="">All</option>
                </select>
              </label>
              <label>
                Filter Color
                <select id="gearFilterColor">
                  <option value="">All</option>
                </select>
              </label>
            </div>
            <div class="gear-controls-row">
              <label>
                Filter Stat Modified
                <select id="gearFilterStat">
                  <option value="">All</option>
                </select>
              </label>
              <label>
                Filter Free Slot
                <select id="gearFilterFreeSlot">
                  <option value="">All</option>
                  <option value="has">Has Free Slot</option>
                  <option value="none">No Free Slot</option>
                </select>
              </label>
            </div>
            <span class="muted">Filters apply to inventory gear.</span>
          </div>
        </div>
        <div class="slot-count">Slots used: <span id="inventorySlotCount">0/0</span></div>
        <div id="inventorySlots" class="gear-grid"></div>
      </div>
        </section>

        <section class="card collapsible collapsed section-card" data-collapsible>
      <div class="collapsible-header">
        <h2>Local Node Storage</h2>
        <button class="collapse-toggle" type="button" aria-label="Show section" title="Show section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><circle cx="12" cy="12" r="2.5"></circle></svg></button>
      </div>
      <div class="collapsible-body">
        <p class="muted">Stored and can only be accessed in your local node.</p>
        <div class="gear-controls">
          <div class="gear-controls-section">
            <div class="gear-controls-row">
              <label>
                Filter Rarity
                <select id="localGearFilterRarity">
                  <option value="">All</option>
                </select>
              </label>
              <label>
                Filter Gear Type
                <select id="localGearFilterType">
                  <option value="">All</option>
                </select>
              </label>
              <label>
                Filter Color
                <select id="localGearFilterColor">
                  <option value="">All</option>
                </select>
              </label>
            </div>
            <div class="gear-controls-row">
              <label>
                Filter Stat Modified
                <select id="localGearFilterStat">
                  <option value="">All</option>
                </select>
              </label>
              <label>
                Filter Free Slot
                <select id="localGearFilterFreeSlot">
                  <option value="">All</option>
                  <option value="has">Has Free Slot</option>
                  <option value="none">No Free Slot</option>
                </select>
              </label>
            </div>
            <span class="muted">Filters apply to local node storage.</span>
          </div>
        </div>
        <div class="slot-count">Slots used: <span id="localNodeSlotCount">0/0</span></div>
        <div id="localNodeSlots" class="gear-grid"></div>
      </div>
        </section>

        <section class="card collapsible collapsed section-card gear-modification-panel" data-collapsible>
          <div class="collapsible-header">
            <h3>Gear Modification</h3>
            <button class="collapse-toggle" type="button" aria-label="Show section" title="Show section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><circle cx="12" cy="12" r="2.5"></circle></svg></button>
          </div>
          <div class="collapsible-body">
          <p class="muted">Gear modifications cost Essence.</p>
          <button id="openGearModificationHub" type="button" aria-label="Open gear modification" title="Open gear modification"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M14.7 6.3a4 4 0 1 0 3 3l-4.6 4.6a2 2 0 0 1-2.8 0l-1.3-1.3a2 2 0 0 1 0-2.8z"></path><path d="M12 12l-7 7"></path></svg><span>Gear Modification</span></button>
          <div class="gear-mod-upgrade-row">
            <div>
              <strong>Discount Tier: <span id="gearModTierLabel">None</span></strong>
              <div class="muted">Current discount: <span id="gearModDiscountLabel">0%</span> off base Essence costs.</div>
            </div>
            <label>
              Set Discount Tier
              <select id="gearModTierSelect" aria-label="Set gear modification discount tier"></select>
            </label>
          </div>
          <p class="muted">This upgrade lowers Essence prices for gear upgrades, rerolls, condensing, and aesthetics. Upgrading this discount does not cost Essence.</p>
          <div id="gearModUpgradeStatus" class="mono muted"></div>
          </div>
        </section>

      </div>
    </section>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>Character Info</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
      <div class="collapsible-body section-stack">
        <section class="card notes-area section-card">
          <h3>Character Notes</h3>
          <textarea id="characterNotes" placeholder="Add notes about your character, gear, or story beats..."></textarea>
        </section>

      </div>
    </section>


    <section class="card collapsible collapsed" data-collapsible>
      <div class="collapsible-header">
        <h2>Edit History</h2>
        <button class="collapse-toggle" type="button" aria-label="Show section" title="Show section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><circle cx="12" cy="12" r="2.5"></circle></svg></button>
      </div>
      <div class="collapsible-body">
        <div id="deletedGearHistory" class="deletion-history"></div>
      </div>
    </section>
  </main>

  <div id="levelupModal" class="xr-modal hidden">
    <div class="xr-modal-backdrop"></div>
    <div class="xr-modal-card">
      <h2>Level Up</h2>
      <div class="modal-grid">
        <label>
          Target Level
          <select id="targetLevel"></select>
        </label>
        <div class="level-preview">
          <strong>Preview</strong>
          <ul id="levelPreview"></ul>
        </div>
        <div>
          <strong>Add Stat Points </strong>
          <div class="stat-inputs">
            <label>Power
              <input id="levelPower" type="number" min="0" value="0" />
            </label>
            <label>Defense
              <input id="levelDefense" type="number" min="0" value="0" />
            </label>
            <label>Speed
              <input id="levelSpeed" type="number" min="0" value="0" />
            </label>
            <label>Intelligence
              <input id="levelIntelligence" type="number" min="0" value="0" />
            </label>
          </div>
          <p class="muted">Points remaining: <span id="pointsRemaining">0</span></p>
          <p class="muted"><br>(these points subtract when levelling down)</p>
        </div>
        <div id="levelError" class="mono muted"></div>
      </div>
      <div class="xr-modal-actions">
        <button id="confirmLevelUp" type="button" aria-label="Apply level" title="Apply level"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><path d="M8 12l3 3 5-6"></path></svg></button>
        <button id="cancelLevelUp" type="button" aria-label="Cancel" title="Cancel"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M6 6l12 12"></path><path d="M18 6L6 18"></path></svg></button>
      </div>
    </div>
  </div>

  <div id="gearGeneratorModal" class="xr-modal hidden">
    <div class="xr-modal-backdrop"></div>
    <div class="xr-modal-card">
      <div class="gear-generator-header">
        <h2>Generate Gear</h2>
      </div>
      <div class="modal-grid">
        <label>
          Bonus Luck
          <input id="gearBonusLuck" type="number" min="0" value="0" />
        </label>
        <label>
          Pieces
          <input id="gearAmount" type="number" min="1" value="1" />
        </label>
        <label>
          Gear Type
          <select id="gearTypeNumber">
            <option value="0">Random (None)</option>
            <option value="1">One-Handed Weapon</option>
            <option value="2">Two-Handed Weapon</option>
            <option value="3">Head</option>
            <option value="4">Torso</option>
            <option value="5">Hands</option>
            <option value="6">Legs</option>
            <option value="7">Feet</option>
            <option value="8">Ring</option>
            <option value="9">Neck</option>
            <option value="10">Kernel</option>
            <option value="11">Consumable</option>
            <option value="12">Bauble</option>
          </select>
        </label>
        <label>
          Rarity
          <select id="gearRarity">
            <option value="">Random (None)</option>
            <option value="Common">Common</option>
            <option value="Uncommon">Uncommon</option>
            <option value="Rare">Rare</option>
            <option value="Epic">Epic</option>
            <option value="Legendary">Legendary</option>
          </select>
        </label>
        <label>
          Color
          <select id="gearColor">
            <option value="">Random (None)</option>
            <option value="Neutral">Neutral</option>
            <option value="Red">Red</option>
            <option value="Blue">Blue</option>
            <option value="Green">Green</option>
            <option value="Gray">Gray</option>
          </select>
        </label>
        <label>
          Color 2
          <select id="gearColor2">
            <option value="">None</option>
            <option value="Neutral">Neutral</option>
            <option value="Red">Red</option>
            <option value="Blue">Blue</option>
            <option value="Green">Green</option>
            <option value="Gray">Gray</option>
          </select>
        </label>
        <div class="muted">Total luck used: <span id="gearTotalLuck">0</span></div>
        <div id="gearLuckLimitNote" class="muted"></div>
        <div class="xr-modal-actions gear-generator-header-actions">
          <button id="generateGear" type="button" aria-label="Generate" title="Generate"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="3"></circle><path d="M12 3v3M12 18v3M3 12h3M18 12h3M5.6 5.6l2.1 2.1M16.3 16.3l2.1 2.1M18.4 5.6l-2.1 2.1M7.7 16.3l-2.1 2.1"></path></svg><span>Generate</span></button>
          <button id="addAllGeneratedGear" type="button" disabled aria-label="Add all to inventory" title="Add all to inventory"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 4v10"></path><path d="M8 10l4 4 4-4"></path><path d="M4 20h16"></path></svg><span>Inventory All</span></button>
          <button id="closeGearGenerator" type="button" aria-label="Close" title="Close"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M6 6l12 12"></path><path d="M18 6L6 18"></path></svg></button>
        </div>
      </div>
      <div class="gear-details-list" style="margin-top:1rem;">
        <strong>Generated Gear</strong>
        <div id="generatedGearList" class="gear-grid"></div>
      </div>
      <details class="manual-gear-section">
        <summary>Generate Gear Manually</summary>
        <div class="manual-gear-grid">
          <label>
            Gear Name
            <input id="manualGearName" type="text" maxlength="60" placeholder="Optional custom name" />
          </label>
          <label>
            Gear Type
            <select id="manualGearType">
              <option value="One-Handed Weapon">One-Handed Weapon</option>
              <option value="Two-Handed Weapon">Two-Handed Weapon</option>
              <option value="Head">Head</option>
              <option value="Torso">Torso</option>
              <option value="Hands">Hands</option>
              <option value="Legs">Legs</option>
              <option value="Feet">Feet</option>
              <option value="Ring">Ring</option>
              <option value="Neck">Neck</option>
              <option value="Kernel">Kernel</option>
              <option value="Consumable">Consumable</option>
              <option value="Bauble">Bauble</option>
            </select>
          </label>
          <label>
            Rarity
            <select id="manualGearRarity">
              <option value="Basic">Basic</option>
              <option value="Common">Common</option>
              <option value="Uncommon">Uncommon</option>
              <option value="Rare">Rare</option>
              <option value="Epic">Epic</option>
              <option value="Legendary">Legendary</option>
            </select>
          </label>
          <label>
            Color
            <select id="manualGearColor">
              <option value="Neutral">Neutral</option>
              <option value="Red">Red</option>
              <option value="Blue">Blue</option>
              <option value="Green">Green</option>
              <option value="Gray">Gray</option>
            </select>
          </label>
          <label>
            Color 2
            <select id="manualGearColor2">
              <option value="">None</option>
              <option value="Neutral">Neutral</option>
              <option value="Red">Red</option>
              <option value="Blue">Blue</option>
              <option value="Green">Green</option>
              <option value="Gray">Gray</option>
            </select>
          </label>
          <label>
            Item Type
            <input id="manualGearItemType" type="text" placeholder="e.g. Laser Dagger" />
          </label>
          <label>
            Aesthetic
            <input id="manualGearAesthetic" type="text" placeholder="Optional aesthetic detail" />
          </label>
          <label>
            Essence Value
            <input id="manualGearEssence" type="number" min="0" value="0" />
          </label>
          <label>
            Credit Value
            <input id="manualGearCredit" type="number" min="0" value="0" />
          </label>
        </div>
        <div>
          <strong>Stat Modifiers</strong>
          <div id="manualGearStatsList" class="manual-gear-list"></div>
          <button id="addManualGearStat" type="button" aria-label="Add stat" title="Add stat"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M5 19h14"></path><path d="M7 16V9M12 16V6M17 16v-4"></path><path d="M4 5h4M6 3v4"></path></svg><span>Add Stat</span></button>
        </div>
        <div>
          <strong>Abilities</strong>
          <div id="manualGearAbilitiesList" class="manual-gear-list"></div>
          <button id="addManualGearAbility" type="button" aria-label="Add ability" title="Add ability"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 4l1.5 3.5L17 9l-3.5 1.5L12 14l-1.5-3.5L7 9l3.5-1.5z"></path><path d="M4 18h4M6 16v4"></path></svg><span>Add Ability</span></button>
        </div>
        <div class="manual-gear-actions">
          <button id="addManualGear" type="button" aria-label="Add manual gear" title="Add manual gear"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M14 6l4 4-8 8-4 1 1-4z"></path><path d="M4 6h4M6 4v4"></path></svg><span>Add Manual</span></button>
          <span id="manualGearStatus" class="mono muted"></span>
        </div>
      </details>
      <div class="paste-area" style="margin-top:1rem;">
        <strong>Paste Gear JSON</strong>
        <textarea id="gearPasteInput" placeholder="Paste gear JSON here"></textarea>
        <div class="gear-generator-actions">
          <button id="addPastedGear" type="button" aria-label="Add pasted gear" title="Add pasted gear"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><rect x="5" y="4" width="10" height="14" rx="2"></rect><path d="M9 4V2h4v2"></path><path d="M18 17h4M20 15v4"></path></svg><span>Add Pasted to List Above</span></button>
          <span id="pasteStatus" class="mono muted"></span>
        </div>
      </div>
    </div>
  </div>

  <div id="gearDetailModal" class="xr-modal hidden">
    <div class="xr-modal-backdrop"></div>
    <div class="xr-modal-card">
      <h2 id="gearDetailTitle">Gear Details</h2>
      <div class="modal-grid">
        <label>
          Gear Name
          <input id="gearNameInput" type="text" maxlength="60" />
        </label>
        <div id="gearDetailBody" class="gear-details-list"></div>
        <label class="gear-detail-notes">
          Notes
          <textarea id="gearNotesInput" rows="3" placeholder="Add optional notes about this gear..."></textarea>
        </label>
      </div>
      <div class="gear-modal-actions">
        <div class="right-actions">
          <button id="saveGearName" type="button" aria-label="Save details" title="Save details"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M5 4h12l2 2v14H5z"></path><path d="M8 4v6h8V4"></path><path d="M8 16h8"></path></svg></button>
          <button id="copyGearJson" type="button" aria-label="Copy JSON" title="Copy JSON"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><rect x="6" y="5" width="12" height="16" rx="2"></rect><path d="M9 5V3h6v2"></path><path d="M9 11h6M9 15h6"></path></svg><span>Copy JSON</span></button>
          <button id="openGearDetailModify" type="button" aria-label="Modify gear" title="Modify gear"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M14.7 6.3a4 4 0 1 0 3 3l-4.6 4.6a2 2 0 0 1-2.8 0l-1.3-1.3a2 2 0 0 1 0-2.8z"></path><path d="M12 12l-7 7"></path></svg><span>Modify</span></button>
        </div>
        <div class="right-actions">
          <button id="dissolveGear" type="button" aria-label="Dissolve into essence" title="Dissolve into essence"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M10 3h4"></path><path d="M11 3v6l-5 8a3 3 0 0 0 2.6 4h6.8A3 3 0 0 0 18 17l-5-8V3"></path><path d="M8 14h8"></path></svg><span>Dissolve</span></button>
          <button id="deleteGear" type="button" aria-label="Delete gear" title="Delete gear"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 7h16"></path><path d="M9 7V4h6v3"></path><path d="M7 7l1 13h8l1-13"></path><path d="M10 11v6M14 11v6"></path></svg><span>Delete</span></button>
          <button id="closeGearDetail" type="button" aria-label="Close" title="Close"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M6 6l12 12"></path><path d="M18 6L6 18"></path></svg></button>
        </div>
      </div>
      <div id="gearDetailStatus" class="mono muted"></div>
    </div>
  </div>

  <div id="gearModificationModal" class="xr-modal hidden">
    <div class="xr-modal-backdrop"></div>
    <div class="xr-modal-card">
      <h2>Gear Modification</h2>
      <div id="gearModificationBody" class="gear-details-list"></div>
      <div class="xr-modal-actions">
        <button id="gearModificationBack" type="button" aria-label="Back" title="Back"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M9 8L4 12l5 4"></path><path d="M4 12h16"></path></svg><span>Back</span></button>
        <button id="gearModificationUndo" class="hidden" type="button" aria-label="Undo modification" title="Undo modification"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 12a8 8 0 1 0 2.4-5.7"></path><path d="M4 6v6h6"></path></svg><span>Undo Mod</span></button>
        <button id="gearModificationDetails" class="hidden" type="button" aria-label="Go to gear details" title="Go to gear details"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h2v5h-2z"></path></svg><span>Gear Details</span></button>
        <button id="closeGearModification" type="button" aria-label="Close" title="Close"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M6 6l12 12"></path><path d="M18 6L6 18"></path></svg><span>Close</span></button>
      </div>
      <div id="gearModificationStatus" class="mono muted"></div>
    </div>
  </div>


  <div id="respecModal" class="xr-modal hidden">
    <div class="xr-modal-backdrop"></div>
    <div class="xr-modal-card">
      <h2>Use Respec Consumable</h2>
      <p class="muted" id="respecModalHint"></p>
      <div class="stat-inputs">
        <label>Power
          <input id="respecPower" type="number" min="0" value="0" />
        </label>
        <label>Defense
          <input id="respecDefense" type="number" min="0" value="0" />
        </label>
        <label>Speed
          <input id="respecSpeed" type="number" min="0" value="0" />
        </label>
        <label>Intelligence
          <input id="respecIntelligence" type="number" min="0" value="0" />
        </label>
      </div>
      <p class="muted">Points remaining: <span id="respecPointsRemaining">0</span></p>
      <div class="xr-modal-actions">
        <button id="respecApplyBtn" type="button" aria-label="Apply respec" title="Apply respec"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><path d="M8 12l3 3 5-6"></path></svg></button>
        <button id="respecCancelBtn" type="button" aria-label="Cancel" title="Cancel"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M6 6l12 12"></path><path d="M18 6L6 18"></path></svg></button>
      </div>
      <div id="respecModalMsg" class="mono muted"></div>
    </div>
  </div>

  <div id="energyModal" class="xr-modal hidden">
    <div class="xr-modal-backdrop"></div>
    <div class="xr-modal-card">
      <h2>Use Energy Consumable</h2>
      <p class="muted">Choose which energy color to restore.</p>
      <label>
        Energy Color
        <select id="energyColorSelect">
          <option value="red">Red</option>
          <option value="blue">Blue</option>
          <option value="green">Green</option>
          <option value="gray">Gray</option>
        </select>
      </label>
      <div class="xr-modal-actions">
        <button id="energyApplyBtn" type="button" aria-label="Apply" title="Apply"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><path d="M8 12l3 3 5-6"></path></svg></button>
        <button id="energyCancelBtn" type="button" aria-label="Cancel" title="Cancel"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M6 6l12 12"></path><path d="M18 6L6 18"></path></svg></button>
      </div>
    </div>
  </div>

  <div id="gearChangeModal" class="xr-modal hidden">
    <div class="xr-modal-backdrop"></div>
    <div class="xr-modal-card">
      <h2>Use Gear Change Consumable</h2>
      <p class="muted" id="gearChangeHint">Pick the gear and target value for this consumable.</p>
      <label>
        Target Gear
        <select id="gearChangeTarget"></select>
      </label>
      <label>
        New Value
        <select id="gearChangeValue"></select>
      </label>
      <div class="xr-modal-actions">
        <button id="gearChangeApplyBtn" type="button" aria-label="Apply" title="Apply"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><path d="M8 12l3 3 5-6"></path></svg></button>
        <button id="gearChangeCancelBtn" type="button" aria-label="Cancel" title="Cancel"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M6 6l12 12"></path><path d="M18 6L6 18"></path></svg></button>
      </div>
      <div id="gearChangeModalMsg" class="mono muted"></div>
    </div>
  </div>

  <div id="statusPopup" class="status-popup" aria-live="polite"></div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="/shared/auth.js"></script>
  <script src="/shared/nav.js"></script>
  <script>
    const sb = window.supabaseClient;
    const levelTable = [
      { level: 1, xp: 0, baseHp: 5, statPoints: 3, energyCap: 5, kernelSlots: 1, inventorySlots: 10, baseLuck: 1 },
      { level: 2, xp: 10, baseHp: 10, statPoints: 0, energyCap: 5, kernelSlots: 1, inventorySlots: 12, baseLuck: 2 },
      { level: 3, xp: 20, baseHp: 15, statPoints: 1, energyCap: 6, kernelSlots: 2, inventorySlots: 14, baseLuck: 3 },
      { level: 4, xp: 35, baseHp: 20, statPoints: 0, energyCap: 6, kernelSlots: 2, inventorySlots: 16, baseLuck: 4 },
      { level: 5, xp: 55, baseHp: 25, statPoints: 1, energyCap: 7, kernelSlots: 3, inventorySlots: 18, baseLuck: 5 },
      { level: 6, xp: 80, baseHp: 30, statPoints: 0, energyCap: 7, kernelSlots: 3, inventorySlots: 20, baseLuck: 6 },
      { level: 7, xp: 110, baseHp: 35, statPoints: 1, energyCap: 8, kernelSlots: 4, inventorySlots: 22, baseLuck: 7 },
      { level: 8, xp: 150, baseHp: 40, statPoints: 0, energyCap: 8, kernelSlots: 4, inventorySlots: 24, baseLuck: 8 },
      { level: 9, xp: 200, baseHp: 45, statPoints: 1, energyCap: 9, kernelSlots: 5, inventorySlots: 26, baseLuck: 9 },
      { level: 10, xp: 260, baseHp: 50, statPoints: 0, energyCap: 10, kernelSlots: 5, inventorySlots: 30, baseLuck: 10 }
    ];

    const statLimitTable = {
      1: { hp: 20, defenseDc: 17, attackDamage: 20, comboDamage: 40, luck: 5 },
      2: { hp: 25, defenseDc: 18, attackDamage: 30, comboDamage: 60, luck: 7 },
      3: { hp: 30, defenseDc: 19, attackDamage: 40, comboDamage: 80, luck: 9 },
      4: { hp: 35, defenseDc: 20, attackDamage: 50, comboDamage: 100, luck: 11 },
      5: { hp: 40, defenseDc: 21, attackDamage: 60, comboDamage: 120, luck: 13 },
      6: { hp: 50, defenseDc: 23, attackDamage: 80, comboDamage: 160, luck: 15 },
      7: { hp: 60, defenseDc: 25, attackDamage: 100, comboDamage: 200, luck: 18 },
      8: { hp: 80, defenseDc: 28, attackDamage: 125, comboDamage: 250, luck: 21 },
      9: { hp: 100, defenseDc: 30, attackDamage: 150, comboDamage: 300, luck: 25 },
      10: { hp: null, defenseDc: null, attackDamage: null, comboDamage: null, luck: null }
    };

    const defaults = {
      level: 1,
      xp: 0,
      luck: 1,
      hp: 5,
      current_hp: 5,
      essence: 0,
      power: 0,
      defense: 0,
      speed: 0,
      intelligence: 0,
      inventory_slots: 10,
      kernel_slots: 1,
      energy_cap: 5,
      energy_red: 0,
      energy_blue: 0,
      energy_gray: 0,
      energy_green: 0,
      status_burn: 0,
      status_freeze: 0,
      status_poison: 0,
      gear_mod_discount_tier: 0
    };

    const statusEffectDefaults = {
      burn: 0,
      freeze: 0,
      poison: 0
    };

    let currentUser = null;
    let activeCharacter = null;
    let isDirty = false;
    let isSaving = false;
    let autosaveTimer = null;
    let characterGear = [];
    let generatedGear = [];
    let activeGearRow = null;
    let pyodideClient = null;
    let pyodideReady = false;
    let gearModificationSource = "hub";
    let selectedModificationType = null;
    let selectedGearModificationTargetId = "";
    let pendingModificationRecord = null;

    const elements = {
      nameInput: document.getElementById("characterName"),
      saveButton: document.getElementById("saveCharacter"),
      displayName: document.getElementById("displayName"),
      displayLevel: document.getElementById("displayLevel"),
      displayLuck: document.getElementById("displayLuck"),
      displayHp: document.getElementById("displayHp"),
      displayEnergyCap: document.getElementById("displayEnergyCap"),
      inputXp: document.getElementById("inputXp"),
      inputEssence: document.getElementById("inputEssence"),
      inputCurrentHp: document.getElementById("inputCurrentHp"),
      inputEnergyRed: document.getElementById("inputEnergyRed"),
      inputEnergyBlue: document.getElementById("inputEnergyBlue"),
      inputEnergyGray: document.getElementById("inputEnergyGray"),
      inputEnergyGreen: document.getElementById("inputEnergyGreen"),
      inputPower: document.getElementById("inputPower"),
      inputDefense: document.getElementById("inputDefense"),
      inputSpeed: document.getElementById("inputSpeed"),
      inputIntelligence: document.getElementById("inputIntelligence"),
      inputStatusBurn: document.getElementById("inputStatusBurn"),
      inputStatusFreeze: document.getElementById("inputStatusFreeze"),
      inputStatusPoison: document.getElementById("inputStatusPoison"),
      displayAttackPlus: document.getElementById("displayAttackPlus"),
      displayDamagePlus: document.getElementById("displayDamagePlus"),
      displayAttackDamageLimit: document.getElementById("displayAttackDamageLimit"),
      displayComboDamageLimit: document.getElementById("displayComboDamageLimit"),
      displayDefenseDc: document.getElementById("displayDefenseDc"),
      displayArmor: document.getElementById("displayArmor"),
      displayDamageTaken: document.getElementById("displayDamageTaken"),
      displayStatusDefenseDc: document.getElementById("displayStatusDefenseDc"),
      displayStatusArmor: document.getElementById("displayStatusArmor"),
      displayStatusAttackPlus: document.getElementById("displayStatusAttackPlus"),
      displayStatusDamagePlus: document.getElementById("displayStatusDamagePlus"),
      displayInitiative: document.getElementById("displayInitiative"),
      displayMovementSpeed: document.getElementById("displayMovementSpeed"),
      displayRange: document.getElementById("displayRange"),
      displayPerception: document.getElementById("displayPerception"),
      displayAoeRange: document.getElementById("displayAoeRange"),
      displayHacking: document.getElementById("displayHacking"),
      displayInventorySlots: document.getElementById("displayInventorySlots"),
      displayKernelSlots: document.getElementById("displayKernelSlots"),
      adventuringPlusesColumn: document.getElementById("adventuringPlusesColumn"),
      displayAdventuringPluses: document.getElementById("displayAdventuringPluses"),
      tempBuffSection: document.getElementById("tempBuffSection"),
      tempBuffSummary: document.getElementById("tempBuffSummary"),
      clearTempBuffs: document.getElementById("clearTempBuffs"),
      equippedSlots: document.getElementById("equippedSlots"),
      inventorySlots: document.getElementById("inventorySlots"),
      localNodeSlots: document.getElementById("localNodeSlots"),
      inventorySlotCount: document.getElementById("inventorySlotCount"),
      localNodeSlotCount: document.getElementById("localNodeSlotCount"),
      abilitiesList: document.getElementById("abilitiesList"),
      openGearGenerator: document.getElementById("openGearGenerator"),
      gearGeneratorStatus: document.getElementById("gearGeneratorStatus"),
      statusPopup: document.getElementById("statusPopup"),
      deletedGearHistory: document.getElementById("deletedGearHistory"),
      notesInput: document.getElementById("characterNotes"),
      openGearModificationHub: document.getElementById("openGearModificationHub"),
      gearModTierSelect: document.getElementById("gearModTierSelect"),
      gearModTierLabel: document.getElementById("gearModTierLabel"),
      gearModDiscountLabel: document.getElementById("gearModDiscountLabel"),
      gearModUpgradeStatus: document.getElementById("gearModUpgradeStatus")
    };

    const modal = document.getElementById("levelupModal");
    const modalBackdrop = modal.querySelector(".xr-modal-backdrop");
    const targetLevelSelect = document.getElementById("targetLevel");
    const levelPreview = document.getElementById("levelPreview");
    const levelPower = document.getElementById("levelPower");
    const levelDefense = document.getElementById("levelDefense");
    const levelSpeed = document.getElementById("levelSpeed");
    const levelIntelligence = document.getElementById("levelIntelligence");
    const pointsRemaining = document.getElementById("pointsRemaining");
    const levelError = document.getElementById("levelError");

    const gearGeneratorModal = document.getElementById("gearGeneratorModal");
    const gearGeneratorBackdrop = gearGeneratorModal.querySelector(".xr-modal-backdrop");
    const gearBonusLuck = document.getElementById("gearBonusLuck");
    const gearAmount = document.getElementById("gearAmount");
    const gearTypeNumber = document.getElementById("gearTypeNumber");
    const gearRarity = document.getElementById("gearRarity");
    const gearColor = document.getElementById("gearColor");
    const gearColor2 = document.getElementById("gearColor2");
    const gearTotalLuck = document.getElementById("gearTotalLuck");
    const gearLuckLimitNote = document.getElementById("gearLuckLimitNote");
    const generateGearButton = document.getElementById("generateGear");
    const addAllGeneratedGearButton = document.getElementById("addAllGeneratedGear");
    const closeGearGenerator = document.getElementById("closeGearGenerator");
    const generatedGearList = document.getElementById("generatedGearList");
    const gearPasteInput = document.getElementById("gearPasteInput");
    const addPastedGear = document.getElementById("addPastedGear");
    const pasteStatus = document.getElementById("pasteStatus");
    const manualGearName = document.getElementById("manualGearName");
    const manualGearType = document.getElementById("manualGearType");
    const manualGearRarity = document.getElementById("manualGearRarity");
    const manualGearColor = document.getElementById("manualGearColor");
    const manualGearColor2 = document.getElementById("manualGearColor2");
    const manualGearItemType = document.getElementById("manualGearItemType");
    const manualGearAesthetic = document.getElementById("manualGearAesthetic");
    const manualGearEssence = document.getElementById("manualGearEssence");
    const manualGearCredit = document.getElementById("manualGearCredit");
    const manualGearStatsList = document.getElementById("manualGearStatsList");
    const addManualGearStat = document.getElementById("addManualGearStat");
    const manualGearAbilitiesList = document.getElementById("manualGearAbilitiesList");
    const addManualGearAbility = document.getElementById("addManualGearAbility");
    const addManualGearButton = document.getElementById("addManualGear");
    const manualGearStatus = document.getElementById("manualGearStatus");
    const gearSortField = document.getElementById("gearSortField");
    const gearSortDirection = document.getElementById("gearSortDirection");
    const gearFilterRarity = document.getElementById("gearFilterRarity");
    const gearFilterType = document.getElementById("gearFilterType");
    const gearFilterColor = document.getElementById("gearFilterColor");
    const gearFilterStat = document.getElementById("gearFilterStat");
    const gearFilterFreeSlot = document.getElementById("gearFilterFreeSlot");
    const localGearFilterRarity = document.getElementById("localGearFilterRarity");
    const localGearFilterType = document.getElementById("localGearFilterType");
    const localGearFilterColor = document.getElementById("localGearFilterColor");
    const localGearFilterStat = document.getElementById("localGearFilterStat");
    const localGearFilterFreeSlot = document.getElementById("localGearFilterFreeSlot");

    const gearDetailModal = document.getElementById("gearDetailModal");
    const gearDetailBackdrop = gearDetailModal.querySelector(".xr-modal-backdrop");
    const gearDetailTitle = document.getElementById("gearDetailTitle");
    const gearNameInput = document.getElementById("gearNameInput");
    const gearNotesInput = document.getElementById("gearNotesInput");
    const gearDetailBody = document.getElementById("gearDetailBody");
    const closeGearDetail = document.getElementById("closeGearDetail");
    const copyGearJson = document.getElementById("copyGearJson");
    const saveGearName = document.getElementById("saveGearName");
    const deleteGearButton = document.getElementById("deleteGear");
    const dissolveGearButton = document.getElementById("dissolveGear");
    const openGearDetailModify = document.getElementById("openGearDetailModify");
    const gearDetailStatus = document.getElementById("gearDetailStatus");

    const gearModificationModal = document.getElementById("gearModificationModal");
    const gearModificationBackdrop = gearModificationModal?.querySelector(".xr-modal-backdrop");
    const gearModificationBody = document.getElementById("gearModificationBody");
    const gearModificationStatus = document.getElementById("gearModificationStatus");
    const gearModificationBack = document.getElementById("gearModificationBack");
    const gearModificationUndo = document.getElementById("gearModificationUndo");
    const gearModificationDetails = document.getElementById("gearModificationDetails");
    const closeGearModification = document.getElementById("closeGearModification");

    const respecModal = document.getElementById("respecModal");
    const respecModalBackdrop = respecModal?.querySelector(".xr-modal-backdrop");
    const respecModalHint = document.getElementById("respecModalHint");
    const respecPower = document.getElementById("respecPower");
    const respecDefense = document.getElementById("respecDefense");
    const respecSpeed = document.getElementById("respecSpeed");
    const respecIntelligence = document.getElementById("respecIntelligence");
    const respecPointsRemaining = document.getElementById("respecPointsRemaining");
    const respecApplyBtn = document.getElementById("respecApplyBtn");
    const respecCancelBtn = document.getElementById("respecCancelBtn");
    const respecModalMsg = document.getElementById("respecModalMsg");

    const energyModal = document.getElementById("energyModal");
    const energyModalBackdrop = energyModal?.querySelector(".xr-modal-backdrop");
    const energyColorSelect = document.getElementById("energyColorSelect");
    const energyApplyBtn = document.getElementById("energyApplyBtn");
    const energyCancelBtn = document.getElementById("energyCancelBtn");

    const gearChangeModal = document.getElementById("gearChangeModal");
    const gearChangeModalBackdrop = gearChangeModal?.querySelector(".xr-modal-backdrop");
    const gearChangeHint = document.getElementById("gearChangeHint");
    const gearChangeTarget = document.getElementById("gearChangeTarget");
    const gearChangeValue = document.getElementById("gearChangeValue");
    const gearChangeApplyBtn = document.getElementById("gearChangeApplyBtn");
    const gearChangeCancelBtn = document.getElementById("gearChangeCancelBtn");
    const gearChangeModalMsg = document.getElementById("gearChangeModalMsg");

    let gearHistory = [];
    let editHistory = [];
    let tempConsumableBonus = createEmptyBonus();
    let tempConsumableSummary = [];

    const gearSlotLabels = {
      weapon_1: "Weapon 1",
      weapon_2: "Weapon 2",
      head: "Head",
      torso: "Torso",
      hands: "Hands",
      legs: "Legs",
      feet: "Feet",
      ring_1: "Ring 1",
      ring_2: "Ring 2",
      neck: "Neck",
      kernel_1: "Kernel 1",
      kernel_2: "Kernel 2",
      kernel_3: "Kernel 3",
      kernel_4: "Kernel 4",
      kernel_5: "Kernel 5"
    };

    const gearTypeToSlots = {
      "One-Handed Weapon": ["weapon_1", "weapon_2"],
      "Two-Handed Weapon": ["weapon_1", "weapon_2"],
      "Head": ["head"],
      "Torso": ["torso"],
      "Hands": ["hands"],
      "Legs": ["legs"],
      "Feet": ["feet"],
      "Ring": ["ring_1", "ring_2"],
      "Neck": ["neck"],
      "Kernel": ["kernel_1", "kernel_2", "kernel_3", "kernel_4", "kernel_5"]
    };

    const statKeyMap = {
      Luck: "luck",
      "Inventory Slots": "inventory_slots",
      "Energy Cap": "energy_cap",
      "Kernel Slots": "kernel_slots",
      HP: "hp",
      Power: "power",
      Defense: "defense",
      Speed: "speed",
      Intelligence: "intelligence",
      "Attack Plus": "attackPlus",
      "Damage Plus": "damagePlus",
      "Defense DC": "defenseDc",
      Armor: "armor",
      Initiative: "initiative",
      "Movement Speed": "movementSpeed",
      Range: "range",
      Perception: "perception",
      "AOE Range": "aoeRange",
      Hacking: "hacking",
      "Group XP Gain": "group_xp_gain",
      "HP Regen": "hp_regen",
      "Energy Conversion": "energy_conversion",
      "Energy Generation": "energy_generation",
      "Resell Value": "resell_value"
    };

    const statOptions = [
      "Power",
      "Defense",
      "Speed",
      "Intelligence",
      "Luck",
      "HP",
      "Attack Plus",
      "Damage Plus",
      "Defense DC",
      "Armor",
      "Initiative",
      "Movement Speed",
      "Range",
      "Perception",
      "AOE Range",
      "Hacking",
      "Inventory Slots",
      "Kernel Slots",
      "Energy Cap",
      "Energy Conversion",
      "Energy Generation",
      "Group XP Gain",
      "HP Regen",
      "Resell Value"
    ];

    const baubleFormulaOptions = [
      "G÷4",
      "G÷3",
      "G÷2",
      "G",
      "Gx1.25",
      "Gx1.5",
      "Gx1.75",
      "Gx2.5",
      "+1",
      "+2",
      "+3",
      "+4",
      "+5"
    ];

    const gearTypeSortOrder = [
      "One-Handed Weapon",
      "Two-Handed Weapon",
      "Head",
      "Torso",
      "Hands",
      "Legs",
      "Feet",
      "Ring",
      "Neck",
      "Kernel",
      "Bauble",
      "Consumable"
    ];

    const raritySortOrder = ["Basic", "Common", "Uncommon", "Rare", "Epic", "Legendary"];
    const colorSortOrder = ["Neutral", "Red", "Blue", "Green", "Gray"];
    const gearMaxes = {
      Common: { statBuffMax: 2, activePassiveMax: 1 },
      Uncommon: { statBuffMax: 3, activePassiveMax: 2 },
      Rare: { statBuffMax: 4, activePassiveMax: 3 },
      Epic: { statBuffMax: 7, activePassiveMax: 3 },
      Legendary: { statBuffMax: 10, activePassiveMax: 4 }
    };
    const rarityBaseModifierCaps = {
      Common: { basicStats: 1, colorStats: 0, actives: 0 },
      Uncommon: { basicStats: 1, colorStats: 1, actives: 1 },
      Rare: { basicStats: 1, colorStats: 2, actives: 1 },
      Epic: { basicStats: 2, colorStats: 2, actives: 2 },
      Legendary: { basicStats: 2, colorStats: 3, actives: 2 }
    };
    const gearUpgradeCosts = {
      Common: { next: "Uncommon", statBuff: "+1", ability: "-", cost: 1000 },
      Uncommon: { next: "Rare", statBuff: "+1", ability: "+1 Active", cost: 2000 },
      Rare: { next: "Epic", statBuff: "+1", ability: "-", cost: 5000 },
      Epic: { next: "Legendary", statBuff: "+1", ability: "+1 Active", cost: 10000 }
    };
    const gearRerollCosts = { Common: 250, Uncommon: 500, Rare: 1000, Epic: 2500, Legendary: 5000 };
    const gearCondenseCosts = {
      Common: [125, 250],
      Uncommon: [250, 500],
      Rare: [500, 1000, 1500],
      Epic: [1250, 2500, 3750, 4000, 5250],
      Legendary: [2500, 5000, 7500, 10000, 12500, 15000, 17500]
    };
    const gearModificationDiscountTiers = [
      { tier: 0, label: "None", discount: 0 },
      { tier: 1, label: "I", discount: 10 },
      { tier: 2, label: "II", discount: 20 },
      { tier: 3, label: "III", discount: 30 },
      { tier: 4, label: "IV", discount: 40 },
      { tier: 5, label: "V", discount: 50 }
    ];
    const gearTypeToNumber = {
      "One-Handed Weapon": 1,
      "Two-Handed Weapon": 2,
      "Head": 3,
      "Torso": 4,
      "Hands": 5,
      "Legs": 6,
      "Feet": 7,
      "Ring": 8,
      "Neck": 9,
      "Kernel": 10,
      "Consumable": 11,
      "Bauble": 12
    };
    const colorBuffKeywords = {
      Red: ["attack plus", "damage plus", "power"],
      Blue: ["hp", "defense dc", "armor", "defense"],
      Green: ["initiative", "movement speed", "range", "speed"],
      Gray: ["perception", "hacking", "intelligence"]
    };

    const rarityIndexMap = {
      Common: 0,
      Uncommon: 1,
      Rare: 2,
      Epic: 3,
      Legendary: 4
    };
    const statBuffFormulaByLabel = {
      "Luck": ["1", "2", "3", "5", "8"],
      "Luck ✦": ["2", "3", "4", "6", "9"],
      "Luck ✦✦": ["3", "4", "5", "7", "10"],
      "Inventory Slots": ["L÷4", "L÷3", "L÷2", "L", "Lx1.25"],
      "Inventory Slots ✦": ["L÷3", "L÷2", "L", "Lx1.25", "Lx1.5"],
      "Energy Cap": ["L÷5", "L÷4", "L÷3", "L÷2", "L"],
      "Energy Cap ✦": ["L÷4", "L÷3", "L÷2", "L", "Lx1.25"],
      "Kernel Slots": ["L÷5", "L÷4", "L÷3", "L÷2", "L"],
      "Attack Plus": ["L÷5", "L÷4", "L÷3", "L÷2", "L"],
      "Attack Plus ✦": ["L÷4", "L÷3", "L÷2", "L", "Lx1.25"],
      "Damage Plus": ["L÷5", "L÷4", "L÷3", "L÷2", "L"],
      "Damage Plus ✦": ["L÷4", "L÷3", "L÷2", "L", "Lx1.25"],
      "Power": [null, null, null, "D", "D+1"],
      "HP": ["L÷2", "L", "Lx1.25", "Lx1.5", "Lx2"],
      "HP ✦": ["L", "Lx1.25", "Lx1.5", "Lx1.75", "Lx2.5"],
      "Defense DC": ["L÷5", "L÷4", "L÷3", "L÷2", "L"],
      "Defense DC ✦": ["L÷4", "L÷3", "L÷2", "L", "Lx1.25"],
      "Armor": ["L÷5", "L÷5", "L÷4", "L÷4", "L÷3"],
      "Armor ✦": ["L÷4", "L÷4", "L÷3", "L÷3", "L÷2"],
      "Defense": [null, null, null, "D", "D+1"],
      "Initiative": ["L÷5", "L÷4", "L÷3", "L÷2", "L"],
      "Initiative ✦": ["L÷4", "L÷3", "L÷2", "L", "Lx1.25"],
      "Movement Speed": ["L÷2", "L", "Lx1.25", "Lx1.5", "Lx2"],
      "Movement Speed ✦": ["L", "Lx1.25", "Lx1.5", "Lx1.75", "Lx2.5"],
      "Range": ["L÷4", "L÷3", "L÷2", "L", "Lx1.25"],
      "Range ✦": ["L÷3", "L÷2", "L", "Lx1.25", "Lx1.5"],
      "Speed": [null, null, null, "D", "D+1"],
      "Perception": ["L÷4", "L÷3", "L÷2", "L", "Lx1.25"],
      "Perception ✦": ["L÷3", "L÷2", "L", "Lx1.25", "Lx1.5"],
      "Hacking": ["L÷4", "L÷3", "L÷2", "L", "Lx1.25"],
      "Hacking ✦": ["L÷3", "L÷2", "L", "Lx1.25", "Lx1.5"],
      "Intelligence": [null, null, null, "D", "D+1"],
      "Energy Generation": ["1", "1", "2", "2", "3"],
      "Energy Conversion": ["1", "2", "3", "4", "5"],
      "Group XP Gain": ["1", "2", "3", "4", "5"],
      "HP Regen": ["L÷4", "L÷3", "L÷2", "L", "Lx1.25"],
      "Resell Value": ["x1.25", "x1.5", "x1.75", "x2", "x2.5"]
    };
    const aestheticPresetOptions = [
      "Valdan (Cyberpunk)",
      "Ydilikian (Medieval)",
      "Asticarian (Modern)",
      "Rtolkan (Steampunk)",
      "Pbosh (Viking/Heavy, Rough Metal)",
      "Cortez (Western)",
      "Cortez (Pirate)",
      "Jiyyagan (Survivor/Jungle)"
    ];

    function toPythonLiteral(value) {
      if (value === null || value === undefined || value === "") {
        return "None";
      }
      return JSON.stringify(value);
    }

    function reportZeroedStatIssue(scope, details = {}) {
      console.error("[WR2 Zeroed Stat Diagnostic]", {
        scope,
        timestamp: new Date().toISOString(),
        ...details
      });
    }

    let availableAbilities = [];
    let abilityDetailMap = new Map();

    function deriveSecondaryStats(stats) {
      const power = stats.power || 0;
      const defense = stats.defense || 0;
      const speed = stats.speed || 0;
      const intelligence = stats.intelligence || 0;
      const perception = intelligence * 2;

      return {
        attackPlus: power,
        damagePlus: power,
        defenseDc: 10 + defense,
        armor: defense,
        initiative: speed,
        movementSpeed: (speed * 2) + 10,
        range: speed + 5,
        perception,
        aoeRange: perception,
        hacking: intelligence
      };
    }

    function normalizeStats(stats) {
      const normalized = {
        ...defaults,
        ...stats
      };
      if (normalized.current_hp == null) {
        normalized.current_hp = normalized.hp;
      }
      return normalized;
    }

    function currentStats() {
      if (!activeCharacter) {
        return normalizeStats({});
      }
      return normalizeStats(activeCharacter.base_stats || {});
    }

    function getStatusStacks(stats) {
      return {
        burn: Math.max(0, Number(stats.status_burn) || 0),
        freeze: Math.max(0, Number(stats.status_freeze) || 0),
        poison: Math.max(0, Number(stats.status_poison) || 0)
      };
    }

    function getStatusEffectsPayload(stats) {
      const stacks = getStatusStacks(stats);
      return {
        burn: stacks.burn,
        freeze: stacks.freeze,
        poison: stacks.poison
      };
    }

    function mergeStatusEffectsIntoStats(baseStats = {}, statusEffects) {
      if (!statusEffects) return baseStats;
      const merged = { ...baseStats };
      merged.status_burn = Number(statusEffects.burn) || 0;
      merged.status_freeze = Number(statusEffects.freeze) || 0;
      merged.status_poison = Number(statusEffects.poison) || 0;
      return merged;
    }

    function normalizeStatusEffects(statusEffects) {
      const normalized = { ...statusEffectDefaults };
      if (!statusEffects) return normalized;
      return {
        burn: Math.max(0, Number(statusEffects.burn) || 0),
        freeze: Math.max(0, Number(statusEffects.freeze) || 0),
        poison: Math.max(0, Number(statusEffects.poison) || 0)
      };
    }

    function pushStatus(message, { tone = "info", actionLabel, onAction, duration = 4500 } = {}) {
      if (!elements.statusPopup) return;
      const toast = document.createElement("div");
      toast.className = `status-toast ${tone}`;
      const messageSpan = document.createElement("span");
      messageSpan.className = "status-message";
      messageSpan.textContent = message;
      toast.appendChild(messageSpan);
      if (actionLabel && typeof onAction === "function") {
        const actionButton = document.createElement("button");
        actionButton.type = "button";
        actionButton.textContent = actionLabel;
        actionButton.addEventListener("click", () => {
          onAction();
          toast.remove();
        });
        toast.appendChild(actionButton);
      }
      elements.statusPopup.appendChild(toast);
      toast.addEventListener("click", () => {
        toast.remove();
      });
      if (duration !== null) {
        setTimeout(() => {
          toast.remove();
        }, duration);
      }
    }

    function getCappedLuckValue(luck, level = null) {
      const numericLuck = Number(luck) || 0;
      const fallbackLevel = currentStats().level;
      const resolvedLevel = Number(level ?? fallbackLevel) || 1;
      const luckLimit = getLevelLimits(resolvedLevel).luck;
      if (!Number.isFinite(luckLimit)) {
        return numericLuck;
      }
      return Math.min(numericLuck, luckLimit);
    }

    function calculateFormulaValue(formula, luck, statName, context = {}) {
      if (formula == null) return 0;
      if (typeof formula === "number") return formula;
      const effectiveLuck = getCappedLuckValue(luck, context.level);
      const gValue = Math.max(0, Number(context.g) || 0);
      const trimmed = String(formula).trim();
      if (!trimmed) return 0;
      if (trimmed.startsWith("x")) {
        return null;
      }
      if (trimmed === "D") {
        return String(effectiveLuck).length;
      }
      if (trimmed === "D+1") {
        return String(effectiveLuck).length + 1;
      }
      const normalized = trimmed.replace(/^\+/, "");
      // Valid grammar: D, D+1, numeric literals, standalone variables (L/G), and binary L/G operator forms.
      if (normalized.toUpperCase() === "L") {
        return effectiveLuck;
      }
      if (normalized.toUpperCase() === "G") {
        return gValue;
      }
      if (/^\d+(\.\d+)?$/.test(normalized)) {
        return Number(normalized);
      }
      const match = normalized.match(/^([LG])([x*÷\/])([\d.]+)$/i);
      if (!match) {
        reportZeroedStatIssue("calculateFormulaValue.unparsed_formula", {
          statName,
          formula: trimmed,
          luck,
          context
        });
        return 0;
      }
      const [, symbol, op, raw] = match;
      const value = Number(raw);
      const baseValue = symbol.toUpperCase() === "G" ? gValue : effectiveLuck;
      let result = 0;
      if (op === "x" || op === "*") {
        result = Math.floor(baseValue * value);
      } else {
        result = Math.floor(baseValue / value);
      }
      if (statName === "Kernel Slots") {
        return Math.min(3, Math.max(1, result));
      }
      const finalResult = Math.max(1, result);
      if (!Number.isFinite(finalResult)) {
        reportZeroedStatIssue("calculateFormulaValue.invalid_result", {
          statName,
          formula: trimmed,
          luck,
          context,
          baseValue,
          parsedValue: value,
          result,
          finalResult
        });
      }
      return finalResult;
    }

    function getChartFormulaForStat(statLabel, rarity) {
      const formulas = statBuffFormulaByLabel[statLabel];
      if (!formulas) return null;
      const rarityIndex = rarityIndexMap[rarity];
      if (!Number.isInteger(rarityIndex)) return null;
      return formulas[rarityIndex] ?? null;
    }

    function getChartLookupLabelForStat(stat) {
      if (!stat || typeof stat !== "object") return null;
      if (typeof stat.label === "string" && stat.label.trim()) {
        return stat.label.trim();
      }
      if (typeof stat.name === "string" && stat.name.includes("✦")) {
        return stat.name.trim();
      }
      return null;
    }

    function recalculateGearStatFromChart(stat, rarity, luck, context = {}) {
      if (!stat || typeof stat !== "object") return stat;
      const chartLookupLabel = getChartLookupLabelForStat(stat);
      const statLabel = chartLookupLabel || stat.label || stat.name || stat.stat;
      const normalizedLookup = typeof statLabel === "string" ? statLabel.trim() : "";
      const chartFormula = getChartFormulaForStat(chartLookupLabel || normalizedLookup, rarity);
      const formula = chartFormula ?? stat.formula;
      if (!formula) {
        reportZeroedStatIssue("recalculateGearStatFromChart.missing_formula", {
          rarity,
          luck,
          context,
          stat
        });
        return { ...stat, formula: chartFormula ?? stat.formula };
      }
      if (typeof formula === "string" && formula.trim().startsWith("x")) {
        return { ...stat, formula, value: formula };
      }
      const value = calculateFormulaValue(formula, luck, statLabel, context);
      if (typeof value === "number" && value <= 0) {
        reportZeroedStatIssue("recalculateGearStatFromChart.non_positive_value", {
          statLabel,
          formula,
          rarity,
          luck,
          context,
          value,
          stat
        });
      }
      return { ...stat, formula, value };
    }

    function debugZeroedGearStats(gear, source = "unknown") {
      if (!gear || typeof gear !== "object") return;
      const scan = (list, listType) => {
        (list || []).forEach((stat, index) => {
          const statName = stat?.name || stat?.label || stat?.stat || "Unknown";
          const hasFormula = stat?.formula != null && String(stat.formula).trim() !== "";
          const resolvedValue = stat?.value ?? stat?.calc;
          if (!hasFormula) return;
          if (!Number.isFinite(Number(resolvedValue)) || Number(resolvedValue) === 0) {
            reportZeroedStatIssue("debugZeroedGearStats.empty_or_zero_stat", {
              source,
              listType,
              index,
              statName,
              formula: stat?.formula,
              value: resolvedValue,
              gearName: gear?.name,
              gearType: gear?.gear_type || gear?.gearType,
              rarity: gear?.rarity,
              color: gear?.color,
              color2: gear?.color2,
              stat
            });
          }
        });
      };
      scan(gear.stats, "stats");
      scan(gear.stat_modifiers, "stat_modifiers");
    }

    function recalculateGearStatsForRarity(gear, rarity, luck, context = {}) {
      const nextGear = { ...(gear || {}) };
      nextGear.stats = Array.isArray(gear?.stats)
        ? gear.stats.map(stat => recalculateGearStatFromChart(stat, rarity, luck, context))
        : [];
      nextGear.stat_modifiers = Array.isArray(gear?.stat_modifiers)
        ? gear.stat_modifiers.map(stat => recalculateGearStatFromChart(stat, rarity, luck, context))
        : [];
      debugZeroedGearStats(nextGear, "recalculateGearStatsForRarity");
      return nextGear;
    }

    function resolveAbilityDetails(ability) {
      if (!ability || typeof ability !== "string") return ability;
      return abilityDetailMap.get(ability) || ability;
    }

    function parseAbilityLines(ability) {
      const resolved = resolveAbilityDetails(ability);
      if (!resolved) return [];
      if (typeof resolved === "string") return [resolved];
      const details = resolved.tierDetails;
      if (!details) return [];
      if (typeof details === "string") {
        return details.split("\n");
      }
      return Object.values(details).flatMap(detail => String(detail || "").split("\n"));
    }

    function parseAbilityStatLine(line) {
      const cleaned = String(line || "").trim().replace(/^[-•]\s*/, "");
      if (!cleaned.includes(":")) return null;
      const [rawStat, ...rest] = cleaned.split(":");
      const statName = rawStat.trim();
      if (!statName || statName.toLowerCase().includes("basic stat of your choice")) return null;
      const rawValue = rest.join(":").trim();
      if (!rawValue) return null;
      if (/^[+-]?\d+(\.\d+)?$/.test(rawValue.replace(/^\+/, ""))) {
        return { statName, value: Number(rawValue.replace(/^\+/, "")) };
      }
      return { statName, formula: rawValue.replace(/^\+/, "") };
    }

    function parseStatusAbilityLine(line, statusStacks) {
      const cleaned = String(line || "").trim().replace(/^[-•]\s*/, "");
      if (!cleaned) return [];
      const results = [];
      const freezeDefenseMatch = cleaned.match(/freezing.*\+([\d.]+)\s+defense dc and armor/i);
      if (freezeDefenseMatch && statusStacks.freeze > 0) {
        const value = Number(freezeDefenseMatch[1]);
        if (!Number.isNaN(value)) {
          results.push({ statName: "Defense DC", value });
          results.push({ statName: "Armor", value });
        }
      }
      const freezeDamageMatch = cleaned.match(/deal\s*\+?([\d.]+)\s*points?\s*of damage for each stack of freeze/i);
      if (freezeDamageMatch && statusStacks.freeze > 0) {
        const perStack = Number(freezeDamageMatch[1]);
        if (!Number.isNaN(perStack)) {
          results.push({ statName: "Damage Plus", value: perStack * statusStacks.freeze });
        }
      }
      return results;
    }

    function getAoeBuffMultiplier() {
      let multiplier = 1;
      characterGear.forEach(entry => {
        if (!entry.equipped || !entry.gear) return;
        const gearType = entry.gear.gear_type || entry.gear.gearType;
        if (gearType !== "Kernel") return;
        (entry.gear.abilities || []).forEach(ability => {
          if (!ability || ability.name !== "AOE Buff") return;
          parseAbilityLines(ability).forEach(line => {
            const match = String(line).match(/AOE Radius now = Perception x([\d.]+)/i);
            if (match) {
              const value = Number(match[1]);
              if (!Number.isNaN(value)) {
                multiplier = Math.max(multiplier, value);
              }
            }
          });
        });
      });
      return multiplier;
    }

    function mergeBonuses(target, source) {
      ["base", "derived", "misc"].forEach(section => {
        Object.keys(source[section]).forEach(key => {
          target[section][key] += source[section][key] || 0;
        });
      });
      return target;
    }

    function getEquippedColorCounts() {
      const counts = {};
      characterGear.forEach(entry => {
        if (!entry.equipped || !entry.gear) return;
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        if (gearType === "Bauble") return;
        [gear.color, gear.color2].filter(Boolean).forEach(color => {
          counts[color] = (counts[color] || 0) + 1;
        });
      });
      return counts;
    }

    function hasAllCoreColorsEquipped() {
      const counts = getEquippedColorCounts();
      return ["Red", "Blue", "Green", "Gray"].every(color => (counts[color] || 0) > 0);
    }

    function createEmptyBonus() {
      return {
        base: {
          luck: 0,
          inventory_slots: 0,
          energy_cap: 0,
          kernel_slots: 0,
          hp: 0,
          power: 0,
          defense: 0,
          speed: 0,
          intelligence: 0
        },
        derived: {
          attackPlus: 0,
          damagePlus: 0,
          defenseDc: 0,
          armor: 0,
          initiative: 0,
          movementSpeed: 0,
          range: 0,
          perception: 0,
          aoeRange: 0,
          hacking: 0
        },
        misc: {
          group_xp_gain: 0,
          hp_regen: 0,
          energy_conversion: 0,
          energy_generation: 0,
          resell_value: 0
        }
      };
    }

    function createEmptyBonusSources() {
      return {
        base: {
          luck: [],
          inventory_slots: [],
          energy_cap: [],
          kernel_slots: [],
          hp: [],
          power: [],
          defense: [],
          speed: [],
          intelligence: []
        },
        derived: {
          attackPlus: [],
          damagePlus: [],
          defenseDc: [],
          armor: [],
          initiative: [],
          movementSpeed: [],
          range: [],
          perception: [],
          aoeRange: [],
          hacking: []
        },
        misc: {
          group_xp_gain: [],
          hp_regen: [],
          energy_conversion: [],
          energy_generation: [],
          resell_value: []
        }
      };
    }

    function applyStatBonus(target, statName, value, sourceLabel, sources) {
      const key = statKeyMap[statName];
      if (!key || !value) return;
      if (Object.prototype.hasOwnProperty.call(target.derived, key)) {
        target.derived[key] += value;
        if (sources && sourceLabel) {
          sources.derived[key].push({ value, label: sourceLabel });
        }
      } else if (Object.prototype.hasOwnProperty.call(target.misc, key)) {
        target.misc[key] += value;
        if (sources && sourceLabel) {
          sources.misc[key].push({ value, label: sourceLabel });
        }
      } else if (Object.prototype.hasOwnProperty.call(target.base, key)) {
        target.base[key] += value;
        if (sources && sourceLabel) {
          sources.base[key].push({ value, label: sourceLabel });
        }
      }
    }

    function calculateGearBonuses(baseStats) {
      const equippedColorCounts = getEquippedColorCounts();
      const baseLuck = baseStats.luck || 0;
      const statusStacks = getStatusStacks(baseStats);
      const nonBaubleBonus = createEmptyBonus();
      const abilityBonus = createEmptyBonus();
      const baubleBonus = createEmptyBonus();
      const sources = createEmptyBonusSources();
      const adventuringPluses = [];

      characterGear.forEach(entry => {
        if (!entry.gear) return;
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        const isBauble = gearType === "Bauble";
        const isEquipped = entry.equipped;
        const isInventory = entry.gear_slot === "inventory";

        if (!isBauble && isEquipped) {
          (gear.stats || []).forEach(stat => {
            const statName = stat.name || stat.stat || stat.label;
            if (!statName) return;
            const value = stat.value ?? stat.calc ?? calculateFormulaValue(stat.formula, baseLuck, statName);
            if (typeof value !== "number") return;
            if (value === 0 && stat?.formula) {
              reportZeroedStatIssue("calculateGearBonuses.zero_non_bauble_stat", {
                statName,
                formula: stat.formula,
                baseLuck,
                gearName: gear?.name,
                gearType,
                rarity: gear?.rarity,
                color: gear?.color,
                color2: gear?.color2,
                stat
              });
            }
            applyStatBonus(nonBaubleBonus, statName, value, gearType, sources);
          });
        }
      });

      const interimLuck = applyGearBonuses(baseStats, nonBaubleBonus).luck || baseLuck;

      characterGear.forEach(entry => {
        if (!entry.gear) return;
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        if (gearType !== "Kernel" || !entry.equipped) return;
        (gear.abilities || []).forEach(ability => {
          const lines = parseAbilityLines(ability);
          const hasColorSpread = lines.some(line => line.toLowerCase().includes("each color equipped"));
          if (hasColorSpread && !hasAllCoreColorsEquipped()) return;
          const abilityLabel = typeof ability === "string" ? "Kernel Ability" : ability.name || "Kernel Ability";
          const gLine = lines.find(line => line.includes("G ="));
          let gValue = 0;
          if (gLine) {
            const match = gLine.match(/G = The amount of (\w+)/i);
            if (match) {
              const color = match[1];
              gValue = equippedColorCounts[color] || 0;
            }
          }
          lines.forEach(line => {
            if (line.includes("G =")) return;
            const parsed = parseAbilityStatLine(line);
            if (parsed) {
              const value = parsed.value ?? calculateFormulaValue(parsed.formula, interimLuck, parsed.statName, { g: gValue });
              if (typeof value === "number") {
                applyStatBonus(abilityBonus, parsed.statName, value, abilityLabel, sources);
              }
            }
            const statusBonuses = parseStatusAbilityLine(line, statusStacks);
            statusBonuses.forEach(statusBonus => {
              applyStatBonus(abilityBonus, statusBonus.statName, statusBonus.value, abilityLabel, sources);
            });
          });
        });
      });

      const combinedBeforeBauble = mergeBonuses(mergeBonuses(createEmptyBonus(), nonBaubleBonus), abilityBonus);
      const interimStats = applyGearBonuses(baseStats, combinedBeforeBauble);
      const updatedLuck = interimStats.luck || baseLuck;
      const cappedUpdatedLuck = getCappedLuckValue(updatedLuck, baseStats.level);

      characterGear.forEach(entry => {
        if (!entry.gear) return;
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        const isBauble = gearType === "Bauble";
        const isInventory = entry.gear_slot === "inventory";
        if (!isBauble || !isInventory) return;
        const gValue = gear.color ? (equippedColorCounts[gear.color] || 0) : 0;
        (gear.stat_modifiers || []).forEach(stat => {
          const statName = stat.name || stat.stat || stat.label;
          if (!statName) return;
          const value = stat.value ?? stat.calc ?? calculateFormulaValue(stat.formula, cappedUpdatedLuck, statName, { g: gValue });
          if (typeof value !== "number") return;
          if (value === 0 && stat?.formula) {
            reportZeroedStatIssue("calculateGearBonuses.zero_bauble_stat_modifier", {
              statName,
              formula: stat.formula,
              gValue,
              cappedUpdatedLuck,
              gearName: gear?.name,
              gearType,
              rarity: gear?.rarity,
              color: gear?.color,
              color2: gear?.color2,
              stat
            });
          }
          if (statKeyMap[statName]) {
            applyStatBonus(baubleBonus, statName, value, "Bauble", sources);
          } else {
            adventuringPluses.push({ name: statName, value });
          }
        });
      });

      const combined = mergeBonuses(mergeBonuses(nonBaubleBonus, abilityBonus), baubleBonus);
      mergeBonuses(combined, tempConsumableBonus);
      Object.keys(tempConsumableBonus.base).forEach(key => {
        const value = tempConsumableBonus.base[key] || 0;
        if (value) {
          sources.base[key].push({ value, label: "Temp Buff" });
        }
      });
      Object.keys(tempConsumableBonus.derived).forEach(key => {
        const value = tempConsumableBonus.derived[key] || 0;
        if (value) {
          sources.derived[key].push({ value, label: "Temp Buff" });
        }
      });
      Object.keys(tempConsumableBonus.misc).forEach(key => {
        const value = tempConsumableBonus.misc[key] || 0;
        if (value) {
          sources.misc[key].push({ value, label: "Temp Buff" });
        }
      });
      combined.sources = sources;
      combined.adventuringPluses = adventuringPluses;
      return combined;
    }

    function applyGearBonuses(baseStats, gearBonus) {
      const combined = { ...baseStats };
      Object.keys(gearBonus.base).forEach(key => {
        combined[key] = (combined[key] || 0) + (gearBonus.base[key] || 0);
      });
      combined.current_hp = Math.min(combined.current_hp ?? combined.hp, combined.hp);
      return combined;
    }

    function getGearGeneratorLuck(stats) {
      const baseLuck = stats.luck || 0;
      const bonus = Number(gearBonusLuck.value) || 0;
      const totalLuck = baseLuck + bonus;
      const luckLimit = getLevelLimits(stats.level).luck;
      if (!Number.isFinite(luckLimit)) {
        return totalLuck;
      }
      return Math.min(totalLuck, luckLimit);
    }

    function updateGearGeneratorLuck(stats) {
      const baseLuck = stats.luck || 0;
      const bonus = Number(gearBonusLuck.value) || 0;
      const requestedLuck = baseLuck + bonus;
      const cappedLuck = getGearGeneratorLuck(stats);
      const luckLimit = getLevelLimits(stats.level).luck;
      gearTotalLuck.textContent = cappedLuck;
      if (gearLuckLimitNote) {
        if (Number.isFinite(luckLimit) && requestedLuck > luckLimit) {
          gearLuckLimitNote.textContent = `Luck cap reminder: requested ${requestedLuck}, but generation is capped at ${luckLimit} for your level.`;
        } else {
          gearLuckLimitNote.textContent = "";
        }
      }
    }

    function getGearModTier(stats = currentStats()) {
      const tier = Number(stats.gear_mod_discount_tier) || 0;
      return Math.max(0, Math.min(5, tier));
    }

    function getGearModDiscountPercent(stats = currentStats()) {
      const tierInfo = gearModificationDiscountTiers.find(item => item.tier === getGearModTier(stats));
      return tierInfo?.discount || 0;
    }

    function applyGearModDiscount(cost, stats = currentStats()) {
      if (!Number.isFinite(cost)) return "-";
      const discount = getGearModDiscountPercent(stats);
      return Math.max(0, Math.round(cost * (1 - (discount / 100))));
    }

    function formatCostAfterDiscount(cost, stats = currentStats()) {
      if (!Number.isFinite(cost)) return "-";
      const discounted = applyGearModDiscount(cost, stats);
      const discount = getGearModDiscountPercent(stats);
      return `${discounted} Essence (${discount}% off)`;
    }

    function getGearModificationCandidates(location = "all") {
      return characterGear
        .filter(entry => entry?.gear)
        .filter(entry => {
          if (location === "all") return true;
          if (location === "equipped") return !!entry.equipped;
          return entry.gear_slot === location;
        })
        .map(entry => ({
        id: entry.gear_id,
        slot: entry.gear_slot,
        equipped: !!entry.equipped,
        label: `${formatGearName(entry.gear)} — ${entry.gear.rarity || "Unknown"} (${entry.gear.gear_type || "Unknown"}) [${entry.gear_slot}]`,
        entry
      }));
    }

    function formatEssenceCostWithTotal(cost, stats = currentStats()) {
      return `${formatCostAfterDiscount(cost, stats)}`;
    }

    function renderGearModificationSelection() {
      pendingModificationRecord = null;
      if (!gearModificationBody) return;
      const stats = currentStats();
      gearModificationBody.innerHTML = `
        <p class="muted">Full rules + Local Shop info: <a href="https://xeonrapture.com/xr/XRRPG+2.0/Sub-RPGs/Webrunning+2.0/Gear/Gear+Modification+and+the+Local+Shop" target="_blank" rel="noopener">Gear Modification and the Local Shop</a>.</p>
        <label>
          Gear Location
          <select id="gearModificationLocation">
            <option value="all">Any Section</option>
            <option value="equipped">Equipped</option>
            <option value="inventory">Inventory</option>
            <option value="local_node">Local Node Storage</option>
          </select>
        </label>
        <label>
          Piece to Modify
          <select id="gearModificationTarget"></select>
        </label><br>
        <div class="gear-mod-option-grid">
          <button type="button" data-mod-choice="upgrading" title="Moves gear up a rarity, recalculates stat buffs with your current Luck, can add new modifiers">Upgrade</button>
          <button type="button" data-mod-choice="rerolling" title="Rerolls Stat Buffs / Actives / Passives using current Luck, keeps modifier counts the same">Reroll Modifiers</button>
          <button type="button" data-mod-choice="condensing" title="Takes abilities or stat buffs from a source piece and moves them into a target piece, destroying source gear">Condense Into</button>
          <button type="button" data-mod-choice="aesthetic" title="Changes gear appearance or swaps aesthetics between two pieces">Aesthetic Modification</button>
        </div>
      `;
      const locationSelect = document.getElementById("gearModificationLocation");
      const targetSelect = document.getElementById("gearModificationTarget");
      if (activeGearRow?.gear_slot) {
        const initialLocation = activeGearRow.equipped ? "equipped" : activeGearRow.gear_slot;
        if (["equipped", "inventory", "local_node"].includes(initialLocation)) {
          locationSelect.value = initialLocation;
        }
      }
      const refreshTargets = () => {
        const location = locationSelect?.value || "all";
        const candidates = getGearModificationCandidates(location);
        targetSelect.innerHTML = candidates.length
          ? candidates.map(item => `<option value="${item.id}">${item.label}</option>`).join("")
          : '<option value="">No gear available in this section</option>';
        if (selectedGearModificationTargetId && candidates.some(item => item.id === selectedGearModificationTargetId)) {
          targetSelect.value = selectedGearModificationTargetId;
        }
        selectedGearModificationTargetId = targetSelect.value || "";
      };
      refreshTargets();
      locationSelect?.addEventListener("change", refreshTargets);
      targetSelect?.addEventListener("change", () => {
        selectedGearModificationTargetId = targetSelect.value || "";
      });
      selectedModificationType = null;
      if (gearModificationStatus) {
        gearModificationStatus.textContent = "";
      }
      if (gearModificationBack) {
        gearModificationBack.classList.add("hidden");
      }
      gearModificationUndo?.classList.add("hidden");
      gearModificationDetails?.classList.add("hidden");
    }

    function formatFullStatList(stats = [], modifiers = []) {
      const values = [];
      stats.forEach(stat => values.push(formatStatSummary(stat)));
      modifiers.forEach(stat => values.push(formatStatSummary(stat)));
      return values.length ? values.join(", ") : "None";
    }

    function formatFullAbilityList(abilities = []) {
      return abilities.length ? abilities.map(formatAbilitySummary).join(", ") : "None";
    }

    function renderGearModificationDetail(choice) {
      const targetSelect = document.getElementById("gearModificationTarget");
      const targetId = targetSelect?.value || selectedGearModificationTargetId;
      const entry = findGearEntry(targetId);
      if (!entry || !gearModificationBody) return;
      selectedModificationType = choice;
      selectedGearModificationTargetId = entry.gear_id;
      const stats = currentStats();
      const rarity = entry.gear.rarity || "Common";
      const common = `<p class="muted">Selected gear location: ${formatSlotLabel(entry.gear_slot)}.</p>`;
      const essenceLine = `<p class="muted">Current Essence: ${stats.essence || 0}</p>`;
      if (choice === "upgrading") {
        const row = gearUpgradeCosts[rarity];
        gearModificationBody.innerHTML = row ? `
          <strong>Upgrade: ${formatGearName(entry.gear)}</strong>
          <p>This updates stat values based on your current Luck and can add new modifiers and/or abilities.</p>
          <p>Cost: <strong>${formatEssenceCostWithTotal(row.cost, stats)}</strong></p>
          ${essenceLine}
          <button type="button" data-mod-apply="upgrading">Upgrade to ${row.next}</button>
          ${common}` : `<p>${rarity} gear cannot be upgraded further.</p>${essenceLine}${common}`;
      } else if (choice === "rerolling") {
        const cost = gearRerollCosts[rarity];
        gearModificationBody.innerHTML = `
          <p><strong>Reroll Modifiers: ${formatGearName(entry.gear)}</strong></p>
          <p>Reroll Stat Buffs, Actives, and Passives while keeping the same amount of each modifier type. Uses your current Luck.</p>
          <p>Cost: <strong>${formatEssenceCostWithTotal(cost, stats)}</strong></p>
          ${essenceLine}
          <button type="button" data-mod-apply="rerolling">Reroll Modifiers</button>
          ${common}`;
      } else if (choice === "condensing") {
        if (!canGearCondense(entry.gear)) {
          gearModificationBody.innerHTML = `
            <strong>Condense Into: ${formatGearName(entry.gear)}</strong>
            <p>This gear cannot be condensed into. Only non-Kernel/Bauble/Consumable gear can use Condense Into.</p>
            ${common}`;
          return;
        }
        const costOptions = (gearCondenseCosts[rarity] || []).map((cost, idx) => `<option value="${idx + 1}">${idx + 1} modifier${idx ? "s" : ""}</option>`).join("");
        const donorOptions = characterGear
          .filter(item => item.gear_id !== entry.gear_id && canGearCondense(item.gear))
          .map(item => `<option value="${item.gear_id}">${formatGearName(item.gear)} [${item.gear_slot}]</option>`)
          .join("");
        gearModificationBody.innerHTML = `
          <strong>Condense Into: ${formatGearName(entry.gear)}</strong>
          <p>Condense source gear into this target gear. The source gear transfers chosen stat buffs or chosen abilities to the target.</p>
          <p><strong>Warning:</strong> The source gear is permanently destroyed.</p>
          <p class="muted">1 transfer: ${formatCostAfterDiscount((gearCondenseCosts[rarity] || [])[0] || 0, stats)} · 2 transfers: ${formatCostAfterDiscount((gearCondenseCosts[rarity] || [])[1] || 0, stats)} · 3 transfers: ${formatCostAfterDiscount((gearCondenseCosts[rarity] || [])[2] || 0, stats)}</p>
          ${essenceLine}
          <label>Modifiers to Transfer
            <select id="gearCondenseCount">${costOptions || '<option value="1">1 modifier</option>'}</select>
          </label>
          <label>Source Gear to Condense Into Target
            <select id="gearCondenseDonor">${donorOptions || '<option value="">No source gear available</option>'}</select>
          </label>
          <label>Transfer Type
            <select id="gearCondenseTransferType">
              <option value="stat">Stat Buff</option>
              <option value="ability">Ability</option>
            </select>
          </label>
          <label>Modifiers to Transfer
            <select id="gearCondenseModifier" multiple size="6"></select>
          </label>
          <p class="muted">Hold Ctrl/Cmd to select multiple modifiers</p>
          <button type="button" data-mod-apply="condensing" ${donorOptions ? '' : 'disabled'}>Condense</button>
          ${common}`;
      } else if (choice === "aesthetic") {
        if (!canGearUseAestheticModification(entry.gear)) {
          gearModificationBody.innerHTML = `
            <strong>Aesthetic Modification: ${formatGearName(entry.gear)}</strong>
            <p>This gear has no aesthetic, so it cannot be used for aesthetic modification or swap.</p>
            ${common}`;
          return;
        }
        const others = characterGear
          .filter(item => item.gear_id !== entry.gear_id && canGearUseAestheticModification(item.gear))
          .map(item => `<option value="${item.gear_id}">${formatGearName(item.gear)} — ${item.gear.aesthetic || "None"}</option>`)
          .join("");
        gearModificationBody.innerHTML = `
          <strong>Aesthetic Modification: ${formatGearName(entry.gear)}</strong>
          <p class="muted">Current Aesthetic: ${entry.gear.aesthetic || "None"}</p>
          <p class="muted">Aesthetic Modification Cost: ${formatCostAfterDiscount(300, stats)} · Aesthetic Swap Cost: ${formatCostAfterDiscount(100, stats)}</p>
          ${essenceLine}
          <label>Mode
            <select id="gearAestheticMode">
              <option value="modify">Aesthetic Modification</option>
              <option value="swap">Aesthetic Swap</option>
            </select>
          </label>
          <label id="gearAestheticPresetWrap">Aesthetic Preset
            <select id="gearAestheticPreset">
              <option value="">Choose a preset</option>
              ${aestheticPresetOptions.map(option => `<option value="${option}">${option}</option>`).join("")}
            </select>
          </label>
          <label id="gearAestheticSwapTargetWrap">Swap Target
            <select id="gearAestheticSwapTarget">${others || '<option value="">No swap target available</option>'}</select>
          </label>
          <p id="gearAestheticSwapPreview" class="muted"></p>
          <button type="button" data-mod-apply="aesthetic" ${others ? "" : "disabled"}>Change Aesthetic</button>
          ${common}`;
      }
      if (choice === "condensing") {
        const donorSelect = document.getElementById("gearCondenseDonor");
        const transferTypeSelect = document.getElementById("gearCondenseTransferType");
        const modifierSelect = document.getElementById("gearCondenseModifier");
        const countSelect = document.getElementById("gearCondenseCount");
        const maxCaps = gearMaxes[entry.gear.rarity] || gearMaxes.Common;
        const targetStatCount = Array.isArray(entry.gear.stats)
          ? entry.gear.stats.length
          : Array.isArray(entry.gear.stat_modifiers)
            ? entry.gear.stat_modifiers.length
            : 0;
        const targetAbilityCount = Array.isArray(entry.gear.abilities) ? entry.gear.abilities.length : 0;
        const enforceCondenseSelectionLimit = () => {
          const desiredCount = Math.max(1, Number(countSelect?.value || 1));
          const selectedOptions = Array.from(modifierSelect?.selectedOptions || []);
          if (selectedOptions.length <= desiredCount) return;
          selectedOptions.slice(desiredCount).forEach(option => {
            option.selected = false;
          });
        };
        const syncDonorModifiers = () => {
          const donor = findGearEntry(donorSelect?.value);
          const donorStats = Array.isArray(donor?.gear?.stats) ? donor.gear.stats : [];
          const donorStatModifiers = Array.isArray(donor?.gear?.stat_modifiers) ? donor.gear.stat_modifiers : [];
          const donorAbilities = Array.isArray(donor?.gear?.abilities) ? donor.gear.abilities : [];
          const transferType = transferTypeSelect?.value || "stat";
          const donorStatPool = donorStats.length ? donorStats : donorStatModifiers;
          const options = transferType === "ability"
            ? donorAbilities.map((ability, idx) => `<option value="${idx}">${formatAbilitySummary(ability)}</option>`)
            : donorStatPool.map((stat, idx) => `<option value="${idx}">${formatStatSummary(stat)}</option>`);
          modifierSelect.innerHTML = options.length ? options.join("") : '<option value="">No source modifiers available</option>';
          if (countSelect) {
            const remainingCap = transferType === "ability"
              ? Math.max(0, maxCaps.activePassiveMax - targetAbilityCount)
              : Math.max(0, maxCaps.statBuffMax - targetStatCount);
            const maxSelectable = Math.max(0, Math.min(options.length, remainingCap));
            Array.from(countSelect.options).forEach(option => {
              option.disabled = Number(option.value) > maxSelectable;
            });
            if (maxSelectable === 0) {
              countSelect.value = "1";
            } else if (Number(countSelect.value) > maxSelectable) {
              countSelect.value = String(maxSelectable);
            }
          }
          enforceCondenseSelectionLimit();
        };
        donorSelect?.addEventListener("change", syncDonorModifiers);
        transferTypeSelect?.addEventListener("change", syncDonorModifiers);
        countSelect?.addEventListener("change", enforceCondenseSelectionLimit);
        modifierSelect?.addEventListener("change", enforceCondenseSelectionLimit);
        syncDonorModifiers();
      }
      if (choice === "aesthetic") {
        const swapTarget = document.getElementById("gearAestheticSwapTarget");
        const modeSelect = document.getElementById("gearAestheticMode");
        const preview = document.getElementById("gearAestheticSwapPreview");
        const presetWrap = document.getElementById("gearAestheticPresetWrap");
        const swapWrap = document.getElementById("gearAestheticSwapTargetWrap");
        const syncSwapPreview = () => {
          if (!preview) return;
          const mode = modeSelect?.value || "modify";
          if (presetWrap) presetWrap.classList.toggle("hidden", mode !== "modify");
          if (swapWrap) swapWrap.classList.toggle("hidden", mode !== "swap");
          if (mode !== "swap") {
            preview.textContent = "";
            return;
          }
          const otherEntry = findGearEntry(swapTarget?.value);
          preview.textContent = otherEntry
            ? `Swap target aesthetic: ${otherEntry.gear?.aesthetic || "None"}`
            : "Swap target aesthetic: None";
        };
        swapTarget?.addEventListener("change", syncSwapPreview);
        modeSelect?.addEventListener("change", syncSwapPreview);
        syncSwapPreview();
      }
      if (gearModificationStatus) {
        gearModificationStatus.textContent = "";
      }
      if (gearModificationBack) {
        gearModificationBack.classList.remove("hidden");
      }
      gearModificationUndo?.classList.add("hidden");
      gearModificationDetails?.classList.add("hidden");
    }

    function formatStatSummary(stat = {}) {
      const statName = stat.label || stat.name || "Stat";
      if (typeof stat.value === "number") {
        return `${statName}: ${formatSignedValue(stat.value)}`;
      }
      if (stat.formula) {
        return `${statName}: ${stat.formula}`;
      }
      return statName;
    }

    function formatAbilitySummary(ability = {}) {
      const name = ability.name || "Unknown Ability";
      const type = ability.type || "Ability";
      const tierKeys = getUnlockedTierLabelsForAbility(ability, ability?.rarity);
      const tierLabel = tierKeys.length ? ` (${tierKeys.join(", ")})` : "";
      return `${name} [${type}]${tierLabel}`;
    }

    function getUnlockedTierLabelsForAbility(ability, rarity = null) {
      if (!ability || typeof ability !== "object") return [];
      const tierLimit = getAbilityTierLimit(ability.name, rarity || ability.rarity);
      return Object.keys(ability.tierDetails || {}).filter(tier => {
        if (tierLimit === null) return true;
        const tierNumber = getTierNumberFromLabel(tier);
        return tierNumber === null || tierNumber <= tierLimit;
      });
    }

    function summarizeGearModificationResult(choice, before, after, { donorSnapshot, secondTargetSnapshot } = {}) {
      const summary = [];
      if (choice === "upgrading") {
        summary.push(`Rarity: ${before.rarity || "Unknown"} → ${after.rarity || "Unknown"}`);
      }
      const beforeStats = Array.isArray(before.stats) ? before.stats : [];
      const afterStats = Array.isArray(after.stats) ? after.stats : [];
      const beforeAbilities = Array.isArray(before.abilities) ? before.abilities : [];
      const afterAbilities = Array.isArray(after.abilities) ? after.abilities : [];

      const newStats = afterStats.slice(beforeStats.length);
      const newAbilities = afterAbilities.slice(beforeAbilities.length);
      if (newStats.length) {
        summary.push(`New stat buffs: ${newStats.map(formatStatSummary).join(", ")}`);
      }
      if (newAbilities.length) {
        summary.push(`New abilities: ${newAbilities.map(formatAbilitySummary).join(", ")}`);
      }

      if (choice !== "rerolling") {
        const statChanges = [];
        const comparedStats = Math.min(beforeStats.length, afterStats.length);
        for (let i = 0; i < comparedStats; i += 1) {
          const prev = beforeStats[i];
          const next = afterStats[i];
          if (!prev || !next) continue;
          const prevVal = typeof prev.value === "number" ? prev.value : prev.formula;
          const nextVal = typeof next.value === "number" ? next.value : next.formula;
          if (prevVal !== nextVal) {
            statChanges.push(`${next.label || next.name || "Stat"}: ${prevVal} → ${nextVal}`);
          }
        }
        if (statChanges.length) {
          summary.push(`Stat changes: ${statChanges.join(", ")}`);
        }

        const abilityTierChanges = [];
        const comparedAbilities = Math.min(beforeAbilities.length, afterAbilities.length);
        for (let i = 0; i < comparedAbilities; i += 1) {
          const prev = beforeAbilities[i] || {};
          const next = afterAbilities[i] || {};
          const prevTiers = getUnlockedTierLabelsForAbility(prev, before.rarity).join(", ") || "None";
          const nextTiers = getUnlockedTierLabelsForAbility(next, after.rarity).join(", ") || "None";
          if (prevTiers !== nextTiers) {
            abilityTierChanges.push(`${next.name || prev.name || "Ability"}: ${prevTiers} → ${nextTiers}`);
          }
        }
        if (abilityTierChanges.length) {
          summary.push(`Ability tier changes: ${abilityTierChanges.join(", ")}`);
        }
      }

      if (choice === "rerolling") {
        summary.push("Rerolled modifiers on this gear.");
      }

      if (choice === "condensing" && donorSnapshot) {
        summary.push(`Condensed ${formatGearName(donorSnapshot.gear)} into ${formatGearName(after)}.`);
      }
      if (choice === "aesthetic") {
        const beforeAesthetic = before.aesthetic || "None";
        const afterAesthetic = after.aesthetic || "None";
        if (beforeAesthetic !== afterAesthetic) {
          summary.push(`Aesthetic: ${beforeAesthetic} → ${afterAesthetic}`);
        }
        if (secondTargetSnapshot) {
          summary.push(`Swapped with: ${formatGearName(secondTargetSnapshot.after)}`);
        }
      }

      if (!summary.length) {
        summary.push("No visible modifier changes were detected.");
      }
      return summary;
    }

    function renderGearModificationResult(record) {
      if (!gearModificationBody) return;
      const summary = summarizeGearModificationResult(
        record.modification?.choice,
        record.modification?.before || {},
        record.modification?.after || {},
        {
          donorSnapshot: record.modification?.donorSnapshot,
          secondTargetSnapshot: record.modification?.secondTargetSnapshot
        }
      );
      gearModificationBody.innerHTML = `
        <h3>Modification Complete</h3>
        <p><strong>${record.label}</strong></p>
        <p class="muted">Spent ${record.modification?.cost || 0} Essence.</p>
        <ul>${summary.map(item => `<li>${item}</li>`).join("")}</ul>
      `;
      if (gearModificationStatus) {
        gearModificationStatus.textContent = "";
      }
      if (gearModificationBack) {
        gearModificationBack.classList.remove("hidden");
      }
      gearModificationUndo?.classList.remove("hidden");
      gearModificationDetails?.classList.remove("hidden");
    }

    function openGearModificationModal({ source = "hub", entry = null } = {}) {
      gearModificationSource = source;
      if (entry) {
        activeGearRow = entry;
        selectedGearModificationTargetId = entry.gear_id;
      } else {
        selectedGearModificationTargetId = "";
      }
      renderGearModificationSelection();
      if (entry) {
        const select = document.getElementById("gearModificationTarget");
        if (select) select.value = entry.gear_id;
      }
      gearModificationModal?.classList.remove("hidden");
    }

    function closeGearModificationModal() {
      pendingModificationRecord = null;
      gearModificationUndo?.classList.add("hidden");
      gearModificationDetails?.classList.add("hidden");
      gearModificationModal?.classList.add("hidden");
    }

    function cloneJson(value) {
      return JSON.parse(JSON.stringify(value));
    }

    async function updateEssenceBy(delta) {
      const updatedEssence = Math.max(0, (activeCharacter.base_stats?.essence || 0) + delta);
      const updatedStats = { ...activeCharacter.base_stats, essence: updatedEssence };
      const { error } = await sb
        .from("webrunning_characters")
        .update({ base_stats: updatedStats })
        .eq("id", activeCharacter.id)
        .eq("user_id", currentUser.id);
      if (error) throw error;
      activeCharacter.base_stats = updatedStats;
      return updatedEssence;
    }

    function isColorCompatibleStat(stat, color) {
      if (!color || color === "Neutral") return true;
      const name = normalizeLabel(stat?.label || stat?.name);
      if (!name) return true;
      const keywords = colorBuffKeywords[color] || [];
      return keywords.some(keyword => name.includes(keyword));
    }

    function getStatIdentityKey(stat) {
      const raw = String(stat?.label || stat?.name || "");
      return normalizeLabel(raw.replace(/✦+/g, "").replace(/\s+/g, " "));
    }

    function inferColorFromStat(stat) {
      const name = normalizeLabel(stat?.label || stat?.name);
      if (!name) return null;
      const match = Object.entries(colorBuffKeywords).find(([, keywords]) => keywords.some(keyword => name.includes(keyword)));
      return match?.[0] || null;
    }

    function inferColorFromAbility(ability) {
      const textChunks = [];
      if (ability?.name) textChunks.push(String(ability.name));
      parseAbilityLines(ability).forEach(line => textChunks.push(String(line)));
      const joined = normalizeLabel(textChunks.join(" "));
      if (!joined) return null;
      let bestColor = null;
      let bestScore = 0;
      Object.entries(colorBuffKeywords).forEach(([color, keywords]) => {
        const score = keywords.reduce((acc, keyword) => acc + (joined.includes(keyword) ? 1 : 0), 0);
        if (score > bestScore) {
          bestScore = score;
          bestColor = color;
        }
      });
      return bestColor;
    }

    function preferredModifierColor(modifier, type, fallbackColor = null) {
      if (modifier?.source_color) return modifier.source_color;
      const inferred = type === "ability" ? inferColorFromAbility(modifier) : inferColorFromStat(modifier);
      return inferred || fallbackColor || null;
    }

    function pickUniqueStat(stats, takenNames = []) {
      const taken = new Set(takenNames.map(name => getStatIdentityKey({ label: name })));
      return (stats || []).find(stat => !taken.has(getStatIdentityKey(stat))) || null;
    }


    function takeRerolledStats(rerolledStats = [], targetCount = 0) {
      if (targetCount <= 0) return [];
      const selected = [];
      const taken = new Set();
      (rerolledStats || []).forEach(stat => {
        if (selected.length >= targetCount) return;
        const key = getStatIdentityKey(stat);
        if (!key || taken.has(key)) return;
        selected.push(cloneJson(stat));
        taken.add(key);
      });
      for (const stat of (rerolledStats || [])) {
        if (selected.length >= targetCount) break;
        selected.push(cloneJson(stat));
      }
      return selected.slice(0, targetCount);
    }

    function takeRerolledAbilities(rerolledAbilities = [], targetCount = 0, rarity = null) {
      if (targetCount <= 0) return [];
      const selected = [];
      const taken = new Set();
      (rerolledAbilities || []).forEach(ability => {
        if (selected.length >= targetCount) return;
        const key = normalizeLabel(ability?.name);
        if (!key || taken.has(key)) return;
        selected.push(buildUpgradedAbility(ability, rarity || ability?.rarity));
        taken.add(key);
      });
      for (const ability of (rerolledAbilities || [])) {
        if (selected.length >= targetCount) break;
        selected.push(buildUpgradedAbility(ability, rarity || ability?.rarity));
      }
      return selected.slice(0, targetCount);
    }

    function takeRerolledStatsByProfile(rerolledStats = [], profileStats = [], fallbackColor = null) {
      if (!Array.isArray(profileStats) || !profileStats.length) return [];
      const selected = [];
      const taken = new Set();
      const pool = Array.isArray(rerolledStats) ? rerolledStats : [];
      profileStats.forEach(sourceStat => {
        const preferredColor = preferredModifierColor(sourceStat, "stat", fallbackColor);
        let candidate = pool.find(stat => {
          const key = getStatIdentityKey(stat);
          return key && !taken.has(key) && (!preferredColor || preferredModifierColor(stat, "stat", fallbackColor) === preferredColor);
        });
        if (!candidate) {
          candidate = pool.find(stat => {
            const key = getStatIdentityKey(stat);
            return key && !taken.has(key);
          });
        }
        if (!candidate) return;
        const next = cloneJson(candidate);
        if (preferredColor) next.source_color = preferredColor;
        selected.push(next);
        taken.add(getStatIdentityKey(candidate));
      });
      return selected;
    }

    function takeRerolledAbilitiesByProfile(rerolledAbilities = [], profileAbilities = [], rarity = null, fallbackColor = null) {
      if (!Array.isArray(profileAbilities) || !profileAbilities.length) return [];
      const selected = [];
      const taken = new Set();
      const pool = Array.isArray(rerolledAbilities) ? rerolledAbilities : [];
      profileAbilities.forEach(sourceAbility => {
        const preferredColor = preferredModifierColor(sourceAbility, "ability", fallbackColor);
        let candidate = pool.find(ability => {
          const key = normalizeLabel(ability?.name);
          return key && !taken.has(key) && (!preferredColor || preferredModifierColor(ability, "ability", fallbackColor) === preferredColor);
        });
        if (!candidate) {
          candidate = pool.find(ability => {
            const key = normalizeLabel(ability?.name);
            return key && !taken.has(key);
          });
        }
        if (!candidate) return;
        const next = buildUpgradedAbility(candidate, rarity || candidate?.rarity);
        if (preferredColor) next.source_color = preferredColor;
        selected.push(next);
        taken.add(normalizeLabel(candidate?.name));
      });
      return selected;
    }

    function dedupeStatsByIdentity(stats = []) {
      const output = [];
      const seen = new Set();
      (stats || []).forEach(stat => {
        const key = getStatIdentityKey(stat);
        if (!key || seen.has(key)) return;
        output.push(stat);
        seen.add(key);
      });
      return output;
    }

    function dedupeAbilitiesByName(abilities = []) {
      const output = [];
      const seen = new Set();
      (abilities || []).forEach(ability => {
        const key = normalizeLabel(ability?.name);
        if (!key || seen.has(key)) return;
        output.push(ability);
        seen.add(key);
      });
      return output;
    }

    function isCondensedModifier(modifier) {
      return modifier?.modifier_origin === "condensed";
    }

    function splitModifiersByOrigin(modifiers = []) {
      const base = [];
      const condensed = [];
      (modifiers || []).forEach(modifier => {
        if (isCondensedModifier(modifier)) {
          condensed.push(modifier);
        } else {
          base.push(modifier);
        }
      });
      return { base, condensed };
    }

    function buildUpgradedAbility(baseAbility, rarity) {
      const resolved = resolveAbilityDetails(baseAbility);
      if (typeof resolved === "string") {
        return {
          name: resolved,
          type: "Active",
          rarity,
          tierDetails: { Detail: "No tier details available." }
        };
      }
      const canonical = abilityDetailMap.get(resolved.name) || resolved;
      const tierLimit = getAbilityTierLimit(canonical.name, rarity);
      const filteredTierDetails = {};
      Object.entries(canonical.tierDetails || {}).forEach(([tier, detail]) => {
        const tierNum = getTierNumberFromLabel(tier);
        if (tierLimit === null || tierNum === null || tierNum <= tierLimit) {
          filteredTierDetails[tier] = detail;
        }
      });
      return {
        ...canonical,
        ...resolved,
        type: baseAbility?.type || "Active",
        rarity,
        tierDetails: Object.keys(filteredTierDetails).length ? filteredTierDetails : (canonical.tierDetails || resolved.tierDetails || { Detail: "No tier details available." })
      };
    }

    function canGearCondense(gear) {
      if (!gear || typeof gear !== "object") return false;
      const gearType = gear.gear_type || gear.gearType;
      return !["Kernel", "Bauble", "Consumable"].includes(gearType);
    }

    function canGearUseAestheticModification(gear) {
      return Boolean(gear && typeof gear === "object" && gear.aesthetic);
    }

    async function generateRerolledGear(baseGear, luck, rarityOverride = null) {
      if (!pyodideClient) {
        await ensurePyodideReady();
      }
      if (!pyodideClient) return null;
      const gearTypeNumber = gearTypeToNumber[baseGear.gear_type || baseGear.gearType] || 0;
      const rarity = rarityOverride || baseGear.rarity || "Common";
      const color = baseGear.color || "Neutral";
      const color2 = baseGear.color2 || null;
      const result = pyodideClient.runPython(
        `generate_gear_json(${Math.max(1, Math.round(luck))}, 1, ${gearTypeNumber}, ${toPythonLiteral(rarity)}, ${toPythonLiteral(color)}, ${toPythonLiteral(color2)})`
      );
      const parsed = JSON.parse(result || "[]");
      return parsed[0] || null;
    }


    function getGearLuckContribution(gear, baseLuck) {
      let total = 0;
      (gear?.stats || []).forEach(stat => {
        const statName = normalizeLabel(stat?.label || stat?.name || stat?.stat);
        if (statName !== "luck") return;
        const value = stat?.value ?? stat?.calc ?? calculateFormulaValue(stat?.formula, baseLuck, "Luck");
        if (Number.isFinite(value)) total += Number(value);
      });
      (gear?.stat_modifiers || []).forEach(stat => {
        const statName = normalizeLabel(stat?.label || stat?.name || stat?.stat);
        if (statName !== "luck") return;
        const value = stat?.value ?? stat?.calc ?? calculateFormulaValue(stat?.formula, baseLuck, "Luck");
        if (Number.isFinite(value)) total += Number(value);
      });
      return total;
    }


    function preserveHigherExistingStatValues(previousStats, recalculatedStats) {
      if (!Array.isArray(recalculatedStats) || !Array.isArray(previousStats)) return recalculatedStats;
      return recalculatedStats.map((stat, index) => {
        const previous = previousStats[index];
        if (!previous || typeof stat !== "object" || stat == null) return stat;
        const nextValue = Number(stat?.value ?? stat?.calc);
        const oldValue = Number(previous?.value ?? previous?.calc);
        if (!Number.isFinite(nextValue) || !Number.isFinite(oldValue)) return stat;
        if (nextValue >= oldValue) return stat;
        return { ...stat, value: oldValue };
      });
    }

    async function applyGearModification(choice) {
      const targetId = document.getElementById("gearModificationTarget")?.value || selectedGearModificationTargetId;
      const entry = findGearEntry(targetId);
      if (!entry) return;
      const liveStats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const baseStats = currentStats();
      const targetLuck = getGearLuckContribution(entry.gear, baseStats.luck || 0);
      const modificationLuck = Math.max(1, (liveStats.luck || 1) - targetLuck);
      const luckNow = getCappedLuckValue(modificationLuck, liveStats.level);
      const base = cloneJson(entry.gear);
      let updated = cloneJson(entry.gear);
      let cost = 0;
      let donorSnapshot = null;
      let secondTargetSnapshot = null;
      const freeChoice = activeCharacter?.base_stats?.free_gear_mod || null;
      const freeMaxRarity = activeCharacter?.base_stats?.free_gear_mod_max_rarity || "Common";
      let consumedFreeMod = false;

      if (choice === "upgrading") {
        const row = gearUpgradeCosts[updated.rarity];
        if (!row) {
          pushStatus("That rarity cannot be upgraded further.", { tone: "warning" });
          return;
        }
        cost = applyGearModDiscount(row.cost);
        const rerolled = await generateRerolledGear(base, luckNow, row.next);
        updated.rarity = row.next;
        updated.stats = Array.isArray(base.stats) ? cloneJson(base.stats) : [];
        updated.stat_modifiers = Array.isArray(base.stat_modifiers) ? cloneJson(base.stat_modifiers) : [];
        updated.abilities = Array.isArray(base.abilities) ? cloneJson(base.abilities) : [];

        const rarityCaps = gearMaxes[row.next] || gearMaxes.Common;
        const rarityBaseCaps = rarityBaseModifierCaps[row.next] || rarityBaseModifierCaps.Common;
        const isBauble = (updated.gear_type || updated.gearType) === "Bauble";
        const targetStatsKey = isBauble ? "stat_modifiers" : "stats";
        const baseStatTargetCount = rarityBaseCaps.basicStats + rarityBaseCaps.colorStats;
        const baseActiveTargetCount = rarityBaseCaps.actives;
        const rerollStats = isBauble ? (rerolled?.stat_modifiers || []) : (rerolled?.stats || []);
        const statSplit = splitModifiersByOrigin(updated[targetStatsKey]);
        const abilitySplit = splitModifiersByOrigin(updated.abilities);
        const currentStatNames = statSplit.base.map(stat => stat.label || stat.name);

        if (statSplit.base.length < baseStatTargetCount) {
          const candidateStats = isBauble
            ? rerollStats
            : (() => {
                const colorMatched = rerollStats.filter(stat => isColorCompatibleStat(stat, base.color));
                return colorMatched.length ? colorMatched : rerollStats;
              })();
          const statToAdd = pickUniqueStat(candidateStats, currentStatNames);
          if (statToAdd) {
            statSplit.base.push(cloneJson(statToAdd));
          }
        }
        const rerolledBaseStats = takeRerolledStats(statSplit.base, baseStatTargetCount);
        updated[targetStatsKey] = [...rerolledBaseStats, ...statSplit.condensed].slice(0, rarityCaps.statBuffMax);

        const gValue = updated.color ? (getEquippedColorCounts()[updated.color] || 0) : 0;
        updated = recalculateGearStatsForRarity(updated, row.next, luckNow, { g: gValue });
        updated.stats = preserveHigherExistingStatValues(base.stats, updated.stats);
        updated.stat_modifiers = preserveHigherExistingStatValues(base.stat_modifiers, updated.stat_modifiers);

        const upgradedBaseAbilities = abilitySplit.base.map(ability => buildUpgradedAbility(ability, row.next));
        if (upgradedBaseAbilities.length < baseActiveTargetCount) {
          const existingNames = new Set(upgradedBaseAbilities.map(ability => normalizeLabel(ability?.name)));
          const nextAbility = (rerolled?.abilities || []).find(ability => !existingNames.has(normalizeLabel(ability?.name)));
          if (nextAbility) {
            upgradedBaseAbilities.push(buildUpgradedAbility(nextAbility, row.next));
          }
        }
        const condensedAbilities = abilitySplit.condensed.map(ability => buildUpgradedAbility(ability, row.next));
        updated.abilities = [...upgradedBaseAbilities.slice(0, baseActiveTargetCount), ...condensedAbilities].slice(0, rarityCaps.activePassiveMax);
      } else if (choice === "rerolling") {
        cost = applyGearModDiscount(gearRerollCosts[updated.rarity] || 0);
        const rerollPool = { stats: [], stat_modifiers: [], abilities: [] };
        for (let attempt = 0; attempt < 6; attempt += 1) {
          const rerolled = await generateRerolledGear(base, luckNow, base.rarity);
          rerollPool.stats.push(...(rerolled?.stats || []));
          rerollPool.stat_modifiers.push(...(rerolled?.stat_modifiers || []));
          rerollPool.abilities.push(...(rerolled?.abilities || []));
        }

        updated.stats = takeRerolledStatsByProfile(rerollPool.stats, Array.isArray(base.stats) ? base.stats : [], base.color);
        updated.stat_modifiers = takeRerolledStatsByProfile(rerollPool.stat_modifiers, Array.isArray(base.stat_modifiers) ? base.stat_modifiers : [], base.color);
        updated.abilities = takeRerolledAbilitiesByProfile(rerollPool.abilities, Array.isArray(base.abilities) ? base.abilities : [], base.rarity, base.color);

        if (updated.stats.length < (base.stats || []).length) {
          updated.stats = [...updated.stats, ...cloneJson((base.stats || []).slice(updated.stats.length))];
        }
        if (updated.stat_modifiers.length < (base.stat_modifiers || []).length) {
          updated.stat_modifiers = [...updated.stat_modifiers, ...cloneJson((base.stat_modifiers || []).slice(updated.stat_modifiers.length))];
        }
        if (updated.abilities.length < (base.abilities || []).length) {
          updated.abilities = [...updated.abilities, ...cloneJson((base.abilities || []).slice(updated.abilities.length))];
        }

        const gValue = updated.color ? (getEquippedColorCounts()[updated.color] || 0) : 0;
        updated = recalculateGearStatsForRarity(updated, base.rarity, luckNow, { g: gValue });
        updated.stats = preserveHigherExistingStatValues(base.stats, updated.stats);
        updated.stat_modifiers = preserveHigherExistingStatValues(base.stat_modifiers, updated.stat_modifiers);
      } else if (choice === "condensing") {
        const donorId = document.getElementById("gearCondenseDonor")?.value;
        const transferType = document.getElementById("gearCondenseTransferType")?.value || "stat";
        const moveCount = Math.max(1, Number(document.getElementById("gearCondenseCount")?.value || 1));
        const selectedModifierIndexes = Array.from(document.getElementById("gearCondenseModifier")?.selectedOptions || [])
          .map(option => Number(option.value))
          .filter(value => Number.isFinite(value));
        const donorEntry = findGearEntry(donorId);
        if (!donorEntry) {
          pushStatus("Choose source gear to condense into the target gear.", { tone: "warning" });
          return;
        }
        if (!canGearCondense(updated) || !canGearCondense(donorEntry.gear)) {
          pushStatus("Only non-Kernel/Bauble/Consumable gear can use Condense Into.", { tone: "warning" });
          return;
        }
        if (selectedModifierIndexes.length !== moveCount) {
          pushStatus(`Select exactly ${moveCount} donor modifier${moveCount === 1 ? "" : "s"} to transfer.`, { tone: "warning" });
          return;
        }
        const costList = gearCondenseCosts[updated.rarity] || [];
        cost = applyGearModDiscount(costList[moveCount - 1] || costList[0] || 0);
        const maxCaps = gearMaxes[updated.rarity] || gearMaxes.Common;
        const donorStats = Array.isArray(donorEntry.gear.stats) ? donorEntry.gear.stats : [];
        const donorStatModifiers = Array.isArray(donorEntry.gear.stat_modifiers) ? donorEntry.gear.stat_modifiers : [];
        const donorAbilities = Array.isArray(donorEntry.gear.abilities) ? donorEntry.gear.abilities : [];
        updated.stats = Array.isArray(updated.stats) ? updated.stats : [];
        updated.stat_modifiers = Array.isArray(updated.stat_modifiers) ? updated.stat_modifiers : [];
        updated.abilities = Array.isArray(updated.abilities) ? updated.abilities : [];
        const isBauble = (updated.gear_type || updated.gearType) === "Bauble";
        const targetStatKey = isBauble ? "stat_modifiers" : "stats";
        const donorStatPool = donorStats.length ? donorStats : donorStatModifiers;
        const remainingStatSlots = Math.max(0, maxCaps.statBuffMax - updated[targetStatKey].length);
        const remainingAbilitySlots = Math.max(0, maxCaps.activePassiveMax - updated.abilities.length);

        const pickedIndexes = selectedModifierIndexes.slice(0, moveCount);
        if (transferType === "ability") {
          if (remainingAbilitySlots <= 0) {
            pushStatus("This gear is already at the maximum number of abilities for its rarity.", { tone: "warning" });
            return;
          }
          const pickedAbilities = pickedIndexes
            .map(idx => donorAbilities[idx])
            .filter(Boolean)
            .slice(0, remainingAbilitySlots);
          if (!pickedAbilities.length) {
            pushStatus("Selected donor abilities were not found.", { tone: "warning" });
            return;
          }
          const abilityPayload = pickedAbilities.map(ability => {
            const next = cloneJson(ability);
            next.source_color = preferredModifierColor(ability, "ability", donorEntry.gear.color);
            next.modifier_origin = "condensed";
            return next;
          });
          updated.abilities.push(...abilityPayload);
        } else {
          if (remainingStatSlots <= 0) {
            pushStatus("This gear is already at the maximum number of stat buffs for its rarity.", { tone: "warning" });
            return;
          }
          const pickedStats = pickedIndexes
            .map(idx => donorStatPool[idx])
            .filter(Boolean)
            .slice(0, remainingStatSlots);
          if (!pickedStats.length) {
            pushStatus("Selected donor stats were not found.", { tone: "warning" });
            return;
          }
          const statPayload = pickedStats.map(stat => {
            const next = cloneJson(stat);
            next.source_color = preferredModifierColor(stat, "stat", donorEntry.gear.color);
            next.modifier_origin = "condensed";
            return next;
          });
          updated[targetStatKey].push(...statPayload);
        }

        updated.abilities = updated.abilities.map(ability => buildUpgradedAbility(ability, updated.rarity));

        donorSnapshot = {
          gear: cloneJson(donorEntry.gear),
          gear_id: donorEntry.gear_id,
          gear_slot: donorEntry.gear_slot
        };
        const { error: donorLinkError } = await sb.from("webrunning_character_gear").delete().eq("character_id", activeCharacter.id).eq("gear_id", donorEntry.gear_id);
        if (donorLinkError) throw donorLinkError;
        const { error: donorGearError } = await sb.from("webrunning_gear").delete().eq("id", donorEntry.gear_id);
        if (donorGearError) throw donorGearError;
        characterGear = characterGear.filter(item => item.gear_id !== donorEntry.gear_id);
      } else if (choice === "aesthetic") {
        if (!canGearUseAestheticModification(updated)) {
          pushStatus("This gear has no aesthetic, so it cannot be used for aesthetic modification or swap.", { tone: "warning" });
          return;
        }
        const mode = document.getElementById("gearAestheticMode")?.value || "modify";
        if (mode === "swap") {
          const otherId = document.getElementById("gearAestheticSwapTarget")?.value;
          const otherEntry = findGearEntry(otherId);
          if (!otherEntry) {
            pushStatus("Choose another gear piece for aesthetic swap.", { tone: "warning" });
            return;
          }
          if (!canGearUseAestheticModification(otherEntry.gear)) {
            pushStatus("Swap target must already have an aesthetic.", { tone: "warning" });
            return;
          }
          cost = applyGearModDiscount(100);
          const otherBase = cloneJson(otherEntry.gear);
          const thisAesthetic = updated.aesthetic || null;
          updated.aesthetic = otherBase.aesthetic || null;
          const otherUpdated = { ...otherBase, aesthetic: thisAesthetic };
          const persistedOther = await updateGearRecord(otherEntry.gear_id, buildGearInsertPayload(otherUpdated));
          otherEntry.gear = persistedOther;
          secondTargetSnapshot = { gear_id: otherEntry.gear_id, before: otherBase, after: cloneJson(otherUpdated) };
        } else {
          cost = applyGearModDiscount(300);
          const value = (document.getElementById("gearAestheticPreset")?.value || "").trim();
          if (!value) {
            pushStatus("Choose an aesthetic preset.", { tone: "warning" });
            return;
          }
          updated.aesthetic = value;
        }
      }

      updated.stats = dedupeStatsByIdentity(updated.stats || []);
      updated.stat_modifiers = dedupeStatsByIdentity(updated.stat_modifiers || []);
      updated.abilities = dedupeAbilitiesByName(updated.abilities || []);
      updated = enforceRarityCaps(updated);

      if (freeChoice && freeChoice === choice && getRarityRank(updated.rarity || "Common") <= getRarityRank(freeMaxRarity)) {
        consumedFreeMod = true;
        cost = 0;
      }

      if (cost > (activeCharacter.base_stats?.essence || 0)) {
        pushStatus(`Not enough essence for that modification. Need ${cost}, you have ${activeCharacter.base_stats?.essence || 0}.`, { tone: "warning" });
        return;
      }

      try {
        if (!currentUser?.id) {
          currentUser = await requireUser();
        }
        await updateEssenceBy(-cost);
        if (consumedFreeMod) {
          delete activeCharacter.base_stats.free_gear_mod;
          delete activeCharacter.base_stats.free_gear_mod_max_rarity;
          const { error: freeError } = await sb.from("webrunning_characters").update({ base_stats: activeCharacter.base_stats }).eq("id", activeCharacter.id).eq("user_id", currentUser.id);
          if (freeError) throw freeError;
        }
        const persistedGear = await updateGearRecord(entry.gear_id, buildGearInsertPayload(updated));
        entry.gear = persistedGear;
        if (gearModificationSource === "detail") {
          openGearDetailModal(entry);
        }

        const details = summarizeGearModificationResult(choice, base, updated, { donorSnapshot, secondTargetSnapshot });
        const historyRecord = await addGearHistoryRecord({
          type: "modify",
          label: `${choice[0].toUpperCase()}${choice.slice(1)}: ${formatGearName(updated)}`,
          entry: { gear_id: entry.gear_id, gear_slot: entry.gear_slot, equipped: entry.equipped, gear: cloneJson(updated) },
          details,
          modification: {
            choice,
            cost,
            before: base,
            after: cloneJson(updated),
            donorSnapshot,
            secondTargetSnapshot,
            consumedFreeMod
          }
        });

        pendingModificationRecord = historyRecord;
        render();
        renderGearModificationResult(historyRecord);
        pushStatus(`Modification applied. Spent ${cost} essence.${consumedFreeMod ? " (Used free consumable mod.)" : ""}`, { tone: "success" });
      } catch (error) {
        console.error(error);
        pushStatus("Failed to apply gear modification.", { tone: "error" });
      }
    }

    function getKernelSlots(stats) {
      const count = Math.max(Number(stats.kernel_slots) || 0, 0);
      return Array.from({ length: Math.min(count, 5) }, (_, i) => `kernel_${i + 1}`);
    }

    function getEquippedSlotList(stats) {
      return [
        "weapon_1",
        "weapon_2",
        "head",
        "torso",
        "hands",
        "legs",
        "feet",
        "ring_1",
        "ring_2",
        "neck",
        ...getKernelSlots(stats)
      ];
    }

    function formatSlotLabel(slot) {
      return gearSlotLabels[slot] || slot;
    }

    function formatSignedValue(value) {
      const rounded = Number.isFinite(value) ? value : 0;
      return `${rounded >= 0 ? "+" : ""}${rounded}`;
    }

    function summarizeSources(sourceList = []) {
      if (!sourceList.length) return "";
      const totals = sourceList.reduce((acc, item) => {
        if (!item || !item.label || !item.value) return acc;
        acc[item.label] = (acc[item.label] || 0) + item.value;
        return acc;
      }, {});
      const parts = Object.entries(totals)
        .filter(([, value]) => value)
        .map(([label, value]) => `${formatSignedValue(value)} ${label}`);
      return parts.length ? parts.join(", ") : "";
    }

    function summarizeAdventuringPluses(list = []) {
      if (!list.length) return [];
      const totals = list.reduce((acc, item) => {
        if (!item || !item.name || !item.value) return acc;
        acc[item.name] = (acc[item.name] || 0) + item.value;
        return acc;
      }, {});
      return Object.entries(totals)
        .filter(([, value]) => value)
        .map(([name, value]) => ({ name, value }));
    }

    function scaleSourceList(list = [], factor = 1) {
      return list.map(item => ({
        label: item.label,
        value: item.value * factor
      }));
    }

    function combineSourceLists(...lists) {
      return lists.flat().filter(Boolean);
    }

    function getLevelLimits(level) {
      return statLimitTable[level] || statLimitTable[10];
    }

    function applyDisplayLimit(value, limit) {
      if (!Number.isFinite(limit)) {
        return { displayValue: value, limit: null };
      }
      return { displayValue: Math.min(value, limit), limit };
    }

    function sumSourceValues(sourceList = []) {
      return sourceList.reduce((total, item) => {
        if (!item || !Number.isFinite(item.value)) return total;
        return total + item.value;
      }, 0);
    }

    function setStatDisplay(element, value, summary, options = {}) {
      if (!element) return;
      const displayValue = options.displayValue ?? value;
      const limit = Number.isFinite(options.limit) ? options.limit : null;
      const limitLabel = options.limitLabel || "Limit";
      const rawValue = options.rawValue;
      const showRawValue = options.showRawValue && Number.isFinite(rawValue);


      element.textContent = "";
      const valueRow = document.createElement("span");
      valueRow.className = "stat-value-row";

      const valueGroup = document.createElement("span");
      valueGroup.className = "stat-main-group";

      const valueSpan = document.createElement("span");
      valueSpan.className = "stat-main-value";
      valueSpan.textContent = String(displayValue);
      valueGroup.appendChild(valueSpan);

      if (summary) {
        const summarySpan = document.createElement("span");
        summarySpan.className = "muted stat-summary";
        summarySpan.textContent = `(${summary})`;
        valueGroup.appendChild(summarySpan);
      }

      valueRow.appendChild(valueGroup);

      if (limit !== null) {
        const limitSpan = document.createElement("span");
        limitSpan.className = "stat-limit-value muted";
        const limitDetails = [`${limitLabel} ${limit}`];
        if (showRawValue) {
          limitDetails.push(`(${rawValue})`);
        }
        limitSpan.textContent = limitDetails.join(" • ");
        if (displayValue !== value) {
          limitSpan.title = `Limited from ${value}`;
        }
        valueRow.appendChild(limitSpan);
      }

      element.appendChild(valueRow);

      const details = [];
      if (details.length) {
        const detailsSpan = document.createElement("span");
        detailsSpan.className = "muted stat-summary";
        detailsSpan.textContent = `(${details.join(" • ")})`;
        element.appendChild(detailsSpan);
      }
    }

    function formatGearName(gear) {
      if (!gear) return "Unknown Gear";
      if (gear.name && gear.name.trim()) return gear.name.trim();
      const typeLabel = gear.item_type || gear.itemType || gear.gear_type || gear.gearType || "Gear";
      const rawAesthetic = String(gear.aesthetic || "").trim();
      if (!rawAesthetic) return `${typeLabel}`.trim();
      const parenMatch = rawAesthetic.match(/^([^()]+?)\s*\(([^)]+)\)$/);
      if (parenMatch) {
        const base = parenMatch[1].trim();
        const detail = parenMatch[2].trim();
        return `${base} ${typeLabel} (${detail})`.trim();
      }
      return `${rawAesthetic} ${typeLabel}`.trim();
    }

    function enforceRarityCaps(gear) {
      if (!gear) return gear;
      const rarity = gear.rarity || "Common";
      const caps = gearMaxes[rarity] || gearMaxes.Common;
      const stats = Array.isArray(gear.stats) ? gear.stats : [];
      const abilities = Array.isArray(gear.abilities) ? gear.abilities : [];
      return {
        ...gear,
        stats: cloneJson(stats.slice(0, caps.statBuffMax)),
        abilities: cloneJson(abilities.slice(0, caps.activePassiveMax))
      };
    }

    const gearTagPalette = {
      type: {
        "One-Handed Weapon": "#94a3b8",
        "Two-Handed Weapon": "#94a3b8",
        "Head": "#94a3b8",
        "Torso": "#94a3b8",
        "Hands": "#94a3b8",
        "Legs": "#94a3b8",
        "Feet": "#94a3b8",
        "Ring": "#94a3b8",
        "Neck": "#94a3b8",
        "Kernel": "#94a3b8",
        "Consumable": "#94a3b8",
        "Bauble": "#94a3b8"
      },
      rarity: {
        "Basic": "#cbd5f5",
        "Common": "#94a3b8",
        "Uncommon": "#22c55e",
        "Rare": "#38bdf8",
        "Epic": "#a855f7",
        "Legendary": "#f59e0b"
      },
      color: {
        "Neutral": "#cbd5f5",
        "Red": "#f87171",
        "Blue": "#60a5fa",
        "Green": "#4ade80",
        "Gray": "#9aa3b2"
      }
    };

    function hexToRgba(hex, alpha) {
      const normalized = hex.replace("#", "");
      const bigint = parseInt(normalized, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function renderGearTag(label, group, options = {}) {
      const palette = gearTagPalette[group] || {};
      const primaryKey = options.primary || label;
      const primary = palette[primaryKey] || "#94a3b8";
      const secondaryKey = options.secondary;
      const secondary = secondaryKey ? (palette[secondaryKey] || primary) : null;
      const bg = hexToRgba(primary, 0.22);
      const style = [
        `--tag-color: ${primary}`,
        `--tag-bg: ${bg}`,
        secondary ? `--tag-color-secondary: ${secondary}` : ""
      ]
        .filter(Boolean)
        .join("; ");
      const className = `gear-tag gear-tag--${group}${secondary ? " dual" : ""}`;
      return `<span class="${className}" style="${style}">${label}</span>`;
    }

    function normalizeLabel(value) {
      return String(value || "").trim().toLowerCase();
    }

    function getGearTypeLabel(gear) {
      return gear?.gear_type || gear?.gearType || "";
    }

    function gearHasStat(gear, targetStat) {
      if (!targetStat) return true;
      const target = normalizeLabel(targetStat);
      const allStats = [...(gear.stats || []), ...(gear.stat_modifiers || [])];
      return allStats.some(stat => normalizeLabel(stat.label || stat.name) === target);
    }

    function matchesGearFilters(gear, stats, filters = {}) {
      if (!gear) return false;
      const filterRarity = filters.rarity || "";
      const filterType = filters.type || "";
      const filterColor = filters.color || "";
      const filterStat = filters.stat || "";
      const filterFreeSlot = filters.freeSlot || "";
      const gearType = getGearTypeLabel(gear);
      const gearColor = gear.color || "Neutral";
      if (filterRarity && gear.rarity !== filterRarity) return false;
      if (filterType && gearType !== filterType) return false;
      if (filterColor && gearColor !== filterColor) return false;
      if (filterStat && !gearHasStat(gear, filterStat)) return false;
      if (filterFreeSlot) {
        const resolvedStats = stats || applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
        const hasFreeSlot = availableSlotsForGear(gear, resolvedStats).length > 0;
        if (filterFreeSlot === "has" && !hasFreeSlot) return false;
        if (filterFreeSlot === "none" && hasFreeSlot) return false;
      }
      return true;
    }

    function getInventoryFilterState() {
      return {
        rarity: gearFilterRarity?.value || "",
        type: gearFilterType?.value || "",
        color: gearFilterColor?.value || "",
        stat: gearFilterStat?.value || "",
        freeSlot: gearFilterFreeSlot?.value || ""
      };
    }

    function getLocalNodeFilterState() {
      return {
        rarity: localGearFilterRarity?.value || "",
        type: localGearFilterType?.value || "",
        color: localGearFilterColor?.value || "",
        stat: localGearFilterStat?.value || "",
        freeSlot: localGearFilterFreeSlot?.value || ""
      };
    }

    function sortGearEntries(entries) {
      const sortField = gearSortField?.value || "rarity";
      const direction = gearSortDirection?.value === "desc" ? -1 : 1;
      const rarityIndex = entry => raritySortOrder.indexOf(entry.gear.rarity);
      const typeIndex = entry => gearTypeSortOrder.indexOf(getGearTypeLabel(entry.gear));
      const colorIndex = entry => colorSortOrder.indexOf(entry.gear.color || "Neutral");

      return [...entries].sort((a, b) => {
        let aKey = "";
        let bKey = "";
        if (sortField === "rarity") {
          aKey = rarityIndex(a);
          bKey = rarityIndex(b);
        } else if (sortField === "type") {
          aKey = typeIndex(a);
          bKey = typeIndex(b);
        } else if (sortField === "color") {
          aKey = colorIndex(a);
          bKey = colorIndex(b);
        } else {
          aKey = formatGearName(a.gear);
          bKey = formatGearName(b.gear);
        }

        if (aKey === bKey) {
          return formatGearName(a.gear).localeCompare(formatGearName(b.gear)) * direction;
        }
        if (typeof aKey === "number" && typeof bKey === "number") {
          const normalizedA = aKey === -1 ? Number.MAX_SAFE_INTEGER : aKey;
          const normalizedB = bKey === -1 ? Number.MAX_SAFE_INTEGER : bKey;
          return normalizedA > normalizedB ? direction : -direction;
        }
        return String(aKey).localeCompare(String(bKey)) * direction;
      });
    }

    function availableSlotsForGear(gear, stats) {
      const gearType = gear?.gear_type || gear?.gearType;
      if (!gear || gearType === "Bauble") return [];
      const slots = gearTypeToSlots[gearType] || [];
      const kernelSlots = getKernelSlots(stats);
      const filteredSlots = slots.filter(slot => slot.startsWith("kernel_") ? kernelSlots.includes(slot) : true);
      return filteredSlots.filter(slot => !characterGear.some(entry => entry.equipped && entry.gear_slot === slot));
    }

    function getSwapOptionsForGear(gear, stats) {
      const gearType = gear?.gear_type || gear?.gearType;
      if (!gear || gearType === "Bauble") return [];
      const slots = gearTypeToSlots[gearType] || [];
      const kernelSlots = getKernelSlots(stats);
      const filteredSlots = slots.filter(slot => slot.startsWith("kernel_") ? kernelSlots.includes(slot) : true);
      return filteredSlots
        .map(slot => {
          const entry = characterGear.find(item => item.equipped && item.gear_slot === slot);
          return entry ? { slot, entry } : null;
        })
        .filter(Boolean);
    }

    function selectSwapSlot(options) {
      return options.length ? options[0] : null;
    }

    function renderGearStatsList(stats, statModifiers, luck, context = {}) {
      const rows = [];
      (stats || []).forEach(stat => {
        const statName = stat.label || stat.name;
        if (!statName) return;
        rows.push(`<li class="gear-stat gear-stat--base">${statName}: ${stat.value ?? "?"} <span class="muted">(${stat.formula || "?"})</span></li>`);
      });
      (statModifiers || []).forEach(stat => {
        const statName = stat.label || stat.name;
        if (!statName) return;
        const value = stat.value ?? stat.calc ?? calculateFormulaValue(stat.formula, luck, stat.name || statName, context);
        rows.push(`<li class="gear-stat gear-stat--bonus">${statName}: ${value} <span class="muted">(${stat.formula || "?"})</span></li>`);
      });
      return rows.length ? `<ul>${rows.join("")}</ul>` : `<p class="muted">No stat changes.</p>`;
    }

    function buildGearStatSummary(gear, luck, context = {}) {
      const parts = [];
      (gear.stats || []).forEach(stat => {
        const statName = stat.label || stat.name;
        if (!statName) return;
        const value = stat.value ?? stat.calc;
        if (typeof value !== "number" || value === 0) return;
        parts.push(`${formatSignedValue(value)} ${statName}`);
      });
      (gear.stat_modifiers || []).forEach(stat => {
        const statName = stat.label || stat.name;
        if (!statName) return;
        const value = stat.value ?? stat.calc ?? calculateFormulaValue(stat.formula, luck, stat.name || statName, context);
        if (typeof value !== "number" || value === 0) return;
        parts.push(`${formatSignedValue(value)} ${statName}`);
      });
      return parts.length ? parts.join(", ") : "No stat modifiers";
    }

    function formatTierLabel(tier) {
      const tierText = String(tier || "").trim();
      if (!tierText) return "Tier";
      return /tier/i.test(tierText) ? tierText : `Tier ${tierText}`;
    }

    const abilityTierLimits = {
      Common: 0,
      Uncommon: 1,
      Rare: 2,
      Epic: 3,
      Legendary: Number.POSITIVE_INFINITY
    };

    function getTierNumberFromLabel(label) {
      const normalized = String(label || "").trim();
      if (!normalized) return null;
      const numericMatch = normalized.match(/(\d+)/);
      if (numericMatch) {
        return Number(numericMatch[1]);
      }
      const lower = normalized.toLowerCase();
      const rarityTierMap = {
        common: 1,
        uncommon: 2,
        rare: 3,
        epic: 4,
        legendary: 5
      };
      if (lower in rarityTierMap) {
        return rarityTierMap[lower];
      }
      const romanMatch = lower.match(/tier\s*([ivx]+)/);
      if (!romanMatch) return null;
      const roman = romanMatch[1];
      const romanValues = { i: 1, v: 5, x: 10 };
      let total = 0;
      let prevValue = 0;
      for (let i = roman.length - 1; i >= 0; i -= 1) {
        const value = romanValues[roman[i]] || 0;
        if (value < prevValue) {
          total -= value;
        } else {
          total += value;
          prevValue = value;
        }
      }
      return total || null;
    }

    function getAbilityTierLimit(abilityName, rarity) {
      if (!rarity) return null;
      return abilityTierLimits[rarity] ?? 0;
    }

    function sortTierEntries(tierEntries) {
      return [...tierEntries].sort(([leftTier], [rightTier]) => {
        const leftTierNumber = getTierNumberFromLabel(leftTier);
        const rightTierNumber = getTierNumberFromLabel(rightTier);
        if (leftTierNumber === null && rightTierNumber === null) {
          return String(leftTier).localeCompare(String(rightTier));
        }
        if (leftTierNumber === null) return 1;
        if (rightTierNumber === null) return -1;
        return leftTierNumber - rightTierNumber;
      });
    }

    function renderAbilityDetails(abilities, { showTierDetails = true, gearRarity = null } = {}) {
      if (!abilities || !abilities.length) {
        return `<p class="muted">No abilities.</p>`;
      }
      return abilities
        .map(ability => {
          const resolved = resolveAbilityDetails(ability);
          if (typeof resolved === "string") {
            return `
              <div>
                <strong>${resolved}</strong>
                ${showTierDetails ? `<div class="muted">No details.</div>` : ""}
              </div>
            `;
          }
          const tiers = resolved.tierDetails || {};
          const tierEntries = showTierDetails ? Object.entries(tiers) : [];
          const tierLimit = getAbilityTierLimit(resolved.name, gearRarity);
          const lines = parseAbilityLines(resolved).filter(Boolean);
          const filteredTierEntries = sortTierEntries(tierEntries.filter(([tier]) => {
            if (tierLimit === null) return true;
            const tierNumber = getTierNumberFromLabel(tier);
            return tierNumber === null || tierNumber <= tierLimit;
          }));
          const tierList = filteredTierEntries.length
            ? `<ul>${filteredTierEntries.map(([tier, detail]) => (
              `<li class="ability-tier"><strong>${formatTierLabel(tier)}:</strong> ${detail}</li>`
            )).join("")}</ul>`
            : (lines.length
              ? `<ul>${lines.map(line => `<li>${line}</li>`).join("")}</ul>`
              : `<p class="muted">No details.</p>`);
          return `
            <div>
              <strong><a href="${resolved.link}" target="_blank" rel="noopener">${resolved.name}</a></strong>
              ${tierList}
            </div>
          `;
        })
        .join("");
    }

    function extractTierNumbers(ability) {
      const resolved = resolveAbilityDetails(ability);
      if (!resolved || typeof resolved === "string") return [];
      const tiers = new Set();
      const details = resolved.tierDetails;
      if (details && typeof details === "object") {
        Object.keys(details).forEach(key => {
          const tierNumber = getTierNumberFromLabel(key);
          if (tierNumber !== null) {
            tiers.add(tierNumber);
          }
        });
      }
      parseAbilityLines(resolved).forEach(line => {
        const tierNumber = getTierNumberFromLabel(line);
        if (tierNumber !== null) {
          tiers.add(tierNumber);
        }
      });
      return [...tiers]
        .filter(value => Number.isFinite(value))
        .sort((a, b) => a - b);
    }

    function renderGearSections(stats) {
      renderEquippedSlots(stats);
      renderInventory(stats);
      renderLocalNode(stats);
    }

    function renderEquippedSlots(stats) {
      const container = elements.equippedSlots;
      container.innerHTML = "";
      const slots = getEquippedSlotList(stats);
      if (!slots.length) {
        container.innerHTML = `<span class="muted">No gear slots yet.</span>`;
        return;
      }
      slots.forEach(slot => {
        const entry = characterGear.find(item => item.equipped && item.gear_slot === slot);
        const card = document.createElement("div");
        card.className = "gear-item";
        if (!entry) {
          card.innerHTML = `
            <div class="gear-summary">
              <div class="gear-meta">
                <strong>${formatSlotLabel(slot)}</strong>
                <span class="muted">Empty</span>
              </div>
            </div>
          `;
        } else {
          card.classList.add("gear-item--equipped");
          const gear = entry.gear;
          const gearType = gear.gear_type || gear.gearType;
          const colorLabel = [gear.color, gear.color2].filter(Boolean).join(" / ") || "Neutral";
          const statSummary = buildGearStatSummary(gear, stats.luck);
          card.innerHTML = `
            <div class="gear-slot-badge">${formatSlotLabel(slot)}</div>
            <div class="gear-summary">
              <div class="gear-meta">
                <strong>${formatGearName(gear)}</strong>
                <div class="gear-tags">
                  ${renderGearTag(gearType, "type")}
                  ${renderGearTag(gear.rarity, "rarity")}
                  ${renderGearTag(colorLabel, "color", { primary: gear.color || "Neutral", secondary: gear.color2 })}
                </div>
              <span class="muted gear-stat-summary">Stats: ${statSummary}</span>
              ${isConsumable(gear) ? `<span class="muted">Consumable Summary: ${getConsumableSummary(gear)}</span>` : ""}
              </div>
              <div class="gear-actions">
                <button type="button" data-action="view" data-gear="${entry.gear_id}" aria-label="View details" title="View details"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="11" cy="11" r="6"></circle><path d="M16 16l5 5"></path></svg><span>Details</span></button>
                <button type="button" data-action="unequip" data-gear="${entry.gear_id}" aria-label="Unequip" title="Unequip"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 4v12"></path><path d="M8 12l4 4 4-4"></path><path d="M5 20h14"></path></svg><span>Unequip</span></button>
                <button type="button" data-action="dissolve" data-gear="${entry.gear_id}" aria-label="Dissolve" title="Dissolve"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M10 3h4"></path><path d="M11 3v6l-5 8a3 3 0 0 0 2.6 4h6.8A3 3 0 0 0 18 17l-5-8V3"></path><path d="M8 14h8"></path></svg><span>Dissolve</span></button>
                <button type="button" data-action="delete" data-gear="${entry.gear_id}" aria-label="Delete" title="Delete"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 7h16"></path><path d="M9 7V4h6v3"></path><path d="M7 7l1 13h8l1-13"></path><path d="M10 11v6M14 11v6"></path></svg><span>Delete</span></button>
              </div>
            </div>
          `;
        }
        container.appendChild(card);
      });
    }


    function isConsumable(gear) {
      const gearType = gear?.gear_type || gear?.gearType;
      return gearType === "Consumable";
    }

    function getConsumableType(gear) {
      return String(gear?.item_type || gear?.itemType || "").trim();
    }

    function getConsumableEffectText(gear) {
      if (!gear) return "";
      const abilities = Array.isArray(gear.abilities) ? gear.abilities : [];
      const lines = abilities
        .flatMap(ability => {
          if (!ability || typeof ability !== "object") return [];
          const details = ability.tierDetails;
          if (typeof details === "string") return [details];
          if (details && typeof details === "object") return Object.values(details).map(value => String(value || ""));
          return [];
        })
        .map(line => String(line || "").trim())
        .filter(Boolean);
      return lines[0] || "";
    }

    function getConsumableSummary(gear) {
      const type = getConsumableType(gear) || "Consumable";
      const effect = getConsumableEffectText(gear);
      if (!effect) return `${type}: Single-use consumable.`;
      return `${type}: ${effect}`;
    }

    function getRarityRank(rarity) {
      const order = ["Basic", "Common", "Uncommon", "Rare", "Epic", "Legendary"];
      const idx = order.indexOf(rarity);
      return idx === -1 ? 0 : idx;
    }

    function getGearModChoiceFromEffect(effect = "") {
      const text = String(effect || "").toLowerCase();
      if (text.includes("upgrade")) return "upgrading";
      if (text.includes("reroll")) return "rerolling";
      if (text.includes("condense")) return "condensing";
      if (text.includes("aesthetic")) return "aesthetic";
      return null;
    }

    async function openGearChangeModal(mode = "type", consumableRarity = "Common") {
      return new Promise(resolve => {
        if (!gearChangeModal || !gearChangeTarget || !gearChangeValue) {
          resolve(null);
          return;
        }
        const candidates = characterGear.filter(entry => {
          const type = entry.gear?.gear_type || entry.gear?.gearType;
          if (["Consumable", "Bauble", "Kernel"].includes(type)) return false;
          return getRarityRank(entry.gear?.rarity || "Common") <= getRarityRank(consumableRarity || "Common");
        });
        if (!candidates.length) {
          resolve(null);
          return;
        }
        const typeOptions = ["One-Handed Weapon","Two-Handed Weapon","Head","Torso","Hands","Legs","Feet","Ring","Neck"];
        const colorOptions = ["Neutral", "Red", "Blue", "Green", "Gray"];
        gearChangeHint.textContent = mode === "type"
          ? "Select a gear piece and its new type. Rarity and color stay the same."
          : "Select a gear piece and its new color. Rarity and type stay the same.";
        gearChangeTarget.innerHTML = candidates.map(entry => `<option value="${entry.gear_id}">${formatGearName(entry.gear)} [${entry.gear.rarity}]</option>`).join("");
        gearChangeValue.innerHTML = (mode === "type" ? typeOptions : colorOptions).map(value => `<option value="${value}">${value}</option>`).join("");
        gearChangeModalMsg.textContent = "";
        gearChangeModal.classList.remove("hidden");

        const cleanup = (value) => {
          gearChangeApplyBtn.removeEventListener("click", submit);
          gearChangeCancelBtn.removeEventListener("click", cancel);
          gearChangeModalBackdrop?.removeEventListener("click", cancel);
          gearChangeModal.classList.add("hidden");
          resolve(value);
        };
        const submit = () => cleanup({ gearId: gearChangeTarget.value, value: gearChangeValue.value, mode });
        const cancel = () => cleanup(null);
        gearChangeApplyBtn.addEventListener("click", submit);
        gearChangeCancelBtn.addEventListener("click", cancel);
        gearChangeModalBackdrop?.addEventListener("click", cancel);
      });
    }

    async function applyGearChangeConsumable(selection, consumableRarity) {
      if (!selection?.gearId || !selection?.value) return null;
      const entry = findGearEntry(selection.gearId);
      if (!entry) return null;
      if (getRarityRank(entry.gear?.rarity || "Common") > getRarityRank(consumableRarity || "Common")) {
        pushStatus("That gear is above this consumable's rarity limit.", { tone: "warning" });
        return null;
      }
      const liveStats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const rerolled = await generateRerolledGear({
        ...entry.gear,
        ...(selection.mode === "type" ? { gear_type: selection.value } : {}),
        ...(selection.mode === "color" ? { color: selection.value } : {})
      }, getCappedLuckValue(liveStats.luck || 1, liveStats.level), entry.gear.rarity || "Common");
      if (!rerolled) return null;
      const before = cloneJson(entry.gear);
      const updated = {
        ...entry.gear,
        ...(selection.mode === "type" ? { gear_type: selection.value } : { color: selection.value }),
        stats: cloneJson(rerolled.stats || []),
        stat_modifiers: cloneJson(rerolled.stat_modifiers || []),
        abilities: cloneJson(rerolled.abilities || [])
      };
      const persisted = await updateGearRecord(entry.gear_id, buildGearInsertPayload(updated));
      entry.gear = persisted;
      return { entry, before, after: cloneJson(persisted), selection };
    }

    function buildConsumableReminder(gear, stats = currentStats()) {
      const type = getConsumableType(gear);
      const effect = getConsumableEffectText(gear);
      if (type === "Healing") {
        const percent = Number((effect.match(/(\d+)%/i) || [])[1] || 0);
        const maxHp = Number(stats.max_hp) || Number(stats.hp) || 0;
        const currentHp = Number(stats.current_hp) || 0;
        const missing = Math.max(maxHp - currentHp, 0);
        const estimated = percent > 0 ? Math.ceil((maxHp * percent) / 100) : 0;
        return `Healing used (${effect || "custom effect"}). Missing HP: ${missing}. Estimated healing: ${estimated}.`;
      }
      if (type === "Energy") {
        const amount = Number((effect.match(/grants\s*(\d+)/i) || [])[1] || 0);
        return `Energy consumable used (${effect || "custom effect"}). Choose color and add ${amount || "the listed"} energy.`;
      }
      if (type === "Gear Mod") {
        return `Gear Mod consumable used: ${effect}. You get one free ${effect.toLowerCase()} action.`;
      }
      if (type === "Gear Type Change" || type === "Gear Color Change") {
        return `${type} consumable used (${effect}). Pick a gear piece and reroll all stats/abilities after the change.`;
      }
      return `${type || "Consumable"} used (${effect || "single-use effect"}). Apply any manual effects now.`;
    }

    function renderInventory(stats) {
      const container = elements.inventorySlots;
      container.innerHTML = "";
      if (elements.inventorySlotCount) {
        elements.inventorySlotCount.textContent = `${inventoryCount()}/${inventoryCapacity(stats)}`;
      }
      const inventoryItems = characterGear.filter(item => item.gear_slot === "inventory");
      if (!inventoryItems.length) {
        container.innerHTML = `<span class="muted">No gear in inventory.</span>`;
        return;
      }
      const filteredItems = sortGearEntries(inventoryItems.filter(entry => matchesGearFilters(entry.gear, stats, getInventoryFilterState())));
      if (!filteredItems.length) {
        container.innerHTML = `<span class="muted">No inventory gear matches the selected filters.</span>`;
        return;
      }
      filteredItems.forEach(entry => {
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        const colorLabel = [gear.color, gear.color2].filter(Boolean).join(" / ") || "Neutral";
        const availableSlots = availableSlotsForGear(gear, stats);
        const swapOptions = gearType === "Bauble" ? [] : getSwapOptionsForGear(gear, stats);
        const shouldSwap = !availableSlots.length && swapOptions.length;
        const consumable = isConsumable(gear);
        const slotHint = gearType === "Bauble"
          ? "Baubles cannot be equipped."
          : (consumable
            ? "Consumable (single use)."
          : (availableSlots.length
            ? availableSlots.map(formatSlotLabel).join(", ")
            : (swapOptions.length ? "No slots open (swap available)" : "No slots open")));
        const canEquip = gearType !== "Bauble" && !consumable && (availableSlots.length || swapOptions.length);
        const colorCounts = getEquippedColorCounts();
        const gValue = gearType === "Bauble" && gear.color ? (colorCounts[gear.color] || 0) : 0;
        const statSummary = buildGearStatSummary(gear, stats.luck, { g: gValue });
        const card = document.createElement("div");
        card.className = "gear-item";
        card.innerHTML = `
          <div class="gear-summary">
            <div class="gear-meta">
              <strong>${formatGearName(gear)}</strong>
              <div class="gear-tags">
                ${renderGearTag(gearType, "type")}
                ${renderGearTag(gear.rarity, "rarity")}
                ${renderGearTag(colorLabel, "color", { primary: gear.color || "Neutral", secondary: gear.color2 })}
              </div>
              <span class="muted">Equip Slots: ${slotHint}</span>
              <span class="muted gear-stat-summary">Stats: ${statSummary}</span>
              ${consumable ? `<span class="muted">Consumable Summary: ${getConsumableSummary(gear)}</span>` : ""}
            </div>
            <div class="gear-actions">
              <button type="button" data-action="view" data-gear="${entry.gear_id}" aria-label="View details" title="View details"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="11" cy="11" r="6"></circle><path d="M16 16l5 5"></path></svg><span>Details</span></button>
              <button type="button" data-action="modify" data-gear="${entry.gear_id}" aria-label="Modify" title="Modify"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M14.7 6.3a4 4 0 1 0 3 3l-4.6 4.6a2 2 0 0 1-2.8 0l-1.3-1.3a2 2 0 0 1 0-2.8z"></path><path d="M12 12l-7 7"></path></svg><span>Modify</span></button>
              ${consumable
                ? `<button type="button" data-action="use" data-gear="${entry.gear_id}" aria-label="Use" title="Use"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M13 2L5 13h6l-1 9 9-13h-6z"></path></svg><span>Use</span></button>`
                : (gearType === "Bauble" ? "" : `<button type="button" data-action="equip" data-gear="${entry.gear_id}" ${canEquip ? "" : "disabled"} aria-label="${shouldSwap ? "Swap" : "Equip"}" title="${shouldSwap ? "Swap" : "Equip"}">${shouldSwap ? '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M7 7h10"></path><path d="M14 4l3 3-3 3"></path><path d="M17 17H7"></path><path d="M10 14l-3 3 3 3"></path></svg><span>Swap</span>' : '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3l7 3v5c0 5-3 8-7 10-4-2-7-5-7-10V6z"></path></svg><span>Equip</span>'}</button>`)}
              ${gearType === "Bauble" 
                ? `<button type="button" data-action="local" class="gear-action-wide" data-gear="${entry.gear_id}" aria-label="Move to local node storage" title="Move to local node storage"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 4v10"></path><path d="M8 10l4 4 4-4"></path><path d="M4 20h16"></path></svg><span>Local Storage</span></button>` 
                : `<button type="button" data-action="local" data-gear="${entry.gear_id}" aria-label="Move to local node storage" title="Move to local node storage"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 4v10"></path><path d="M8 10l4 4 4-4"></path><path d="M4 20h16"></path></svg><span>Local Storage</span></button>`}
              <button type="button" data-action="dissolve" data-gear="${entry.gear_id}" aria-label="Dissolve" title="Dissolve"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M10 3h4"></path><path d="M11 3v6l-5 8a3 3 0 0 0 2.6 4h6.8A3 3 0 0 0 18 17l-5-8V3"></path><path d="M8 14h8"></path></svg><span>Dissolve</span></button>
              <button type="button" data-action="delete" data-gear="${entry.gear_id}" aria-label="Delete" title="Delete"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 7h16"></path><path d="M9 7V4h6v3"></path><path d="M7 7l1 13h8l1-13"></path><path d="M10 11v6M14 11v6"></path></svg><span>Delete</span></button>
            </div>
          </div>
        `;
        container.appendChild(card);
      });
    }

    function renderLocalNode(stats) {
      const container = elements.localNodeSlots;
      container.innerHTML = "";
      if (elements.localNodeSlotCount) {
        elements.localNodeSlotCount.textContent = `${localNodeCount()}/${localNodeCapacity(stats)}`;
      }
      const localItems = characterGear.filter(item => item.gear_slot === "local_node");
      if (!localItems.length) {
        container.innerHTML = `<span class="muted">No gear in local node storage.</span>`;
        return;
      }
      const filteredItems = sortGearEntries(localItems.filter(entry => matchesGearFilters(entry.gear, stats, getLocalNodeFilterState())));
      if (!filteredItems.length) {
        container.innerHTML = `<span class="muted">No local node gear matches the selected filters.</span>`;
        return;
      }
      filteredItems.forEach(entry => {
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        const colorLabel = [gear.color, gear.color2].filter(Boolean).join(" / ") || "Neutral";
        const colorCounts = getEquippedColorCounts();
        const gValue = gearType === "Bauble" && gear.color ? (colorCounts[gear.color] || 0) : 0;
        const statSummary = buildGearStatSummary(gear, stats.luck, { g: gValue });
        const consumable = isConsumable(gear);
        const card = document.createElement("div");
        card.className = "gear-item";
        card.innerHTML = `
          <div class="gear-summary">
            <div class="gear-meta">
              <strong>${formatGearName(gear)}</strong>
              <div class="gear-tags">
                ${renderGearTag(gearType, "type")}
                ${renderGearTag(gear.rarity, "rarity")}
                ${renderGearTag(colorLabel, "color", { primary: gear.color || "Neutral", secondary: gear.color2 })}
              </div>
              <span class="muted">Stored in Local Node</span>
              <span class="muted gear-stat-summary">Stats: ${statSummary}</span>
              ${consumable ? `<span class="muted">Consumable Summary: ${getConsumableSummary(gear)}</span>` : ""}
            </div>
            <div class="gear-actions">
              <button type="button" data-action="view" data-gear="${entry.gear_id}" aria-label="View details" title="View details"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="11" cy="11" r="6"></circle><path d="M16 16l5 5"></path></svg><span>Details</span></button>
              <button type="button" data-action="modify" data-gear="${entry.gear_id}" aria-label="Modify" title="Modify"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M14.7 6.3a4 4 0 1 0 3 3l-4.6 4.6a2 2 0 0 1-2.8 0l-1.3-1.3a2 2 0 0 1 0-2.8z"></path><path d="M12 12l-7 7"></path></svg><span>Modify</span></button>
              <button type="button" data-action="inventory" class="gear-action-wide" data-gear="${entry.gear_id}" aria-label="Move to inventory" title="Move to inventory"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 4v10"></path><path d="M8 10l4 4 4-4"></path><path d="M4 20h16"></path></svg><span>Inventory</span></button>
              <button type="button" data-action="dissolve" data-gear="${entry.gear_id}" aria-label="Dissolve" title="Dissolve"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M10 3h4"></path><path d="M11 3v6l-5 8a3 3 0 0 0 2.6 4h6.8A3 3 0 0 0 18 17l-5-8V3"></path><path d="M8 14h8"></path></svg><span>Dissolve</span></button>
              <button type="button" data-action="delete" data-gear="${entry.gear_id}" aria-label="Delete" title="Delete"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 7h16"></path><path d="M9 7V4h6v3"></path><path d="M7 7l1 13h8l1-13"></path><path d="M10 11v6M14 11v6"></path></svg><span>Delete</span></button>
            </div>
          </div>
        `;
        container.appendChild(card);
      });
    }

    function renderAbilities() {
      const container = elements.abilitiesList;
      if (!container) return;
      const actives = [];
      const passives = [];
      const effects = [];

      characterGear.forEach(entry => {
        if (!entry.gear) return;
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        if (gearType === "Bauble" && entry.gear_slot === "inventory") {
          (gear.abilities || []).forEach(ability => effects.push(ability));
          return;
        }
        if (!entry.equipped) return;
        if (gearType === "Kernel") {
          (gear.abilities || []).forEach(ability => passives.push(ability));
        } else {
          (gear.abilities || []).forEach(ability => actives.push({ ability, rarity: gear.rarity }));
        }
      });

      const renderAbilityDropdowns = (list, { showTierEnergy = false, showTierDetails = true } = {}) => {
        if (!list.length) {
          return `<p class="muted">None.</p>`;
        }
        return list
          .map(ability => {
            const abilityEntry = ability && typeof ability === "object" && "ability" in ability
              ? ability
              : { ability, rarity: null };
            const resolved = resolveAbilityDetails(abilityEntry.ability);
            const abilityName = typeof resolved === "string" ? resolved : resolved.name;
            const abilityLink = typeof resolved === "string" ? "" : resolved.link;
            const lines = parseAbilityLines(resolved).filter(Boolean);
            const tierDetails = typeof resolved === "string" ? null : resolved.tierDetails;
            const tierEntries = showTierDetails && tierDetails && typeof tierDetails === "object" && !Array.isArray(tierDetails)
              ? Object.entries(tierDetails)
              : [];
            const tierLimit = getAbilityTierLimit(abilityName, abilityEntry.rarity);
            const filteredTierEntries = sortTierEntries(tierEntries.filter(([tier]) => {
              if (tierLimit === null) return true;
              const tierNumber = getTierNumberFromLabel(tier);
              return tierNumber === null || tierNumber <= tierLimit;
            }));
            const detailsList = filteredTierEntries.length
              ? `<ul>${filteredTierEntries
                .map(([tier, detail]) => (
                  `<li class="ability-tier"><strong>${formatTierLabel(tier)}:</strong> ${detail}</li>`
                ))
                .join("")}</ul>`
              : (lines.length
                ? `<ul>${lines.map(line => `<li>${line}</li>`).join("")}</ul>`
                : `<p class="muted">No details.</p>`);
            return `
              <div class="ability-dropdown">
                <button type="button" class="ability-summary" aria-expanded="false">
                  ${abilityName}
                </button>
                <div class="ability-details" hidden>
                  ${detailsList}
                  ${abilityLink ? `<a href="${abilityLink}" target="_blank" rel="noopener">View full ability details</a>` : ""}
                </div>
              </div>
            `;
          })
          .join("");
      };

      const renderAbilityGroup = (title, list, options = {}) => `
        <div class="ability-group">
          <h3>${title}</h3>
          ${renderAbilityDropdowns(list, options)}
        </div>
      `;

      container.innerHTML = `
        ${renderAbilityGroup("Actives", actives, { showTierEnergy: true, showTierDetails: true })}
        ${renderAbilityGroup("Passives", passives, { showTierDetails: false })}
        ${renderAbilityGroup("Effects", effects, { showTierDetails: false })}
      `;
    }

    function inventoryCapacity(stats) {
      return Math.max(Number(stats.inventory_slots) || 0, 0);
    }

    function localNodeCapacity(stats) {
      return inventoryCapacity(stats) * 3;
    }

    function inventoryCount() {
      return characterGear.filter(entry => entry.gear_slot === "inventory").length;
    }

    function localNodeCount() {
      return characterGear.filter(entry => entry.gear_slot === "local_node").length;
    }

    function findGearEntry(gearId) {
      return characterGear.find(entry => String(entry.gear_id) === String(gearId));
    }

    async function ensurePyodide() {
      if (pyodideReady) return pyodideClient;
      elements.gearGeneratorStatus.textContent = "Loading gear generator…";
      elements.openGearGenerator.classList.add("hidden");
      try {
        const { loadPyodide } = await import("https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.mjs");
        pyodideClient = await loadPyodide();

        const pyFiles = [
          "abilityCatalog.py",
          "ability.py",
          "statbuff.py",
          "miscFunc.py",
          "gear.py",
          "helperFunc.py"
        ];

        for (const name of pyFiles) {
          const resp = await fetch(name);
          if (!resp.ok) throw new Error(`Failed to fetch ${name}: ${resp.status}`);
          const code = await resp.text();
          pyodideClient.FS.writeFile(name, code);
        }

        pyodideClient.runPython(`
          import json, random
          from gear import Gear
          from helperFunc import gearTypeMap

          def _serialize_ability(ability):
              if isinstance(ability, str):
                  return {
                      "name": ability,
                      "link": "",
                      "tierDetails": "No tier details."
                  }
              details = ability.tierDetails
              if isinstance(details, str):
                  details = { "Detail": details }
              return {
                  "name": ability.name,
                  "link": ability.link,
                  "tierDetails": details
              }

          def _serialize_gear(gear):
              stats = []
              for buff in gear.basicStatBuffs + gear.colorStatBuffs:
                  stats.append({
                      "name": buff.normalName,
                      "label": buff.name,
                      "formula": buff.formula,
                      "value": buff.calc
                  })
              abilities = [_serialize_ability(ab) for ab in gear.abilities]
              if gear.gearType == "Consumable":
                  effect_details = {"Effect": str(getattr(gear, "specificEffect", ""))}
                  abilities = [{
                      "name": f"{getattr(gear, 'consumableType', 'Consumable')} Effect",
                      "link": "",
                      "tierDetails": effect_details
                  }]
              aesthetic = getattr(gear, "aesthetic", None) or getattr(gear, "baubleAesthetic", None)
              payload = {
                  "rarity": gear.rarity,
                  "color": gear.color,
                  "color2": gear.color2,
                  "gear_type": gear.gearType,
                  "item_type": gear.specificItem,
                  "aesthetic": aesthetic,
                  "essence_value": gear.essenceValue,
                  "credit_value": gear.creditValue,
                  "abilities": abilities,
                  "stats": stats,
                  "stat_modifiers": []
              }
              if gear.gearType == "Bauble":
                  payload["stat_modifiers"] = [
                      {
                          "name": buff.normalName,
                          "label": buff.name,
                          "formula": buff.formula
                      }
                      for buff in gear.colorStatBuffs
                  ]
                  payload["stats"] = []
              return payload

          def generate_gear_json(luck:int, amount:int, gearTypeNumber:int, rarity, color, color2):
              rarity = rarity if rarity else None
              color = color if color else None
              color2 = color2 if color2 else None
              output = []
              for _ in range(amount):
                  gearType = gearTypeMap.get(gearTypeNumber)
                  if gearType is None:
                      gearType = random.choice([v for v in gearTypeMap.values() if v])
                  gear = Gear(luck, gearType, rarity, color, color2)
                  output.append(_serialize_gear(gear))
              return json.dumps(output)

          def list_abilities_json():
              import abilityCatalog
              abilities = set()
              colors = ["Neutral", "Red", "Blue", "Green", "Gray"]
              color2_options = [None, "Neutral", "Red", "Blue", "Green", "Gray"]

              for name, cls in abilityCatalog.__dict__.items():
                  if not isinstance(cls, type):
                      continue
                  if not issubclass(cls, abilityCatalog.AbilityCatalog):
                      continue
                  if cls is abilityCatalog.AbilityCatalog:
                      continue
                  for color in colors:
                      for color2 in color2_options:
                          try:
                              instance = cls(color, color2)
                          except TypeError:
                              try:
                                  instance = cls(color)
                              except Exception:
                                  continue
                          except Exception:
                              continue
                          if isinstance(instance.abilities, dict):
                              abilities.update(instance.abilities.keys())
                          elif isinstance(instance.abilities, list):
                              abilities.update(instance.abilities)
              return json.dumps(sorted(list(abilities)))

          def list_ability_details_json():
              import abilityCatalog
              colors = ["Neutral", "Red", "Blue", "Green", "Gray"]
              color2_options = [None, "Neutral", "Red", "Blue", "Green", "Gray"]
              link_suffixes = {
                  abilityCatalog.WeaponActiveCatalog: "https://xeonrapture.com/xr/XRRPG+2.0/Sub-RPGs/Webrunning+2.0/Gear+Generation/Gear+Actives#",
                  abilityCatalog.ClothingActiveCatalog: "https://xeonrapture.com/xr/XRRPG+2.0/Sub-RPGs/Webrunning+2.0/Gear+Generation/Gear+Actives#",
                  abilityCatalog.PassiveCatalog: "https://xeonrapture.com/xr/XRRPG+2.0/Sub-RPGs/Webrunning+2.0/Gear+Generation/Kernels#",
                  abilityCatalog.ConsumableEffectCatalog: "https://xeonrapture.com/xr/XRRPG+2.0/Sub-RPGs/Webrunning+2.0/Gear+Generation/Consumables#",
                  abilityCatalog.BaubleEffectCatalog: "https://xeonrapture.com/xr/XRRPG+2.0/Sub-RPGs/Webrunning+2.0/Gear+Generation/Baubles#"
              }
              ability_map = {}

              def normalize_details(details):
                  if isinstance(details, str):
                      return { "Detail": details }
                  if isinstance(details, list):
                      return { f"Detail {index + 1}": detail for index, detail in enumerate(details) }
                  if isinstance(details, dict):
                      return details
                  return { "Detail": str(details) }

              for name, cls in abilityCatalog.__dict__.items():
                  if not isinstance(cls, type):
                      continue
                  if not issubclass(cls, abilityCatalog.AbilityCatalog):
                      continue
                  if cls is abilityCatalog.AbilityCatalog:
                      continue
                  link_suffix = link_suffixes.get(cls, "")
                  for color in colors:
                      for color2 in color2_options:
                          try:
                              instance = cls(color, color2)
                          except TypeError:
                              try:
                                  instance = cls(color)
                              except Exception:
                                  continue
                          except Exception:
                              continue
                          if isinstance(instance.abilities, dict):
                              for ability_name, details in instance.abilities.items():
                                  if ability_name in ability_map:
                                      continue
                                  ability_map[ability_name] = {
                                      "name": ability_name,
                                      "link": f"{link_suffix}{ability_name.replace(' ', '+')}" if link_suffix else "",
                                      "tierDetails": normalize_details(details)
                                  }
                          elif isinstance(instance.abilities, list):
                              for ability_name in instance.abilities:
                                  if ability_name in ability_map:
                                      continue
                                  ability_map[ability_name] = {
                                      "name": ability_name,
                                      "link": f"{link_suffix}{ability_name.replace(' ', '+')}" if link_suffix else "",
                                      "tierDetails": { "Detail": "No tier details." }
                                  }
              return json.dumps(ability_map)
        `);

        pyodideReady = true;
        if (!availableAbilities.length) {
          try {
            const abilityJson = pyodideClient.runPython("list_abilities_json()");
            availableAbilities = JSON.parse(abilityJson) || [];
            refreshAbilitySelectOptions();
          } catch (abilityError) {
            console.warn("Failed to load ability list", abilityError);
          }
        }
        try {
          const abilityDetailJson = pyodideClient.runPython("list_ability_details_json()");
          const abilityDetails = JSON.parse(abilityDetailJson) || {};
          abilityDetailMap = new Map(Object.entries(abilityDetails));
        } catch (detailError) {
          console.warn("Failed to load ability details", detailError);
        }
        elements.gearGeneratorStatus.textContent = "";
        elements.openGearGenerator.classList.remove("hidden");
        pushStatus("Gear generator ready.", { tone: "success", duration: 2500 });
        return pyodideClient;
      } catch (error) {
        console.error(error);
        elements.gearGeneratorStatus.textContent = "Failed to load gear generator.";
        pushStatus("Failed to load gear generator.", { tone: "error" });
        throw error;
      }
    }

    async function openGearGeneratorModal() {
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const hasTempBuffs = tempConsumableSummary.length > 0;
      if (elements.tempBuffSection) {
        elements.tempBuffSection.classList.toggle("hidden", !hasTempBuffs);
      }
      if (elements.tempBuffSummary) {
        elements.tempBuffSummary.textContent = hasTempBuffs
          ? `Active Temp Buffs: ${tempConsumableSummary.join(" | ")}`
          : "No active temporary consumable buffs.";
      }
      if (elements.clearTempBuffs) {
        elements.clearTempBuffs.classList.toggle("hidden", !hasTempBuffs);
      }
      updateGearGeneratorLuck(stats);
      gearGeneratorModal.classList.remove("hidden");
      await ensurePyodide();
    }

    function closeGearGeneratorModal() {
      gearGeneratorModal.classList.add("hidden");
    }

    function renderGeneratedGear(stats) {
      generatedGearList.innerHTML = "";
      if (!generatedGear.length) {
        generatedGearList.innerHTML = `<span class="muted">No gear generated yet.</span>`;
        if (addAllGeneratedGearButton) {
          addAllGeneratedGearButton.disabled = true;
        }
        return;
      }
      if (addAllGeneratedGearButton) {
        addAllGeneratedGearButton.disabled = false;
      }
      const totalLuck = getGearGeneratorLuck(stats);
      const colorCounts = getEquippedColorCounts();
      generatedGear.forEach((gear, index) => {
        const card = document.createElement("div");
        card.className = "gear-item";
        const gearType = gear.gear_type || gear.gearType;
        const showTierDetails = !["Kernel", "Bauble"].includes(gearType);
        const colorLabel = [gear.color, gear.color2].filter(Boolean).join(" / ") || "Neutral";
        const gValue = gearType === "Bauble" && gear.color ? (colorCounts[gear.color] || 0) : 0;
        const statList = renderGearStatsList(gear.stats, gear.stat_modifiers, totalLuck, { g: gValue });
        const isAdded = gear.__added;
        const consumable = isConsumable(gear);
        const availableSlots = availableSlotsForGear(gear, stats);
        const swapOptions = gearType === "Bauble" ? [] : getSwapOptionsForGear(gear, stats);
        const shouldSwap = !availableSlots.length && swapOptions.length;
        const canEquip = gearType !== "Bauble" && !consumable && (availableSlots.length || swapOptions.length);
        card.innerHTML = `
          <div class="gear-summary">
            <div class="gear-meta">
              <strong>${formatGearName(gear)}</strong>
              <div class="gear-tags">
                ${renderGearTag(gearType, "type")}
                ${renderGearTag(gear.rarity, "rarity")}
                ${renderGearTag(colorLabel, "color", { primary: gear.color || "Neutral", secondary: gear.color2 })}
              </div>
            </div>
            <div class="gear-actions gear-actions--stack">
              <button type="button" data-action="add" data-index="${index}" ${isAdded ? "disabled" : ""} aria-label="Add to inventory" title="Add to inventory">${isAdded ? '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><path d="M8 12l3 3 5-6"></path></svg><span>Added</span>' : '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 4v10"></path><path d="M8 10l4 4 4-4"></path><path d="M4 20h16"></path></svg><span>Inventory</span>'}</button>
              ${gearType === "Bauble" || consumable ? "" : `<button type="button" data-action="equip" data-index="${index}" ${isAdded || !canEquip ? "disabled" : ""} aria-label="${shouldSwap ? "Swap" : "Equip"}" title="${shouldSwap ? "Swap" : "Equip"}">${isAdded ? '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><path d="M8 12l3 3 5-6"></path></svg><span>Equipped</span>' : (shouldSwap ? '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M7 7h10"></path><path d="M14 4l3 3-3 3"></path><path d="M17 17H7"></path><path d="M10 14l-3 3 3 3"></path></svg><span>Swap</span>' : '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3l7 3v5c0 5-3 8-7 10-4-2-7-5-7-10V6z"></path></svg><span>Equip</span>')}</button>`}
              <button type="button" data-action="remove" data-index="${index}" ${!isAdded ? "disabled" : ""} aria-label="Remove from character" title="Remove from character">${isAdded ? '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 20V10"></path><path d="M8 14l4-4 4 4"></path><path d="M4 4h16"></path></svg><span>Remove</span>' : '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><rect x="7" y="6" width="3" height="12"></rect><rect x="14" y="6" width="3" height="12"></rect></svg><span>Not Added</span>'}</button>
            </div>
          </div>
          <div class="gear-details-list">
            <strong>Stats</strong>
            ${statList}
            ${consumable ? `<strong>Consumable Summary</strong><p>${getConsumableSummary(gear)}</p>` : ""}
            <strong>Abilities</strong>
            ${renderAbilityDetails(gear.abilities, { showTierDetails, gearRarity: gear.rarity })}
          </div>
        `;
        generatedGearList.appendChild(card);
      });
    }

    async function handleGenerateGear() {
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const totalLuck = getGearGeneratorLuck(stats);
      const requestedLuck = (stats.luck || 0) + (Number(gearBonusLuck.value) || 0);
      const amount = Math.max(Number(gearAmount.value) || 1, 1);
      const gearTypeValue = parseInt(gearTypeNumber.value, 10);
      const rarity = gearRarity.value;
      const color = gearColor.value;
      const color2 = gearColor2.value;

      try {
        await ensurePyodide();
        const result = pyodideClient.runPython(
          `generate_gear_json(${totalLuck}, ${amount}, ${gearTypeValue}, ${toPythonLiteral(rarity)}, ${toPythonLiteral(color)}, ${toPythonLiteral(color2)})`
        );
        generatedGear = JSON.parse(result);
        generatedGear.forEach(gear => {
          if (!gear.name) {
            gear.name = formatGearName(gear);
          }
        });
        renderGeneratedGear(stats);
        if (requestedLuck > totalLuck) {
          pushStatus(`Luck limit note: requested ${requestedLuck}, generated with capped luck ${totalLuck}.`, { tone: "warning" });
        }
      } catch (error) {
        console.error(error);
        pushStatus("Failed to generate gear.", { tone: "error" });
      }
    }

    function buildStatOptionList(selectedValue = "") {
      return statOptions
        .map(stat => `<option value="${stat}" ${stat === selectedValue ? "selected" : ""}>${stat}</option>`)
        .join("");
    }

    function buildFormulaOptionList(selectedValue = "") {
      return baubleFormulaOptions
        .map(formula => `<option value="${formula}" ${formula === selectedValue ? "selected" : ""}>${formula}</option>`)
        .join("");
    }

    function buildAbilityOptionList(selectedValue = "") {
      const list = availableAbilities.length ? [...availableAbilities] : ["Custom Ability"];
      if (selectedValue && !list.includes(selectedValue)) {
        list.unshift(selectedValue);
      }
      return list
        .map(ability => `<option value="${ability}" ${ability === selectedValue ? "selected" : ""}>${ability}</option>`)
        .join("");
    }

    function createManualStatRow({ statName = "", value = 0, formula = "" } = {}) {
      const row = document.createElement("div");
      row.className = "manual-gear-row";
      row.innerHTML = `
        <select class="manual-gear-stat-name">
          ${buildStatOptionList(statName || statOptions[0])}
        </select>
        <div class="manual-gear-stat-value"></div>
        <button type="button" class="manual-gear-remove" aria-label="Remove" title="Remove"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M5 12h14"></path></svg><span>Remove</span></button>
      `;
      const valueContainer = row.querySelector(".manual-gear-stat-value");
      const removeButton = row.querySelector(".manual-gear-remove");
      removeButton.addEventListener("click", () => {
        row.remove();
      });
      const isBauble = manualGearType.value === "Bauble";
      if (isBauble) {
        valueContainer.innerHTML = `
          <select class="manual-gear-formula">
            ${buildFormulaOptionList(formula || baubleFormulaOptions[0])}
          </select>
        `;
      } else {
        valueContainer.innerHTML = `
          <input class="manual-gear-value" type="number" value="${value}" />
        `;
      }
      manualGearStatsList.appendChild(row);
    }

    function refreshManualStatRowsForType() {
      const isBauble = manualGearType.value === "Bauble";
      manualGearStatsList.querySelectorAll(".manual-gear-row").forEach(row => {
        const valueContainer = row.querySelector(".manual-gear-stat-value");
        if (!valueContainer) return;
        if (isBauble) {
          const currentFormula = row.querySelector(".manual-gear-formula")?.value || baubleFormulaOptions[0];
          valueContainer.innerHTML = `
            <select class="manual-gear-formula">
              ${buildFormulaOptionList(currentFormula)}
            </select>
          `;
        } else {
          const currentValue = row.querySelector(".manual-gear-value")?.value || 0;
          valueContainer.innerHTML = `<input class="manual-gear-value" type="number" value="${currentValue}" />`;
        }
      });
    }

    function createManualAbilityRow(selectedValue = "") {
      const row = document.createElement("div");
      row.className = "manual-gear-row";
      row.innerHTML = `
        <select class="manual-gear-ability">
          ${buildAbilityOptionList(selectedValue)}
        </select>
        <div class="manual-gear-stat-value"></div>
        <button type="button" class="manual-gear-remove" aria-label="Remove" title="Remove"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M5 12h14"></path></svg><span>Remove</span></button>
      `;
      const removeButton = row.querySelector(".manual-gear-remove");
      removeButton.addEventListener("click", () => {
        row.remove();
      });
      manualGearAbilitiesList.appendChild(row);
    }

    function readManualStatRows() {
      const isBauble = manualGearType.value === "Bauble";
      const rows = Array.from(manualGearStatsList.querySelectorAll(".manual-gear-row"));
      if (isBauble) {
        return rows
          .map(row => {
            const statName = row.querySelector(".manual-gear-stat-name")?.value;
            const formula = row.querySelector(".manual-gear-formula")?.value;
            if (!statName || !formula) return null;
            return { name: statName, label: statName, formula };
          })
          .filter(Boolean);
      }
      return rows
        .map(row => {
          const statName = row.querySelector(".manual-gear-stat-name")?.value;
          const rawValue = Number(row.querySelector(".manual-gear-value")?.value || 0);
          if (!statName) return null;
          return {
            name: statName,
            label: statName,
            formula: formatSignedValue(rawValue),
            value: rawValue
          };
        })
        .filter(Boolean);
    }

    function readManualAbilities() {
      return Array.from(manualGearAbilitiesList.querySelectorAll(".manual-gear-ability"))
        .map(select => select.value)
        .filter(Boolean);
    }

    function buildManualGearPayload() {
      const isBauble = manualGearType.value === "Bauble";
      const stats = isBauble ? [] : readManualStatRows();
      const statModifiers = isBauble ? readManualStatRows() : [];
      const abilities = readManualAbilities();
      const payload = {
        name: manualGearName.value.trim() || null,
        rarity: manualGearRarity.value,
        color: manualGearColor.value,
        color2: manualGearColor2.value || null,
        gear_type: manualGearType.value,
        item_type: manualGearItemType.value.trim() || null,
        aesthetic: manualGearAesthetic.value.trim() || null,
        essence_value: Number(manualGearEssence.value) || 0,
        credit_value: Number(manualGearCredit.value) || 0,
        stats,
        stat_modifiers: statModifiers,
        abilities
      };
      if (!payload.name) {
        payload.name = formatGearName(payload);
      }
      return payload;
    }

    function populateGearFilterSelects() {
      const unique = list => Array.from(new Set(list));
      const appendOptions = (select, options) => {
        if (!select) return;
        const current = select.value;
        select.querySelectorAll("option:not([value=''])").forEach(option => option.remove());
        options.forEach(option => {
          const element = document.createElement("option");
          element.value = option;
          element.textContent = option;
          select.appendChild(element);
        });
        if (options.includes(current)) {
          select.value = current;
        }
      };

      appendOptions(gearFilterRarity, unique(raritySortOrder));
      appendOptions(gearFilterType, unique(gearTypeSortOrder));
      appendOptions(gearFilterColor, unique(colorSortOrder));
      appendOptions(gearFilterStat, unique(statOptions));
      appendOptions(localGearFilterRarity, unique(raritySortOrder));
      appendOptions(localGearFilterType, unique(gearTypeSortOrder));
      appendOptions(localGearFilterColor, unique(colorSortOrder));
      appendOptions(localGearFilterStat, unique(statOptions));
    }

    function refreshAbilitySelectOptions() {
      manualGearAbilitiesList.querySelectorAll(".manual-gear-ability").forEach(select => {
        const current = select.value;
        select.innerHTML = buildAbilityOptionList(current);
      });
    }

    function resetManualGearStatus() {
      manualGearStatus.textContent = "";
    }

    function handleManualGearAdd() {
      resetManualGearStatus();
      try {
        const payload = buildManualGearPayload();
        generatedGear.unshift(payload);
        renderGeneratedGear(applyGearBonuses(currentStats(), calculateGearBonuses(currentStats())));
        manualGearStatus.textContent = "Manual gear added.";
      } catch (error) {
        console.error(error);
        manualGearStatus.textContent = "Failed to add manual gear.";
      }
    }

    async function addAllGeneratedGear() {
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const available = inventoryCapacity(stats) - inventoryCount();
      if (available <= 0) {
        pushStatus("No inventory slots available.", { tone: "warning" });
        return;
      }
      let added = 0;
      for (const gear of generatedGear) {
        if (gear.__added) continue;
        if (added >= available) break;
        const inserted = await insertGearToInventory(gear);
        if (inserted) {
          gear.__added = true;
          added += 1;
        }
      }
      if (added) {
        pushStatus(`Added ${added} gear item(s) to inventory.`, { tone: "success" });
      } else {
        pushStatus("No new gear was added.", { tone: "warning" });
      }
      renderGeneratedGear(applyGearBonuses(currentStats(), calculateGearBonuses(currentStats())));
    }

    function buildGearInsertPayload(gear) {
      return {
        name: gear.name || formatGearName(gear),
        rarity: gear.rarity,
        color: gear.color,
        color2: gear.color2 || null,
        gear_type: gear.gear_type || gear.gearType,
        aesthetic: gear.aesthetic || null,
        item_type: gear.item_type || gear.itemType || null,
        stats: gear.stats || [],
        essence_value: gear.essence_value || gear.essenceValue || 0,
        credit_value: gear.credit_value || gear.creditValue || 0,
        abilities: gear.abilities || [],
        stat_modifiers: gear.stat_modifiers || gear.statModifiers || [],
        notes: gear.notes || null
      };
    }

    async function updateGearRecord(gearId, payload) {
      if (!gearId) {
        throw new Error("Cannot update gear without a gear id.");
      }
      const { data, error } = await sb
        .from("webrunning_gear")
        .update(payload)
        .eq("id", gearId)
        .select("*")
        .maybeSingle();
      if (error) throw error;

      if (data) {
        return data;
      }

      const { data: refreshed, error: refreshError } = await sb
        .from("webrunning_gear")
        .select("*")
        .eq("id", gearId)
        .maybeSingle();
      if (refreshError) throw refreshError;
      if (refreshed) {
        return refreshed;
      }

      console.warn("Gear update returned no row; falling back to local payload.", { gearId });
      return { id: gearId, ...payload };
    }

    function gearSignature(gear) {
      return JSON.stringify(buildGearInsertPayload(gear));
    }

    function isDuplicateGear(gear) {
      const signature = gearSignature(gear);
      return characterGear.some(entry => entry.gear && gearSignature(entry.gear) === signature);
    }

    async function insertGearToInventory(gear, options = {}) {
      if (!activeCharacter?.id) {
        pushStatus("Save the character before adding gear.", { tone: "warning" });
        return null;
      }
      if (isDuplicateGear(gear)) {
        pushStatus("That gear is already stored on this character.", { tone: "warning" });
        return null;
      }
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const slot = options.slot || "inventory";
      if (slot === "inventory" && inventoryCount() >= inventoryCapacity(stats)) {
        pushStatus("No inventory slots available.", { tone: "warning" });
        return null;
      }
      const payload = buildGearInsertPayload(gear);
      const { data, error } = await sb
        .from("webrunning_gear")
        .insert(payload)
        .select("*")
        .maybeSingle();
      if (error) throw error;

      const linkPayload = {
        character_id: activeCharacter.id,
        gear_id: data.id,
        equipped: slot !== "inventory" && slot !== "local_node",
        gear_slot: slot
      };
      const { error: linkError } = await sb
        .from("webrunning_character_gear")
        .insert(linkPayload);
      if (linkError) throw linkError;

      characterGear.push({
        gear_id: data.id,
        equipped: linkPayload.equipped,
        gear_slot: slot,
        gear: data
      });
      render();
      return data;
    }

    async function addGeneratedGear(index, action) {
      const gear = generatedGear[index];
      if (!gear) return;
      if (gear.__added) {
        pushStatus("That gear has already been added.", { tone: "warning" });
        return;
      }
      if (action === "equip") {
        const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
        const slots = availableSlotsForGear(gear, stats);
        if (!slots.length) {
          const swapOptions = getSwapOptionsForGear(gear, stats);
          if (!swapOptions.length) {
            pushStatus("No open slots for that gear.", { tone: "warning" });
            return;
          }
          if (inventoryCount() >= inventoryCapacity(stats)) {
            pushStatus("No inventory slots available to swap gear.", { tone: "warning" });
            return;
          }
          const selected = selectSwapSlot(swapOptions);
          if (!selected) {
            pushStatus("No swap targets available.", { tone: "warning" });
            return;
          }
          const inserted = await insertGearToInventory(gear, { slot: selected.slot });
          if (!inserted) return;
          await updateGearSlot(selected.entry, "inventory");
        } else {
          const inserted = await insertGearToInventory(gear, { slot: slots[0] });
          if (!inserted) return;
        }
      } else {
        const inserted = await insertGearToInventory(gear);
        if (!inserted) return;
      }
      gear.__added = true;
      pushStatus("Gear added.", { tone: "success" });
      renderGeneratedGear(applyGearBonuses(currentStats(), calculateGearBonuses(currentStats())));
    }

    async function removeGeneratedGearFromCharacter(gear) {
      if (!gear) return;
      const signature = gearSignature(gear);
      const entry = characterGear.find(item => item.gear && gearSignature(item.gear) === signature);
      if (!entry) {
        pushStatus("That gear isn't on this character.", { tone: "warning" });
        gear.__added = false;
        renderGeneratedGear(applyGearBonuses(currentStats(), calculateGearBonuses(currentStats())));
        return;
      }
      activeGearRow = entry;
      await deleteGear({ mode: "delete" });
      gear.__added = false;
      renderGeneratedGear(applyGearBonuses(currentStats(), calculateGearBonuses(currentStats())));
    }

    function getRespecBonusPointsByRarity(rarity) {
      if (rarity === "Legendary") return 2;
      if (rarity === "Rare" || rarity === "Epic") return 1;
      return 0;
    }

    function applyTempConsumableStats(gear) {
      const bonus = createEmptyBonus();
      const applied = [];
      (gear.stats || []).forEach(stat => {
        const statName = stat.name || stat.stat || stat.label;
        const value = Number(stat.value ?? stat.calc);
        if (!statName || !Number.isFinite(value) || value === 0) return;
        applyStatBonus(bonus, statName, value, "Temp Buff", null);
        applied.push(`${formatSignedValue(value)} ${statName}`);
      });
      tempConsumableBonus = mergeBonuses(tempConsumableBonus, bonus);
      if (applied.length) {
        tempConsumableSummary.push(`${formatGearName(gear)}: ${applied.join(", ")}`);
      }
    }

    function openRespecModal(baseStats, bonusPoints = 0) {
      return new Promise(resolve => {
        if (!respecModal) {
          resolve(null);
          return;
        }
        const baseTotal = (Number(baseStats.power) || 0) + (Number(baseStats.defense) || 0) + (Number(baseStats.speed) || 0) + (Number(baseStats.intelligence) || 0);
        const totalPoints = baseTotal + bonusPoints;
        const setRemaining = () => {
          const used = (Number(respecPower.value) || 0) + (Number(respecDefense.value) || 0) + (Number(respecSpeed.value) || 0) + (Number(respecIntelligence.value) || 0);
          respecPointsRemaining.textContent = String(totalPoints - used);
        };

        respecPower.value = Number(baseStats.power) || 0;
        respecDefense.value = Number(baseStats.defense) || 0;
        respecSpeed.value = Number(baseStats.speed) || 0;
        respecIntelligence.value = Number(baseStats.intelligence) || 0;
        respecModalHint.textContent = `Reallocate your current points and add ${bonusPoints} bonus point(s).`;
        respecModalMsg.textContent = "";
        setRemaining();
        respecModal.classList.remove("hidden");

        const clean = (value) => {
          [respecPower, respecDefense, respecSpeed, respecIntelligence].forEach(input => input.removeEventListener("input", setRemaining));
          respecApplyBtn.removeEventListener("click", submit);
          respecCancelBtn.removeEventListener("click", cancel);
          respecModalBackdrop?.removeEventListener("click", cancel);
          respecModal.classList.add("hidden");
          resolve(value);
        };

        const submit = () => {
          const next = {
            power: Number(respecPower.value) || 0,
            defense: Number(respecDefense.value) || 0,
            speed: Number(respecSpeed.value) || 0,
            intelligence: Number(respecIntelligence.value) || 0
          };
          const used = next.power + next.defense + next.speed + next.intelligence;
          const valid = Object.values(next).every(value => Number.isFinite(value) && value >= 0);
          if (!valid || used !== totalPoints) {
            respecModalMsg.textContent = `Allocate exactly ${totalPoints} total points.`;
            return;
          }
          clean(next);
        };

        const cancel = () => clean(null);

        [respecPower, respecDefense, respecSpeed, respecIntelligence].forEach(input => input.addEventListener("input", setRemaining));
        respecApplyBtn.addEventListener("click", submit);
        respecCancelBtn.addEventListener("click", cancel);
        respecModalBackdrop?.addEventListener("click", cancel);
      });
    }

    function openEnergyColorModal(defaultColor = "red") {
      return new Promise(resolve => {
        if (!energyModal || !energyColorSelect || !energyApplyBtn || !energyCancelBtn) {
          resolve(defaultColor);
          return;
        }

        const allowedColors = ["red", "blue", "green", "gray"];
        const fallback = allowedColors.includes(defaultColor) ? defaultColor : "red";
        energyColorSelect.value = fallback;
        energyModal.classList.remove("hidden");

        const clean = (value) => {
          energyApplyBtn.removeEventListener("click", submit);
          energyCancelBtn.removeEventListener("click", cancel);
          energyModalBackdrop?.removeEventListener("click", cancel);
          energyModal.classList.add("hidden");
          resolve(value);
        };

        const submit = () => {
          const chosen = String(energyColorSelect.value || "").trim().toLowerCase();
          clean(allowedColors.includes(chosen) ? chosen : null);
        };

        const cancel = () => clean(null);

        energyApplyBtn.addEventListener("click", submit);
        energyCancelBtn.addEventListener("click", cancel);
        energyModalBackdrop?.addEventListener("click", cancel);
      });
    }

    async function useConsumable(entry) {
      if (!entry || !entry.gear || !isConsumable(entry.gear)) return;
      if (!activeCharacter?.id || !currentUser?.id) {
        pushStatus("Save the character before using consumables.", { tone: "warning" });
        return;
      }
      const gear = entry.gear;
      const type = getConsumableType(gear);
      const effect = getConsumableEffectText(gear);
      const details = [
        `Consumable: ${formatGearName(gear)}`,
        `Type: ${type || "Consumable"}`,
        effect ? `Effect: ${effect}` : null
      ].filter(Boolean);
      let reminder = buildConsumableReminder(gear, currentStats());

      try {
        if (type === "Temp Buff") {
          applyTempConsumableStats(gear);
          details.push("Temporary buffs were applied for this node.");
        } else if (type === "Energy") {
          const amount = Number((effect.toLowerCase().match(/grants\s*(\d+)/i) || [])[1] || 0);
          const energyKeyByColor = { red: "energy_red", blue: "energy_blue", green: "energy_green", gray: "energy_gray" };
          const defaultColor = String(gear.color || "red").trim().toLowerCase();
          const chosen = await openEnergyColorModal(defaultColor);
          if (!chosen) {
            pushStatus("Energy consumable cancelled.", { tone: "warning" });
            return;
          }
          const key = energyKeyByColor[chosen];
          if (key && amount > 0) {
            activeCharacter.base_stats[key] = (Number(activeCharacter.base_stats[key]) || 0) + amount;
            const { error } = await sb.from("webrunning_characters").update({ base_stats: activeCharacter.base_stats }).eq("id", activeCharacter.id).eq("user_id", currentUser.id);
            if (error) throw error;
            details.push(`Added ${amount} ${chosen} energy (ignores energy cap).`);
          }
        } else if (type === "Respec Stats") {
          const bonusPoints = getRespecBonusPointsByRarity(gear.rarity);
          const updated = await openRespecModal(activeCharacter.base_stats, bonusPoints);
          if (!updated) {
            pushStatus("Respec cancelled.", { tone: "warning" });
            return;
          }
          activeCharacter.base_stats.power = updated.power;
          activeCharacter.base_stats.defense = updated.defense;
          activeCharacter.base_stats.speed = updated.speed;
          activeCharacter.base_stats.intelligence = updated.intelligence;
          const { error } = await sb.from("webrunning_characters").update({ base_stats: activeCharacter.base_stats }).eq("id", activeCharacter.id).eq("user_id", currentUser.id);
          if (error) throw error;
          details.push(`Reallocated stats with ${bonusPoints} bonus point(s).`);
        } else if (type === "Gear Mod") {
          const modChoice = getGearModChoiceFromEffect(effect);
          activeCharacter.base_stats.free_gear_mod = modChoice;
          activeCharacter.base_stats.free_gear_mod_max_rarity = gear.rarity || "Common";
          const { error } = await sb.from("webrunning_characters").update({ base_stats: activeCharacter.base_stats }).eq("id", activeCharacter.id).eq("user_id", currentUser.id);
          if (error) throw error;
          details.push(`Granted free gear modification: ${modChoice || "any"} (up to ${gear.rarity || "Common"} rarity).`);
          reminder = `Free gear mod granted: ${effect}. Open Gear Modification to use it at 0 essence.`;
        } else if (type === "Gear Type Change" || type === "Gear Color Change") {
          const mode = type === "Gear Type Change" ? "type" : "color";
          const selection = await openGearChangeModal(mode, gear.rarity || "Common");
          if (!selection) {
            pushStatus("Gear change consumable cancelled.", { tone: "warning" });
            return;
          }
          const result = await applyGearChangeConsumable(selection, gear.rarity || "Common");
          if (!result) return;
          details.push(
            mode === "type"
              ? `Changed gear type: ${(result.before.gear_type || result.before.gearType)} → ${selection.value}.`
              : `Changed gear color: ${result.before.color || "Neutral"} → ${selection.value}.`,
            `Rerolled modifiers and abilities on ${formatGearName(result.after)}.`
          );
        } else if (type === "Local Shop Upgrade") {
          details.push("Local shop upgrade reminder logged.");
        }

        activeGearRow = entry;
        activeGearRow.__deletionMetadata = { type: "consumable_use" };
        const deletedRecord = await deleteGear({ mode: "used", details });
        await addEditHistoryRecord({
          type: "consumable",
          label: `Consumable used: ${formatGearName(gear)}`,
          details
        });
        pushStatus(`${reminder}`, {
          tone: "success",
          actionLabel: deletedRecord ? "Undo" : undefined,
          onAction: deletedRecord ? () => undoGearHistory(deletedRecord.id) : undefined,
          duration: 8500
        });
        render();
      } catch (error) {
        console.error(error);
        pushStatus("Failed to use consumable.", { tone: "error" });
      }
    }

    async function useGeneratedConsumable(index) {
      if (!Number.isFinite(index)) return;
      const gear = generatedGear[index];
      if (!gear || !gear.__added) return;
      const signature = gearSignature(gear);
      const entry = characterGear.find(item => item.gear && gearSignature(item.gear) === signature);
      if (!entry) {
        gear.__added = false;
        renderGeneratedGear(applyGearBonuses(currentStats(), calculateGearBonuses(currentStats())));
        pushStatus("That consumable is no longer on this character.", { tone: "warning" });
        return;
      }
      await useConsumable(entry);
      gear.__added = false;
      renderGeneratedGear(applyGearBonuses(currentStats(), calculateGearBonuses(currentStats())));
    }

    async function addPastedGearFromJson() {
      pasteStatus.textContent = "";
      try {
        const parsed = JSON.parse(gearPasteInput.value.trim());
        const gearItems = Array.isArray(parsed) ? parsed : [parsed];
        let added = 0;
        for (const gear of gearItems) {
          const inserted = await insertGearToInventory(gear);
          if (inserted) {
            added += 1;
          }
        }
        gearPasteInput.value = "";
        if (added) {
          pasteStatus.textContent = "Pasted gear added.";
          pushStatus(`Added ${added} pasted gear item(s).`, { tone: "success" });
        } else {
          pasteStatus.textContent = "No gear added.";
          pushStatus("No new gear was added.", { tone: "warning" });
        }
      } catch (error) {
        console.error(error);
        pasteStatus.textContent = "Invalid JSON.";
        pushStatus("Invalid gear JSON.", { tone: "error" });
      }
    }

    function openGearDetailModal(entry) {
      if (!entry) return;
      activeGearRow = entry;
      const gear = entry.gear;
      const gearType = gear.gear_type || gear.gearType;
      const showTierDetails = !["Kernel", "Bauble"].includes(gearType);
      gearDetailTitle.textContent = formatGearName(gear);
      gearNameInput.value = gear.name || formatGearName(gear);
      gearNotesInput.value = gear.notes || "";
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const colorCounts = getEquippedColorCounts();
      const gValue = gearType === "Bauble" && gear.color ? (colorCounts[gear.color] || 0) : 0;
      const statList = renderGearStatsList(gear.stats, gear.stat_modifiers, stats.luck, { g: gValue });
      gearDetailBody.innerHTML = `
        <div>
          <strong>Summary</strong>
          <ul>
            <li>Type: ${gearType}</li>
            <li>Rarity: ${gear.rarity}</li>
            <li>Color: ${[gear.color, gear.color2].filter(Boolean).join(" / ") || "Neutral"}</li>
            <li>Item: ${gear.item_type || "Unknown"}</li>
            <li>Aesthetic: ${gear.aesthetic || "None"}</li>
            <li>Essence Value: ${gear.essence_value}</li>
          </ul>
        </div>
        <div>
          <strong>Stats</strong>
          ${statList}
        </div>
        <div>
          <strong>Abilities</strong>
          ${renderAbilityDetails(gear.abilities, { showTierDetails, gearRarity: gear.rarity })}
        </div>
      `;
      gearDetailStatus.textContent = "";
      gearDetailModal.classList.remove("hidden");
    }

    function closeGearDetailModal() {
      gearDetailModal.classList.add("hidden");
    }

    async function saveGearNameUpdate() {
      if (!activeGearRow) return;
      const newName = gearNameInput.value.trim();
      if (!newName) {
        gearDetailStatus.textContent = "Name cannot be empty.";
        pushStatus("Gear name cannot be empty.", { tone: "warning" });
        return;
      }
      const notes = gearNotesInput.value.trim();
      try {
        await updateGearRecord(activeGearRow.gear_id, { name: newName, notes });
      } catch (error) {
        gearDetailStatus.textContent = error.message;
        pushStatus(error.message, { tone: "error" });
        return;
      }
      activeGearRow.gear.name = newName;
      activeGearRow.gear.notes = notes;
      gearDetailTitle.textContent = newName;
      gearDetailStatus.textContent = "Details saved.";
      pushStatus("Gear details saved.", { tone: "success" });
      render();
    }

    async function copyGearJsonToClipboard() {
      if (!activeGearRow) return;
      const gear = activeGearRow.gear;
      const payload = {
        name: gear.name,
        rarity: gear.rarity,
        color: gear.color,
        color2: gear.color2,
        gear_type: gear.gear_type,
        aesthetic: gear.aesthetic,
        item_type: gear.item_type,
        stats: gear.stats,
        essence_value: gear.essence_value,
        credit_value: gear.credit_value,
        abilities: gear.abilities,
        stat_modifiers: gear.stat_modifiers,
        notes: gear.notes || ""
      };
      try {
        await navigator.clipboard.writeText(JSON.stringify(payload, null, 2));
        gearDetailStatus.textContent = "Copied to clipboard.";
        pushStatus("Copied gear JSON to clipboard.", { tone: "success" });
      } catch (error) {
        console.error(error);
        gearDetailStatus.textContent = "Copy failed.";
        pushStatus("Copy failed.", { tone: "error" });
      }
    }


    function toHistoryTimestamp(value = new Date()) {
      const date = value instanceof Date ? value : new Date(value);
      return date.toISOString();
    }

    async function persistEditHistory() {
      if (!activeCharacter?.id || !currentUser?.id) return;
      const { error } = await sb
        .from("webrunning_characters")
        .update({ edit_history: editHistory })
        .eq("id", activeCharacter.id)
        .eq("user_id", currentUser.id);
      if (error) throw error;
    }

    function normalizeHistoryRecord(record = {}) {
      return {
        ...record,
        createdAt: record.createdAt || toHistoryTimestamp(),
        details: Array.isArray(record.details) ? record.details : []
      };
    }

    function normalizeHistoryText(value) {
      return String(value || "")
        .toLowerCase()
        .replace(/\s+/g, " ")
        .trim();
    }

    function buildHistoryDetailSignature(details = []) {
      return (Array.isArray(details) ? details : [])
        .map(item => normalizeHistoryText(item))
        .filter(Boolean)
        .join("||");
    }

    function areHistoryRecordsVerySimilar(a, b) {
      if (!a || !b) return false;
      const aType = normalizeHistoryText(a.type);
      const bType = normalizeHistoryText(b.type);
      const aLabel = normalizeHistoryText(a.label);
      const bLabel = normalizeHistoryText(b.label);
      const aDetails = buildHistoryDetailSignature(a.details);
      const bDetails = buildHistoryDetailSignature(b.details);
      const aEntryId = a.entry?.gear_id || null;
      const bEntryId = b.entry?.gear_id || null;

      const sameTypeAndDetails = aType && aType === bType && aDetails && aDetails === bDetails;
      const sameEntryAndDetails = aEntryId && bEntryId && aEntryId === bEntryId && aDetails && aDetails === bDetails;
      const sameLabelAndDetails = aLabel && aLabel === bLabel && aDetails && aDetails === bDetails;
      return sameTypeAndDetails || sameEntryAndDetails || sameLabelAndDetails;
    }

    async function addEditHistoryRecord(record) {
      const snapshot = normalizeHistoryRecord({
        id: `${Date.now()}-${Math.random().toString(16).slice(2)}`,
        ...record
      });
      const latest = editHistory[0];
      if (areHistoryRecordsVerySimilar(latest, snapshot)) {
        latest.details = Array.from(new Set([...(latest.details || []), ...(snapshot.details || [])]));
        latest.label = latest.label || snapshot.label;
        latest.type = latest.type || snapshot.type;
        if (!latest.entry && snapshot.entry) {
          latest.entry = snapshot.entry;
        }
        gearHistory = editHistory.filter(item => ["delete", "modify"].includes(item.type));
        renderGearHistory();
        await persistEditHistory();
        return latest;
      }
      editHistory.unshift(snapshot);
      gearHistory = editHistory.filter(item => ["delete", "modify"].includes(item.type));
      renderGearHistory();
      await persistEditHistory();
      return snapshot;
    }

    async function addGearHistoryRecord(record) {
      return addEditHistoryRecord(record);
    }

    async function addDeletedGearHistory(entry, mode, details = []) {
      return addGearHistoryRecord({
        type: "delete",
        mode,
        label: `${mode === "used" ? "Consumable Used" : mode === "dissolve" ? "Gear Dissolved" : "Gear Deleted"}: ${formatGearName(entry.gear)}`,
        details,
        entry: {
          gear_id: entry.gear_id,
          gear_slot: entry.gear_slot,
          equipped: entry.equipped,
          gear: cloneJson(entry.gear)
        }
      });
    }

    function renderGearHistory() {
      if (!elements.deletedGearHistory) return;
      if (!editHistory.length) {
        elements.deletedGearHistory.innerHTML = `<span class="muted">No edit history yet.</span>`;
        return;
      }
      elements.deletedGearHistory.innerHTML = editHistory
        .map(record => {
          const title = record.label || formatGearName(record.entry?.gear || {});
          const kind = record.type === "modify"
            ? "Gear Modification"
            : (record.type === "delete" ? "Gear Change" : "Character Edit");
          const details = Array.isArray(record.details) ? record.details : [];
          const detailHtml = details.length
            ? `<ul>${details.map(item => `<li>${item}</li>`).join("")}</ul>`
            : "";
          const canUndo = record.type === "modify" || record.type === "delete";
          const created = new Date(record.createdAt || Date.now()).toLocaleString();
          return `
            <div class="deletion-history-item">
              <div>
                <strong>${title}</strong>
                <div class="muted">${kind} • ${created}</div>
                ${detailHtml}
              </div>
              ${canUndo
                ? `<button type="button" data-action="undo-history" data-record="${record.id}" aria-label="Undo" title="Undo"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M9 8L4 12l5 4"></path><path d="M4 12h8a6 6 0 1 1 0 12"></path></svg><span>Undo</span></button>`
                : ""}
            </div>
          `;
        })
        .join("");
    }

    function resolveRestoreSlot(entry, stats) {
      const gearType = entry.gear.gear_type || entry.gear.gearType;
      if (entry.gear_slot === "inventory") {
        if (inventoryCount() < inventoryCapacity(stats)) return "inventory";
        return null;
      }
      if (entry.gear_slot === "local_node") {
        if (localNodeCount() < localNodeCapacity(stats)) return "local_node";
        return null;
      }
      const available = availableSlotsForGear(entry.gear, stats);
      if (available.includes(entry.gear_slot)) return entry.gear_slot;
      if (available.length) return available[0];
      return gearType === "Bauble" ? "inventory" : null;
    }

    async function undoDeleteHistoryRecord(record) {
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const slot = resolveRestoreSlot(record.entry, stats);
      if (!slot) {
        pushStatus("No available slot to restore that gear.", { tone: "warning" });
        return false;
      }
      const inserted = await insertGearToInventory(record.entry.gear, { slot });
      return !!inserted;
    }

    async function undoModificationHistoryRecord(record) {
      const entry = findGearEntry(record.entry?.gear_id);
      if (!entry) {
        pushStatus("Cannot undo: modified gear is no longer available.", { tone: "warning" });
        return false;
      }
      const mod = record.modification || {};
      await updateGearRecord(entry.gear_id, buildGearInsertPayload(mod.before));
      entry.gear = cloneJson(mod.before);

      if (mod.secondTargetSnapshot) {
        const second = findGearEntry(mod.secondTargetSnapshot.gear_id);
        if (second) {
          await updateGearRecord(second.gear_id, buildGearInsertPayload(mod.secondTargetSnapshot.before));
          second.gear = cloneJson(mod.secondTargetSnapshot.before);
        }
      }

      if (mod.donorSnapshot) {
        await insertGearToInventory(mod.donorSnapshot.gear, { slot: mod.donorSnapshot.gear_slot || "local_node" });
      }

      if (mod.cost) {
        await updateEssenceBy(mod.cost);
      }
      return true;
    }

    async function undoGearHistory(recordId) {
      const recordIndex = editHistory.findIndex(record => record.id === recordId);
      if (recordIndex === -1) return;
      const record = editHistory[recordIndex];
      try {
        const success = record.type === "modify"
          ? await undoModificationHistoryRecord(record)
          : await undoDeleteHistoryRecord(record);
        if (!success) return;
        editHistory.splice(recordIndex, 1);
        gearHistory = editHistory.filter(item => ["delete", "modify"].includes(item.type));
        await persistEditHistory();
        renderGearHistory();
        render();
        pushStatus("Undo complete.", { tone: "success" });
      } catch (error) {
        console.error(error);
        pushStatus("Failed to undo history entry.", { tone: "error" });
      }
    }

    async function deleteGear({ mode = "delete", details = [] } = {}) {
      if (!activeGearRow) return;
      const gear = activeGearRow.gear;
      const historyDetails = Array.isArray(details) && details.length
        ? details
        : [
            `Item: ${formatGearName(gear)}`,
            `Rarity: ${gear.rarity || "Unknown"}`,
            `Action: ${mode === "dissolve" ? "Dissolved" : mode === "used" ? "Used" : "Deleted"}`,
            mode === "dissolve" ? `Essence gained: ${gear.essence_value || 0}` : null
          ].filter(Boolean);
      try {
        if (mode === "dissolve") {
          const updatedEssence = (activeCharacter.base_stats?.essence || 0) + (gear.essence_value || 0);
          const { error: characterError } = await sb
            .from("webrunning_characters")
            .update({ base_stats: { ...activeCharacter.base_stats, essence: updatedEssence } })
            .eq("id", activeCharacter.id)
            .eq("user_id", currentUser.id);
          if (characterError) throw characterError;
          activeCharacter.base_stats.essence = updatedEssence;
          pushStatus(`Added ${gear.essence_value || 0} essence to your bank.`, { tone: "success" });
        }

        const { error: linkError } = await sb
          .from("webrunning_character_gear")
          .delete()
          .eq("character_id", activeCharacter.id)
          .eq("gear_id", activeGearRow.gear_id);
        if (linkError) throw linkError;

        const { error: gearError } = await sb
          .from("webrunning_gear")
          .delete()
          .eq("id", activeGearRow.gear_id);
        if (gearError) throw gearError;

        const deletedRecord = await addDeletedGearHistory(activeGearRow, mode, historyDetails);
        characterGear = characterGear.filter(entry => entry.gear_id !== activeGearRow.gear_id);
        generatedGear.forEach(item => {
          if (item && gearSignature(item) === gearSignature(gear)) {
            item.__added = false;
          }
        });
        closeGearDetailModal();
        render();
        const deletedMessage = mode === "used"
          ? "Consumable used."
          : (mode === "dissolve" ? "Gear dissolved." : "Gear deleted.");
        if (mode !== "used") {
          pushStatus(deletedMessage, {
            tone: "warning",
            actionLabel: "Undo",
            onAction: () => undoGearHistory(deletedRecord.id),
            duration: 8000
          });
        }
        return deletedRecord;
      } catch (error) {
        console.error(error);
        gearDetailStatus.textContent = "Failed to delete gear.";
        pushStatus("Failed to delete gear.", { tone: "error" });
      }
    }

    async function updateGearSlot(entry, slot) {
      const equipped = slot !== "inventory" && slot !== "local_node";
      const { error } = await sb
        .from("webrunning_character_gear")
        .update({ gear_slot: slot, equipped })
        .eq("character_id", activeCharacter.id)
        .eq("gear_id", entry.gear_id);
      if (error) throw error;
      entry.gear_slot = slot;
      entry.equipped = equipped;
      render();
    }

    async function equipGear(entry) {
      if (!entry) return;
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const availableSlots = availableSlotsForGear(entry.gear, stats);
      if (!availableSlots.length) {
        const swapOptions = getSwapOptionsForGear(entry.gear, stats);
        if (!swapOptions.length) {
          pushStatus("No open slots for that gear.", { tone: "warning" });
          return;
        }
        const selected = selectSwapSlot(swapOptions);
        if (!selected) {
          pushStatus("No swap targets available.", { tone: "warning" });
          return;
        }
        await updateGearSlot(entry, selected.slot);
        await updateGearSlot(selected.entry, "inventory");
        return;
      }
      await updateGearSlot(entry, availableSlots[0]);
    }

    async function moveGearToInventory(entry) {
      if (!entry) return;
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      if (inventoryCount() >= inventoryCapacity(stats)) {
        pushStatus("No inventory slots available.", { tone: "warning" });
        return;
      }
      await updateGearSlot(entry, "inventory");
    }

    async function moveGearToLocalNode(entry) {
      if (!entry) return;
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      if (localNodeCount() >= localNodeCapacity(stats)) {
        pushStatus("No local node slots available.", { tone: "warning" });
        return;
      }
      await updateGearSlot(entry, "local_node");
    }

    function updateDerived(stats, gearBonus) {
      const derived = deriveSecondaryStats(stats);
      const derivedBonus = gearBonus?.derived || {};
      const sources = gearBonus?.sources || createEmptyBonusSources();
      const statusStacks = getStatusStacks(stats);
      const statusAdjustments = {
        attackPlus: -statusStacks.poison,
        damagePlus: -statusStacks.poison,
        defenseDc: -statusStacks.freeze,
        armor: -statusStacks.freeze
      };
      const totalPerception = derived.perception + (derivedBonus.perception || 0);
      const aoeMultiplier = getAoeBuffMultiplier();
      const aoeRange = (totalPerception * aoeMultiplier) + (derivedBonus.aoeRange || 0);

      const attackSources = combineSourceLists(
        sources.derived.attackPlus,
        sources.base.power,
        statusStacks.poison ? [{ label: "Poison", value: statusAdjustments.attackPlus }] : []
      );
      const damageSources = combineSourceLists(
        sources.derived.damagePlus,
        sources.base.power,
        statusStacks.poison ? [{ label: "Poison", value: statusAdjustments.damagePlus }] : []
      );
      const defenseDcSources = combineSourceLists(
        sources.derived.defenseDc,
        sources.base.defense,
        statusStacks.freeze ? [{ label: "Freeze", value: statusAdjustments.defenseDc }] : []
      );
      const armorSources = combineSourceLists(
        sources.derived.armor,
        sources.base.defense,
        statusStacks.freeze ? [{ label: "Freeze", value: statusAdjustments.armor }] : []
      );
      const initiativeSources = combineSourceLists(sources.derived.initiative, sources.base.speed);
      const movementSources = combineSourceLists(sources.derived.movementSpeed, scaleSourceList(sources.base.speed, 2));
      const rangeSources = combineSourceLists(sources.derived.range, sources.base.speed);
      const perceptionSources = combineSourceLists(sources.derived.perception, scaleSourceList(sources.base.intelligence, 2));
      const aoeRangeSources = combineSourceLists(sources.derived.aoeRange, scaleSourceList(sources.base.intelligence, 2 * aoeMultiplier));
      const hackingSources = combineSourceLists(sources.derived.hacking, sources.base.intelligence);

      const limits = getLevelLimits(stats.level);
      const attackTotal = derived.attackPlus + (derivedBonus.attackPlus || 0) + statusAdjustments.attackPlus;
      const comboTotal = derived.damagePlus + (derivedBonus.damagePlus || 0) + statusAdjustments.damagePlus;
      const defenseDcTotal = derived.defenseDc + (derivedBonus.defenseDc || 0) + statusAdjustments.defenseDc;
      const defenseDcDisplay = applyDisplayLimit(defenseDcTotal, limits.defenseDc);

      setStatDisplay(
        elements.displayAttackPlus,
        attackTotal,
        summarizeSources(attackSources),
        {
          rawValue: attackTotal
        }
      );
      setStatDisplay(
        elements.displayDamagePlus,
        comboTotal,
        summarizeSources(damageSources),
        {
          rawValue: comboTotal
        }
      );
      setStatDisplay(elements.displayAttackDamageLimit, limits.attackDamage ?? "None", "");
      setStatDisplay(elements.displayComboDamageLimit, limits.comboDamage ?? "None", "");
      setStatDisplay(
        elements.displayDefenseDc,
        defenseDcTotal,
        summarizeSources(defenseDcSources),
        {
          displayValue: defenseDcDisplay.displayValue,
          limit: defenseDcDisplay.limit,
          limitLabel: "Limit:",
          rawValue: defenseDcTotal,
          showRawValue: Number.isFinite(defenseDcDisplay.limit)
        }
      );
      setStatDisplay(
        elements.displayArmor,
        derived.armor + (derivedBonus.armor || 0) + statusAdjustments.armor,
        summarizeSources(armorSources)
      );
      setStatDisplay(
        elements.displayInitiative,
        derived.initiative + (derivedBonus.initiative || 0),
        summarizeSources(initiativeSources)
      );
      setStatDisplay(
        elements.displayMovementSpeed,
        derived.movementSpeed + (derivedBonus.movementSpeed || 0),
        summarizeSources(movementSources)
      );
      setStatDisplay(
        elements.displayRange,
        derived.range + (derivedBonus.range || 0),
        summarizeSources(rangeSources)
      );
      setStatDisplay(
        elements.displayPerception,
        totalPerception,
        summarizeSources(perceptionSources)
      );
      setStatDisplay(
        elements.displayAoeRange,
        aoeRange,
        summarizeSources(aoeRangeSources)
      );
      setStatDisplay(
        elements.displayHacking,
        derived.hacking + (derivedBonus.hacking || 0),
        summarizeSources(hackingSources)
      );

      if (elements.displayDamageTaken) {
        elements.displayDamageTaken.textContent = formatSignedValue(statusStacks.burn);
      }
      if (elements.displayStatusDefenseDc) {
        elements.displayStatusDefenseDc.textContent = formatSignedValue(statusAdjustments.defenseDc);
      }
      if (elements.displayStatusArmor) {
        elements.displayStatusArmor.textContent = formatSignedValue(statusAdjustments.armor);
      }
      if (elements.displayStatusAttackPlus) {
        elements.displayStatusAttackPlus.textContent = formatSignedValue(statusAdjustments.attackPlus);
      }
      if (elements.displayStatusDamagePlus) {
        elements.displayStatusDamagePlus.textContent = formatSignedValue(statusAdjustments.damagePlus);
      }
    }

    function render() {
      const baseStats = currentStats();
      const gearBonus = calculateGearBonuses(baseStats);
      const stats = applyGearBonuses(baseStats, gearBonus);

      elements.displayName.textContent = activeCharacter?.name || "";
      elements.displayLevel.textContent = stats.level;
      elements.inputXp.value = baseStats.xp;
      const sources = gearBonus?.sources || createEmptyBonusSources();
      const limits = getLevelLimits(stats.level);
      const luckDisplay = applyDisplayLimit(stats.luck, limits.luck);
      const hpDisplay = applyDisplayLimit(stats.hp, limits.hp);
      setStatDisplay(elements.displayLuck, stats.luck, summarizeSources(sources.base.luck), {
        displayValue: luckDisplay.displayValue,
        limit: luckDisplay.limit,
        limitLabel: "Limit:",
        rawValue: stats.luck,
        showRawValue: Number.isFinite(luckDisplay.limit)
      });
      setStatDisplay(elements.displayHp, stats.hp, summarizeSources(sources.base.hp), {
        displayValue: hpDisplay.displayValue,
        limit: hpDisplay.limit,
        limitLabel: "Limit:",
        rawValue: stats.hp,
        showRawValue: Number.isFinite(hpDisplay.limit)
      });
      setStatDisplay(elements.displayEnergyCap, stats.energy_cap, summarizeSources(sources.base.energy_cap));
      elements.inputEssence.value = baseStats.essence;
      elements.inputCurrentHp.value = baseStats.current_hp;
      elements.inputEnergyRed.value = baseStats.energy_red;
      elements.inputEnergyBlue.value = baseStats.energy_blue;
      elements.inputEnergyGreen.value = baseStats.energy_green;
      elements.inputEnergyGray.value = baseStats.energy_gray;
      setStatDisplay(elements.displayInventorySlots, stats.inventory_slots, summarizeSources(sources.base.inventory_slots));
      setStatDisplay(elements.displayKernelSlots, stats.kernel_slots, summarizeSources(sources.base.kernel_slots));
      if (elements.adventuringPlusesColumn && elements.displayAdventuringPluses) {
        const adventuringPluses = summarizeAdventuringPluses(gearBonus?.adventuringPluses || []);
        if (adventuringPluses.length) {
          elements.adventuringPlusesColumn.classList.remove("hidden");
          elements.displayAdventuringPluses.innerHTML = `<ul>${adventuringPluses
            .map(plus => `<li>${formatSignedValue(plus.value)} ${plus.name}</li>`)
            .join("")}</ul>`;
        } else {
          elements.adventuringPlusesColumn.classList.add("hidden");
          elements.displayAdventuringPluses.textContent = "";
        }
      }

      elements.inputPower.value = baseStats.power;
      elements.inputDefense.value = baseStats.defense;
      elements.inputSpeed.value = baseStats.speed;
      elements.inputIntelligence.value = baseStats.intelligence;
      elements.inputStatusBurn.value = baseStats.status_burn;
      elements.inputStatusFreeze.value = baseStats.status_freeze;
      elements.inputStatusPoison.value = baseStats.status_poison;

      updateDerived(stats, gearBonus);
      renderGearSections(stats);
      renderAbilities();
      renderGearHistory();
      const hasTempBuffs = tempConsumableSummary.length > 0;
      if (elements.tempBuffSection) {
        elements.tempBuffSection.classList.toggle("hidden", !hasTempBuffs);
      }
      if (elements.tempBuffSummary) {
        elements.tempBuffSummary.textContent = hasTempBuffs
          ? `Active Temp Buffs: ${tempConsumableSummary.join(" | ")}`
          : "No active temporary consumable buffs.";
      }
      if (elements.clearTempBuffs) {
        elements.clearTempBuffs.classList.toggle("hidden", !hasTempBuffs);
      }
      updateGearGeneratorLuck(stats);
      const modTier = getGearModTier(baseStats);
      const tierInfo = gearModificationDiscountTiers.find(item => item.tier === modTier) || gearModificationDiscountTiers[0];
      if (elements.gearModTierLabel) {
        elements.gearModTierLabel.textContent = tierInfo.label;
      }
      if (elements.gearModDiscountLabel) {
        elements.gearModDiscountLabel.textContent = `${tierInfo.discount}%`;
      }
      if (elements.gearModTierSelect) {
        elements.gearModTierSelect.value = String(modTier);
      }
    }

    async function requireUser() {
      const { data: { user } } = await sb.auth.getUser();
      if (!user) {
        pushStatus("Not logged in.", { tone: "error" });
        throw new Error("No user");
      }
      return user;
    }

    function formatSaveTimestamp(date = new Date()) {
      return date.toLocaleString(undefined, {
        month: "short",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      });
    }

    function updateSaveStatus(label) {
      pushStatus(`${label} ${formatSaveTimestamp()}`, { tone: "success" });
    }

    function markDirty() {
      isDirty = true;
    }

    async function autoSaveCharacter() {
      if (!isDirty || isSaving) return;
      await saveCharacter({ mode: "auto" });
    }

    function startAutosave() {
      if (autosaveTimer) {
        clearInterval(autosaveTimer);
      }
      autosaveTimer = setInterval(autoSaveCharacter, 45000);
    }

    async function loadCharacter() {
      try {
        currentUser = await requireUser();
        const params = new URLSearchParams(window.location.search);
        const characterId = params.get("id");
        let query = sb
          .from("webrunning_characters")
          .select("id, name, base_stats, status_effects, notes, edit_history")
          .eq("user_id", currentUser.id);

        if (characterId) {
          query = query.eq("id", characterId);
        } else {
          query = query.order("created_at", { ascending: true }).limit(1);
        }

        const { data, error } = await query.maybeSingle();

        if (error) throw error;

        activeCharacter = data || {
          id: null,
          name: "",
          base_stats: { ...defaults },
          status_effects: null,
          edit_history: []
        };

        if (activeCharacter.status_effects) {
          activeCharacter.status_effects = normalizeStatusEffects(activeCharacter.status_effects);
        }
        if (activeCharacter.base_stats) {
          activeCharacter.base_stats = mergeStatusEffectsIntoStats(
            activeCharacter.base_stats,
            activeCharacter.status_effects
          );
        }

        editHistory = Array.isArray(activeCharacter.edit_history) ? activeCharacter.edit_history.map(normalizeHistoryRecord) : [];
        gearHistory = editHistory.filter(item => ["delete", "modify"].includes(item.type));

        elements.nameInput.value = activeCharacter.name || "";
        if (elements.notesInput) {
          elements.notesInput.value = activeCharacter.notes || "";
        }
        render();
        if (activeCharacter.id) {
          await loadCharacterGear();
        }
      } catch (e) {
        console.error(e);
        pushStatus("Failed to load character.", { tone: "error" });
      }
    }

    async function loadCharacterGear() {
      if (!activeCharacter?.id) return;
      try {
        const { data, error } = await sb
          .from("webrunning_character_gear")
          .select("gear_id, equipped, gear_slot, gear:webrunning_gear(*)")
          .eq("character_id", activeCharacter.id);
        if (error) throw error;
        characterGear = (data || []).map(row => ({
          gear_id: row.gear_id,
          equipped: row.equipped,
          gear_slot: row.gear_slot,
          gear: row.gear
        }));
        render();
      } catch (error) {
        console.error(error);
        pushStatus("Failed to load gear.", { tone: "error" });
      }
    }

    function readBaseStatsFromForm() {
      const stats = currentStats();
      stats.xp = Number(elements.inputXp.value) || 0;
      stats.essence = Number(elements.inputEssence.value) || 0;
      stats.current_hp = Number(elements.inputCurrentHp.value) || 0;
      stats.energy_red = Number(elements.inputEnergyRed.value) || 0;
      stats.energy_blue = Number(elements.inputEnergyBlue.value) || 0;
      stats.energy_gray = Number(elements.inputEnergyGray.value) || 0;
      stats.energy_green = Number(elements.inputEnergyGreen.value) || 0;
      stats.power = Number(elements.inputPower.value) || 0;
      stats.defense = Number(elements.inputDefense.value) || 0;
      stats.speed = Number(elements.inputSpeed.value) || 0;
      stats.intelligence = Number(elements.inputIntelligence.value) || 0;
      stats.status_burn = Number(elements.inputStatusBurn.value) || 0;
      stats.status_freeze = Number(elements.inputStatusFreeze.value) || 0;
      stats.status_poison = Number(elements.inputStatusPoison.value) || 0;
      return stats;
    }

    async function setGearModificationTier(tierValue) {
      if (!activeCharacter?.id || !currentUser?.id) return;
      const nextTier = Math.max(0, Math.min(5, Number(tierValue) || 0));
      const stats = currentStats();
      const currentTier = getGearModTier(stats);
      if (nextTier === currentTier) return;
      const updatedStats = { ...stats, gear_mod_discount_tier: nextTier };
      const { error } = await sb
        .from("webrunning_characters")
        .update({ base_stats: updatedStats })
        .eq("id", activeCharacter.id)
        .eq("user_id", currentUser.id);
      if (error) {
        if (elements.gearModUpgradeStatus) {
          elements.gearModUpgradeStatus.textContent = "Failed to update discount tier.";
        }
        if (elements.gearModTierSelect) {
          elements.gearModTierSelect.value = String(currentTier);
        }
        pushStatus("Failed to update gear modification discount tier.", { tone: "error" });
        return;
      }
      activeCharacter.base_stats = updatedStats;
      if (elements.gearModUpgradeStatus) {
        elements.gearModUpgradeStatus.textContent = `Discount tier set to ${gearModificationDiscountTiers[nextTier].label}.`;
      }
      pushStatus("Gear modification discount tier updated.", { tone: "success" });
      render();
    }

    async function saveCharacter({ mode = "manual" } = {}) {
      if (isSaving) return;
      const name = elements.nameInput.value.trim();
      if (!name) {
        if (mode === "manual") {
          pushStatus("Name cannot be empty.", { tone: "warning" });
        }
        return;
      }

      if (!/^[a-zA-Z0-9 _-]+$/.test(name)) {
        if (mode === "manual") {
          pushStatus("Invalid characters in name.", { tone: "warning" });
        }
        return;
      }

      try {
        isSaving = true;
        currentUser = await requireUser();
        const baseStats = readBaseStatsFromForm();
        const notes = elements.notesInput ? elements.notesInput.value.trim() : "";

        const previousName = activeCharacter?.name || "";
        const previousStats = activeCharacter?.base_stats ? cloneJson(activeCharacter.base_stats) : null;
        const previousNotes = activeCharacter?.notes || "";

        if (activeCharacter?.id) {
          const { error } = await sb
            .from("webrunning_characters")
            .update({
              name,
              base_stats: baseStats,
              status_effects: getStatusEffectsPayload(baseStats),
              notes,
              edit_history: editHistory
            })
            .eq("id", activeCharacter.id)
            .eq("user_id", currentUser.id);
          if (error) throw error;
        } else {
          const { data, error } = await sb
            .from("webrunning_characters")
            .insert({
              user_id: currentUser.id,
              name,
              base_stats: baseStats,
              status_effects: getStatusEffectsPayload(baseStats),
              notes,
              edit_history: editHistory
            })
            .select("id, name, base_stats, status_effects, notes, edit_history")
            .maybeSingle();
          if (error) throw error;
          activeCharacter = data;
          if (activeCharacter?.status_effects) {
            activeCharacter.status_effects = normalizeStatusEffects(activeCharacter.status_effects);
            activeCharacter.base_stats = mergeStatusEffectsIntoStats(
              activeCharacter.base_stats,
              activeCharacter.status_effects
            );
          }
        }

        if (activeCharacter?.id) {
          const changed = previousName !== name
            || JSON.stringify(previousStats || {}) !== JSON.stringify(baseStats)
            || previousNotes !== notes;
          if (changed) {
            await addEditHistoryRecord({
              type: "character_edit",
              label: "Character updated",
              details: [
                previousName !== name ? `Name: ${previousName || "(empty)"} → ${name}` : null,
                JSON.stringify(previousStats || {}) !== JSON.stringify(baseStats) ? "Core stats were updated." : null,
                previousNotes !== notes ? "Character notes were updated." : null
              ].filter(Boolean)
            });
          }
        }

        isDirty = false;
        activeCharacter.name = name;
        activeCharacter.base_stats = baseStats;
        activeCharacter.status_effects = getStatusEffectsPayload(baseStats);
        activeCharacter.notes = notes;
        activeCharacter.edit_history = editHistory;
        render();
        updateSaveStatus(mode === "auto" ? "Autosaved:" : "Saved:");
      } catch (e) {
        console.error(e);
        pushStatus(e.message, { tone: "error" });
      } finally {
        isSaving = false;
      }
    }

    function populateLevelSelect() {
      targetLevelSelect.innerHTML = "";
      const stats = currentStats();
      levelTable.forEach(entry => {
        const option = document.createElement("option");
        option.value = entry.level;
        option.textContent = entry.level === stats.level ? `Level ${entry.level} (Current)` : `Level ${entry.level}`;
        targetLevelSelect.appendChild(option);
      });
      targetLevelSelect.value = String(stats.level);
    }

    function getLevelEntry(level) {
      return levelTable.find(entry => entry.level === Number(level));
    }

    function calculatePointDelta(startLevel, targetLevel) {
      if (targetLevel === startLevel) return 0;
      const minLevel = Math.min(startLevel, targetLevel);
      const maxLevel = Math.max(startLevel, targetLevel);
      const points = levelTable
        .filter(entry => entry.level > minLevel && entry.level <= maxLevel)
        .reduce((sum, entry) => sum + (entry.statPoints || 0), 0);
      return targetLevel > startLevel ? points : -points;
    }

    function updateLevelPreview() {
      const stats = currentStats();
      const targetLevel = Number(targetLevelSelect.value);
      const entry = getLevelEntry(targetLevel);
      if (!entry) {
        levelPreview.innerHTML = "";
        return;
      }
      const pointDelta = calculatePointDelta(stats.level, targetLevel);
      const pointsLabel = pointDelta > 0
        ? "Stat Points to allocate"
        : pointDelta < 0
          ? "Stat Points to remove"
          : "Stat Points";
      const pointsValue = Math.abs(pointDelta);
      levelPreview.innerHTML = `
        <li>Level: ${stats.level} → ${entry.level}</li>
        <li>XP: ${stats.xp} (manual)</li>
        <li>Base HP: ${stats.hp} → ${entry.baseHp}</li>
        <li>Energy Cap: ${stats.energy_cap} → ${entry.energyCap}</li>
        <li>Kernel Slots: ${stats.kernel_slots} → ${entry.kernelSlots}</li>
        <li>Inventory Slots: ${stats.inventory_slots} → ${entry.inventorySlots}</li>
        <li>Luck: ${stats.luck} → ${entry.baseLuck}</li>
        <li>${pointsLabel}: ${pointsValue}</li>
      `;
      updateRemainingPoints(pointsValue);
    }

    function updateRemainingPoints(availablePoints) {
      const allocated =
        (Number(levelPower.value) || 0) +
        (Number(levelDefense.value) || 0) +
        (Number(levelSpeed.value) || 0) +
        (Number(levelIntelligence.value) || 0);
      pointsRemaining.textContent = Math.max(availablePoints - allocated, 0);
    }

    function resetLevelInputs() {
      levelPower.value = 0;
      levelDefense.value = 0;
      levelSpeed.value = 0;
      levelIntelligence.value = 0;
      levelError.textContent = "";
    }

    function openLevelModal() {
      populateLevelSelect();
      if (!targetLevelSelect.options.length) {
        pushStatus("No other levels available.", { tone: "warning" });
        return;
      }
      resetLevelInputs();
      updateLevelPreview();
      modal.classList.remove("hidden");
    }

    function closeLevelModal() {
      modal.classList.add("hidden");
    }

    function initCollapsibles() {
      document.querySelectorAll("[data-collapsible]").forEach(section => {
        const button = section.querySelector(".collapse-toggle");
        if (!button) return;
        const updateCollapseButton = collapsed => {
          button.innerHTML = collapsed
            ? '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><circle cx="12" cy="12" r="2.5"></circle></svg>'
            : '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg>';
          button.setAttribute("aria-label", collapsed ? "Show section" : "Hide section");
          button.setAttribute("title", collapsed ? "Show section" : "Hide section");
        };
        const isCollapsed = section.classList.contains("collapsed");
        updateCollapseButton(isCollapsed);
        button.addEventListener("click", () => {
          const nowCollapsed = section.classList.toggle("collapsed");
          updateCollapseButton(nowCollapsed);
        });
      });
    }

    async function applyLevelUp() {
      const stats = currentStats();
      const targetLevel = Number(targetLevelSelect.value);
      const entry = getLevelEntry(targetLevel);
      if (!entry) return;

      const pointDelta = calculatePointDelta(stats.level, targetLevel);
      const requiredPoints = Math.abs(pointDelta);
      const powerPoints = Number(levelPower.value) || 0;
      const defensePoints = Number(levelDefense.value) || 0;
      const speedPoints = Number(levelSpeed.value) || 0;
      const intelligencePoints = Number(levelIntelligence.value) || 0;
      const totalAllocated = powerPoints + defensePoints + speedPoints + intelligencePoints;

      if (totalAllocated !== requiredPoints) {
        levelError.textContent = pointDelta > 0
          ? "Allocate all available stat points before applying."
          : pointDelta < 0
            ? "Remove all required stat points before applying."
            : "No stat points are required for this level.";
        return;
      }

      if (
        pointDelta < 0 &&
        (stats.power - powerPoints < 0 ||
          stats.defense - defensePoints < 0 ||
          stats.speed - speedPoints < 0 ||
          stats.intelligence - intelligencePoints < 0)
      ) {
        levelError.textContent = "Cannot remove more stat points than you currently have.";
        return;
      }

      const updatedStats = {
        ...stats,
        level: entry.level,
        hp: entry.baseHp,
        energy_cap: entry.energyCap,
        kernel_slots: entry.kernelSlots,
        inventory_slots: entry.inventorySlots,
        luck: entry.baseLuck,
        power: stats.power + (pointDelta >= 0 ? powerPoints : -powerPoints),
        defense: stats.defense + (pointDelta >= 0 ? defensePoints : -defensePoints),
        speed: stats.speed + (pointDelta >= 0 ? speedPoints : -speedPoints),
        intelligence: stats.intelligence + (pointDelta >= 0 ? intelligencePoints : -intelligencePoints)
      };
      updatedStats.current_hp = Math.min(updatedStats.current_hp ?? updatedStats.hp, updatedStats.hp);

      try {
        currentUser = await requireUser();
        if (!activeCharacter?.id) {
          levelError.textContent = "Save the character before leveling up.";
          return;
        }
        const { error } = await sb
          .from("webrunning_characters")
          .update({ base_stats: updatedStats })
          .eq("id", activeCharacter.id)
          .eq("user_id", currentUser.id);
        if (error) throw error;

        activeCharacter.base_stats = updatedStats;
        render();
        closeLevelModal();
      } catch (e) {
        console.error(e);
        levelError.textContent = e.message;
      }
    }

    [
      elements.inputXp,
      elements.inputEssence,
      elements.inputCurrentHp,
      elements.inputEnergyRed,
      elements.inputEnergyBlue,
      elements.inputEnergyGreen,
      elements.inputEnergyGray,
      elements.inputPower,
      elements.inputDefense,
      elements.inputSpeed,
      elements.inputIntelligence,
      elements.inputStatusBurn,
      elements.inputStatusFreeze,
      elements.inputStatusPoison
    ]
      .forEach(input => {
        input.addEventListener("input", () => {
          markDirty();
          const stats = readBaseStatsFromForm();
          if (activeCharacter) {
            activeCharacter.base_stats = stats;
          }
          render();
        });
      });

    [levelPower, levelDefense, levelSpeed, levelIntelligence].forEach(input => {
      input.addEventListener("input", () => {
        const stats = currentStats();
        const targetLevel = Number(targetLevelSelect.value);
        const pointDelta = calculatePointDelta(stats.level, targetLevel);
        updateRemainingPoints(Math.abs(pointDelta));
      });
    });

    targetLevelSelect.addEventListener("change", () => {
      resetLevelInputs();
      updateLevelPreview();
    });

    document.getElementById("levelUpButton").addEventListener("click", openLevelModal);
    document.getElementById("confirmLevelUp").addEventListener("click", applyLevelUp);
    document.getElementById("cancelLevelUp").addEventListener("click", closeLevelModal);
    modalBackdrop.addEventListener("click", closeLevelModal);
    elements.saveButton.addEventListener("click", saveCharacter);
    elements.nameInput.addEventListener("input", markDirty);
    if (elements.notesInput) {
      elements.notesInput.addEventListener("input", () => {
        markDirty();
        if (activeCharacter) {
          activeCharacter.notes = elements.notesInput.value;
        }
      });
    }

    elements.openGearGenerator.addEventListener("click", openGearGeneratorModal);
    closeGearGenerator.addEventListener("click", closeGearGeneratorModal);
    gearGeneratorBackdrop.addEventListener("click", closeGearGeneratorModal);
    generateGearButton.addEventListener("click", handleGenerateGear);
    addAllGeneratedGearButton.addEventListener("click", addAllGeneratedGear);
    gearBonusLuck.addEventListener("input", () => {
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const hasTempBuffs = tempConsumableSummary.length > 0;
      if (elements.tempBuffSection) {
        elements.tempBuffSection.classList.toggle("hidden", !hasTempBuffs);
      }
      if (elements.tempBuffSummary) {
        elements.tempBuffSummary.textContent = hasTempBuffs
          ? `Active Temp Buffs: ${tempConsumableSummary.join(" | ")}`
          : "No active temporary consumable buffs.";
      }
      if (elements.clearTempBuffs) {
        elements.clearTempBuffs.classList.toggle("hidden", !hasTempBuffs);
      }
      updateGearGeneratorLuck(stats);
    });
    addPastedGear.addEventListener("click", addPastedGearFromJson);
    addManualGearButton.addEventListener("click", handleManualGearAdd);
    addManualGearStat.addEventListener("click", () => createManualStatRow());
    addManualGearAbility.addEventListener("click", () => createManualAbilityRow());
    manualGearType.addEventListener("change", refreshManualStatRowsForType);

    [
      gearSortField,
      gearSortDirection,
      gearFilterRarity,
      gearFilterType,
      gearFilterColor,
      gearFilterStat,
      gearFilterFreeSlot,
      localGearFilterRarity,
      localGearFilterType,
      localGearFilterColor,
      localGearFilterStat,
      localGearFilterFreeSlot
    ]
      .forEach(select => {
        if (!select) return;
        select.addEventListener("change", () => {
          const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
          renderGearSections(stats);
        });
      });

    generatedGearList.addEventListener("click", event => {
      const button = event.target.closest("button");
      if (!button) return;
      const action = button.dataset.action;
      const index = Number(button.dataset.index);
      if (action === "add") {
        addGeneratedGear(index, "add");
      } else if (action === "equip") {
        addGeneratedGear(index, "equip");
      } else if (action === "remove") {
        if (!Number.isFinite(index)) return;
        removeGeneratedGearFromCharacter(generatedGear[index]);
      }
    });

    function handleGearListClick(event) {
      const button = event.target.closest("button");
      if (!button) return;
      const action = button.dataset.action;
      const gearId = button.dataset.gear;
      if (!action || !gearId) return;
      const entry = findGearEntry(gearId);
      if (!entry) return;
      if (action === "view") {
        openGearDetailModal(entry);
      } else if (action === "equip") {
        equipGear(entry);
      } else if (action === "use") {
        useConsumable(entry);
      } else if (action === "unequip" || action === "inventory") {
        moveGearToInventory(entry);
      } else if (action === "local") {
        moveGearToLocalNode(entry);
      } else if (action === "modify") {
        openGearModificationModal({ source: "list", entry });
      } else if (action === "dissolve") {
        activeGearRow = entry;
        deleteGear({ mode: "dissolve" });
      } else if (action === "delete") {
        activeGearRow = entry;
        deleteGear({ mode: "delete" });
      }
    }

    elements.equippedSlots.addEventListener("click", handleGearListClick);
    elements.inventorySlots.addEventListener("click", handleGearListClick);
    elements.localNodeSlots.addEventListener("click", handleGearListClick);

    if (elements.clearTempBuffs) {
      elements.clearTempBuffs.addEventListener("click", () => {
        tempConsumableBonus = createEmptyBonus();
        tempConsumableSummary = [];
        pushStatus("Temporary consumable buffs cleared.", { tone: "success" });
        render();
      });
    }
    if (elements.abilitiesList) {
      const closeAbilityDropdowns = (exception = null) => {
        elements.abilitiesList.querySelectorAll(".ability-dropdown.is-open").forEach(dropdown => {
          if (dropdown === exception) return;
          dropdown.classList.remove("is-open");
          const toggle = dropdown.querySelector(".ability-summary");
          const details = dropdown.querySelector(".ability-details");
          if (toggle) {
            toggle.setAttribute("aria-expanded", "false");
          }
          if (details) {
            details.hidden = true;
          }
        });
      };

      elements.abilitiesList.addEventListener("click", event => {
        const target = event.target instanceof Element ? event.target : null;
        const button = target ? target.closest(".ability-summary") : null;
        if (!button) return;
        const dropdown = button.closest(".ability-dropdown");
        if (!dropdown) return;
        const isOpen = !dropdown.classList.contains("is-open");
        closeAbilityDropdowns(dropdown);
        const details = dropdown.querySelector(".ability-details");
        dropdown.classList.toggle("is-open", isOpen);
        button.setAttribute("aria-expanded", String(isOpen));
        if (details) {
          details.hidden = !isOpen;
        }
      });

      document.addEventListener("click", event => {
        if (!elements.abilitiesList.contains(event.target)) {
          closeAbilityDropdowns();
        }
      });

      document.addEventListener("keydown", event => {
        if (event.key === "Escape") {
          closeAbilityDropdowns();
        }
      });
    }

    closeGearDetail.addEventListener("click", closeGearDetailModal);
    gearDetailBackdrop.addEventListener("click", closeGearDetailModal);
    saveGearName.addEventListener("click", saveGearNameUpdate);
    gearNameInput.addEventListener("change", saveGearNameUpdate);
    gearNameInput.addEventListener("blur", saveGearNameUpdate);
    gearNotesInput.addEventListener("change", saveGearNameUpdate);
    gearNotesInput.addEventListener("blur", saveGearNameUpdate);
    copyGearJson.addEventListener("click", copyGearJsonToClipboard);
    openGearDetailModify.addEventListener("click", () => {
      if (!activeGearRow) return;
      openGearModificationModal({ source: "detail", entry: activeGearRow });
    });
    deleteGearButton.addEventListener("click", () => deleteGear({ mode: "delete" }));
    dissolveGearButton.addEventListener("click", () => deleteGear({ mode: "dissolve" }));

    if (elements.deletedGearHistory) {
      elements.deletedGearHistory.addEventListener("click", event => {
        const button = event.target.closest("button");
        if (!button) return;
        const action = button.dataset.action;
        if (action !== "undo-history") return;
        const recordId = button.dataset.record;
        undoGearHistory(recordId);
      });
    }

    elements.openGearModificationHub?.addEventListener("click", () => openGearModificationModal({ source: "hub" }));
    elements.gearModTierSelect?.addEventListener("change", event => {
      setGearModificationTier(event.target.value);
    });
    gearModificationBackdrop?.addEventListener("click", closeGearModificationModal);
    closeGearModification?.addEventListener("click", closeGearModificationModal);
    gearModificationBack?.addEventListener("click", () => {
      if (selectedModificationType) {
        renderGearModificationSelection();
      } else if (gearModificationSource === "detail") {
        closeGearModificationModal();
      }
    });
    gearModificationUndo?.addEventListener("click", async () => {
      if (!pendingModificationRecord) return;
      await undoGearHistory(pendingModificationRecord.id);
      pendingModificationRecord = null;
      renderGearModificationSelection();
    });
    gearModificationDetails?.addEventListener("click", () => {
      if (!pendingModificationRecord) return;
      activeGearRow = findGearEntry(pendingModificationRecord.entry?.gear_id) || activeGearRow;
      pendingModificationRecord = null;
      closeGearModificationModal();
      if (activeGearRow) openGearDetailModal(activeGearRow);
    });
    gearModificationBody?.addEventListener("click", async event => {
      const modApplyButton = event.target.closest("button[data-mod-apply]");
      if (modApplyButton) {
        applyGearModification(modApplyButton.dataset.modApply);
        return;
      }
      const button = event.target.closest("button[data-mod-choice]");
      if (!button) return;
      const choice = button.dataset.modChoice;
      if (choice === "root") {
        renderGearModificationSelection();
        return;
      }
      renderGearModificationDetail(choice);
    });

    window.addEventListener("DOMContentLoaded", () => {
      populateGearFilterSelects();
      if (elements.gearModTierSelect) {
        elements.gearModTierSelect.innerHTML = gearModificationDiscountTiers
          .map(item => `<option value="${item.tier}">Tier ${item.label} (${item.discount}% off)</option>` )
          .join("");
      }
      if (manualGearStatsList && !manualGearStatsList.children.length) {
        createManualStatRow();
      }
      if (manualGearAbilitiesList && !manualGearAbilitiesList.children.length) {
        createManualAbilityRow();
      }
      loadCharacter();
      initCollapsibles();
      startAutosave();
      ensurePyodide().catch(() => {});
    });
  </script>
</body>
</html>
