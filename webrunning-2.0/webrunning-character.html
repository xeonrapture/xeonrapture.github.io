<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Webrunning Character Sheet</title>
  <link rel="stylesheet" href="/shared/style.css">
</head>
<body class="wr-scope">
  <div id="nav"></div>

  <main class="wrap sheet">
    <header>
      <a href="/webrunning-2.0/webrunning-character-manager.html" aria-label="Back to character manager">← Back to Character Manager</a>
      <h1>Webrunning Character Sheet</h1>
      <p>Use this page to track your character stats, gear, and progression.</p>
    </header>

    <section class="card">
      <h2>Character</h2>
      <div class="sheet-actions">
        <label>
          <span class="muted">Character Name</span>
          <input id="characterName" type="text" maxlength="32" placeholder="Character name" />
        </label>
        <button id="saveCharacter" type="button">Save Character</button>
        <button id="levelUpButton" type="button">Level Up</button>
      </div>
    </section>

    <section class="card">
      <h2>Core Info</h2>
      <div class="stats-grid core-info">
        <dl>
          <dt>Name:</dt>
          <dd id="displayName"></dd>
          <dt>Level:</dt>
          <dd id="displayLevel">1</dd>
          <dt>XP:</dt>
          <dd>
            <input id="inputXp" type="number" min="0" value="0" />
          </dd>
          <dt>Luck:</dt>
          <dd id="displayLuck">1</dd>
        </dl>
        <dl>
          <dt>Max HP:</dt>
          <dd id="displayHp">10</dd>
          <dt>Current HP:</dt>
          <dd>
            <input id="inputCurrentHp" type="number" min="0" value="10" />
          </dd>
          <dt>Energy Cap:</dt>
          <dd id="displayEnergyCap">5</dd>
          <dt>Essence:</dt>
          <dd>
            <input id="inputEssence" type="number" min="0" value="0" />
          </dd>
        </dl>
      </div>
      <div class="stat-inputs" style="margin-top: 0.75rem;">
        <label>Energy (Red)
          <input id="inputEnergyRed" type="number" min="0" value="0" />
        </label>
        <label>Energy (Blue)
          <input id="inputEnergyBlue" type="number" min="0" value="0" />
        </label>
        <label>Energy (Green)
          <input id="inputEnergyGreen" type="number" min="0" value="0" />
        </label>
        <label>Energy (Gray)
          <input id="inputEnergyGray" type="number" min="0" value="0" />
        </label>
      </div>
    </section>

    <section class="card">
      <h2>Basic Stats</h2>
      <div class="stat-inputs">
        <label>Power
          <input id="inputPower" type="number" min="0" value="0" />
        </label>
        <label>Defense
          <input id="inputDefense" type="number" min="0" value="0" />
        </label>
        <label>Speed
          <input id="inputSpeed" type="number" min="0" value="0" />
        </label>
        <label>Intelligence
          <input id="inputIntelligence" type="number" min="0" value="0" />
        </label>
      </div>
    </section>

    <section class="card">
      <h2>Status Effects</h2>
      <div class="stat-inputs">
        <label>Burn
          <input id="inputStatusBurn" type="number" min="0" value="0" />
        </label>
        <label>Freeze
          <input id="inputStatusFreeze" type="number" min="0" value="0" />
        </label>
        <label>Poison
          <input id="inputStatusPoison" type="number" min="0" value="0" />
        </label>
      </div>
      <br>
      <div class="stats-grid">
        <dl>
          <dt>Damage Taken Modifier:</dt>
          <dd id="displayDamageTaken">+0</dd>
          <dt>Defense DC Modifier:</dt>
          <dd id="displayStatusDefenseDc">+0</dd>
          <dt>Armor Modifier:</dt>
          <dd id="displayStatusArmor">+0</dd>
          <dt>Attack Plus Modifier:</dt>
          <dd id="displayStatusAttackPlus">+0</dd>
          <dt>Damage Plus Modifier:</dt>
          <dd id="displayStatusDamagePlus">+0</dd>
        </dl>
      </div>
    </section>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>Secondary Stats</h2>
        <button class="collapse-toggle" type="button">Hide</button>
      </div>
      <div class="collapsible-body">
        <p class="muted">Tied to Basic Stats and increased by equipping gear.</p>
        <div class="stats-grid">
          <dl>
            <dt>Attack Plus:</dt>
            <dd id="displayAttackPlus">0</dd>
            <dt>Damage Plus:</dt>
            <dd id="displayDamagePlus">0</dd>
            <dt>Defense DC:</dt>
            <dd id="displayDefenseDc">10</dd>
            <dt>Armor:</dt>
            <dd id="displayArmor">0</dd>
            <dt>Initiative:</dt>
            <dd id="displayInitiative">0</dd>
            <dt>Movement Speed:</dt>
            <dd id="displayMovementSpeed">10</dd>
            <dt>Range:</dt>
            <dd id="displayRange">5</dd>
            <dt>Perception:</dt>
            <dd id="displayPerception">0</dd>
            <dt>AOE Range:</dt>
            <dd id="displayAoeRange">0</dd>
            <dt>Hacking:</dt>
            <dd id="displayHacking">0</dd>
          </dl>
        </div>
      </div>
    </section>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>Neutral Buffs</h2>
        <button class="collapse-toggle" type="button">Hide</button>
      </div>
      <div class="collapsible-body">
        <div class="stats-grid">
          <dl>
            <dt>Inventory Slots:</dt>
            <dd id="displayInventorySlots">10</dd>
            <dt>Kernel Slots:</dt>
            <dd id="displayKernelSlots">1</dd>
            <dt>Energy Conversion:</dt>
            <dd>0</dd>
            <dt>Group XP Gain:</dt>
            <dd>0</dd>
            <dt>HP Regen:</dt>
            <dd>0</dd>
            <dt>Resell Value:</dt>
            <dd>0</dd>
          </dl>
        </div>
      </div>
    </section>

    <section class="card">
      <h2>Gear Generator</h2>
      <p class="muted">Generate gear with your current luck plus a bonus and add it to your inventory or equip it.</p>
      <div class="gear-generator-actions">
        <button id="openGearGenerator" type="button" class="hidden">Generate Gear</button>
        <span id="gearGeneratorStatus" class="mono muted"></span>
      </div>
    </section>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>Gear Slots</h2>
        <button class="collapse-toggle" type="button">Hide</button>
      </div>
      <div class="collapsible-body">
        <div id="equippedSlots" class="gear-grid"></div>
      </div>
    </section>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>Inventory Slots</h2>
        <button class="collapse-toggle" type="button">Hide</button>
      </div>
        <div class="collapsible-body">
        <div class="gear-controls">
          <div class="gear-controls-section">
            <div class="gear-controls-row">
              <label>
                Sort By
                <select id="gearSortField">
                  <option value="rarity">Rarity</option>
                  <option value="type">Gear Type</option>
                  <option value="color">Color</option>
                  <option value="name">Name</option>
                </select>
              </label>
              <label>
                Direction
                <select id="gearSortDirection">
                  <option value="asc">Ascending</option>
                  <option value="desc">Descending</option>
                </select>
              </label>
            </div>
          </div>
          <div class="gear-controls-divider" role="presentation"></div>
          <div class="gear-controls-section">
            <div class="gear-controls-row">
              <label>
                Filter Rarity
                <select id="gearFilterRarity">
                  <option value="">All</option>
                </select>
              </label>
              <label>
                Filter Gear Type
                <select id="gearFilterType">
                  <option value="">All</option>
                </select>
              </label>
              <label>
                Filter Color
                <select id="gearFilterColor">
                  <option value="">All</option>
                </select>
              </label>
            </div>
            <div class="gear-controls-row">
              <label>
                Filter Stat Modified
                <select id="gearFilterStat">
                  <option value="">All</option>
                </select>
              </label>
            </div>
            <span class="muted">Filters apply to inventory and local node storage.</span>
          </div>
        </div>
        <div class="slot-count">Slots used: <span id="inventorySlotCount">0/0</span></div>
        <div id="inventorySlots" class="gear-grid"></div>
      </div>
    </section>

    <section class="card collapsible collapsed" data-collapsible>
      <div class="collapsible-header">
        <h2>Local Node Storage</h2>
        <button class="collapse-toggle" type="button">Show</button>
      </div>
      <div class="collapsible-body">
        <p class="muted">Stored and can only be accessed in your local node.</p>
        <div class="slot-count">Slots used: <span id="localNodeSlotCount">0/0</span></div>
        <div id="localNodeSlots" class="gear-grid"></div>
      </div>
    </section>

    <section class="card">
      <h2>Abilities</h2>
      <div id="abilitiesList" class="ability-section"></div>
    </section>

    <section class="card">
      <h2>Deleted Gear History</h2>
      <div id="deletedGearHistory" class="deletion-history"></div>
    </section>

    <section class="card notes-area">
      <h2>Character Notes</h2>
      <textarea id="characterNotes" placeholder="Add notes about your character, gear, or story beats..."></textarea>
    </section>
  </main>

  <div id="levelupModal" class="xr-modal hidden">
    <div class="xr-modal-backdrop"></div>
    <div class="xr-modal-card">
      <h2>Level Up</h2>
      <div class="modal-grid">
        <label>
          Target Level
          <select id="targetLevel"></select>
        </label>
        <div class="level-preview">
          <strong>Preview</strong>
          <ul id="levelPreview"></ul>
        </div>
        <div>
          <strong>Add Stat Points </strong>
          <div class="stat-inputs">
            <label>Power
              <input id="levelPower" type="number" min="0" value="0" />
            </label>
            <label>Defense
              <input id="levelDefense" type="number" min="0" value="0" />
            </label>
            <label>Speed
              <input id="levelSpeed" type="number" min="0" value="0" />
            </label>
            <label>Intelligence
              <input id="levelIntelligence" type="number" min="0" value="0" />
            </label>
          </div>
          <p class="muted">Points remaining: <span id="pointsRemaining">0</span></p>
          <p class="muted"><br>(these points subtract when levelling down)</p>
        </div>
        <div id="levelError" class="mono muted"></div>
      </div>
      <div class="xr-modal-actions">
        <button id="confirmLevelUp" type="button">Apply Level</button>
        <button id="cancelLevelUp" type="button">Cancel</button>
      </div>
    </div>
  </div>

  <div id="gearGeneratorModal" class="xr-modal hidden">
    <div class="xr-modal-backdrop"></div>
    <div class="xr-modal-card">
      <h2>Generate Gear</h2>
      <div class="modal-grid">
        <label>
          Bonus Luck
          <input id="gearBonusLuck" type="number" min="0" value="0" />
        </label>
        <label>
          Pieces
          <input id="gearAmount" type="number" min="1" value="1" />
        </label>
        <label>
          Gear Type
          <select id="gearTypeNumber">
            <option value="0">Random (None)</option>
            <option value="1">One-Handed Weapon</option>
            <option value="2">Two-Handed Weapon</option>
            <option value="3">Head</option>
            <option value="4">Torso</option>
            <option value="5">Hands</option>
            <option value="6">Legs</option>
            <option value="7">Feet</option>
            <option value="8">Ring</option>
            <option value="9">Neck</option>
            <option value="10">Kernel</option>
            <option value="12">Bauble</option>
          </select>
        </label>
        <label>
          Rarity
          <select id="gearRarity">
            <option value="">Random (None)</option>
            <option value="Common">Common</option>
            <option value="Uncommon">Uncommon</option>
            <option value="Rare">Rare</option>
            <option value="Epic">Epic</option>
            <option value="Legendary">Legendary</option>
          </select>
        </label>
        <label>
          Color
          <select id="gearColor">
            <option value="">Random (None)</option>
            <option value="Neutral">Neutral</option>
            <option value="Red">Red</option>
            <option value="Blue">Blue</option>
            <option value="Green">Green</option>
            <option value="Gray">Gray</option>
          </select>
        </label>
        <label>
          Color 2
          <select id="gearColor2">
            <option value="">None</option>
            <option value="Neutral">Neutral</option>
            <option value="Red">Red</option>
            <option value="Blue">Blue</option>
            <option value="Green">Green</option>
            <option value="Gray">Gray</option>
          </select>
        </label>
        <div class="muted">Total luck used: <span id="gearTotalLuck">0</span></div>
      </div>
      <div class="xr-modal-actions">
        <button id="generateGear" type="button">Generate</button>
        <button id="addAllGeneratedGear" type="button" disabled>Add All to Inventory</button>
        <button id="closeGearGenerator" type="button">Close</button>
      </div>
      <div class="gear-details-list" style="margin-top:1rem;">
        <strong>Generated Gear</strong>
        <div id="generatedGearList" class="gear-grid"></div>
      </div>
      <details class="manual-gear-section">
        <summary>Generate Gear Manually</summary>
        <div class="manual-gear-grid">
          <label>
            Gear Name
            <input id="manualGearName" type="text" maxlength="60" placeholder="Optional custom name" />
          </label>
          <label>
            Gear Type
            <select id="manualGearType">
              <option value="One-Handed Weapon">One-Handed Weapon</option>
              <option value="Two-Handed Weapon">Two-Handed Weapon</option>
              <option value="Head">Head</option>
              <option value="Torso">Torso</option>
              <option value="Hands">Hands</option>
              <option value="Legs">Legs</option>
              <option value="Feet">Feet</option>
              <option value="Ring">Ring</option>
              <option value="Neck">Neck</option>
              <option value="Kernel">Kernel</option>
              <option value="Consumable">Consumable</option>
              <option value="Bauble">Bauble</option>
            </select>
          </label>
          <label>
            Rarity
            <select id="manualGearRarity">
              <option value="Basic">Basic</option>
              <option value="Common">Common</option>
              <option value="Uncommon">Uncommon</option>
              <option value="Rare">Rare</option>
              <option value="Epic">Epic</option>
              <option value="Legendary">Legendary</option>
            </select>
          </label>
          <label>
            Color
            <select id="manualGearColor">
              <option value="Neutral">Neutral</option>
              <option value="Red">Red</option>
              <option value="Blue">Blue</option>
              <option value="Green">Green</option>
              <option value="Gray">Gray</option>
            </select>
          </label>
          <label>
            Color 2
            <select id="manualGearColor2">
              <option value="">None</option>
              <option value="Neutral">Neutral</option>
              <option value="Red">Red</option>
              <option value="Blue">Blue</option>
              <option value="Green">Green</option>
              <option value="Gray">Gray</option>
            </select>
          </label>
          <label>
            Item Type
            <input id="manualGearItemType" type="text" placeholder="e.g. Laser Dagger" />
          </label>
          <label>
            Aesthetic
            <input id="manualGearAesthetic" type="text" placeholder="Optional aesthetic detail" />
          </label>
          <label>
            Essence Value
            <input id="manualGearEssence" type="number" min="0" value="0" />
          </label>
          <label>
            Credit Value
            <input id="manualGearCredit" type="number" min="0" value="0" />
          </label>
        </div>
        <div>
          <strong>Stat Modifiers</strong>
          <div id="manualGearStatsList" class="manual-gear-list"></div>
          <button id="addManualGearStat" type="button">+ Add Stat</button>
        </div>
        <div>
          <strong>Abilities</strong>
          <div id="manualGearAbilitiesList" class="manual-gear-list"></div>
          <button id="addManualGearAbility" type="button">+ Add Ability</button>
        </div>
        <div class="manual-gear-actions">
          <button id="addManualGear" type="button">Add Manual Gear</button>
          <span id="manualGearStatus" class="mono muted"></span>
        </div>
      </details>
      <div class="paste-area" style="margin-top:1rem;">
        <strong>Paste Gear JSON</strong>
        <textarea id="gearPasteInput" placeholder="Paste gear JSON here"></textarea>
        <div class="gear-generator-actions">
          <button id="addPastedGear" type="button">Add Pasted Gear</button>
          <span id="pasteStatus" class="mono muted"></span>
        </div>
      </div>
    </div>
  </div>

  <div id="gearDetailModal" class="xr-modal hidden">
    <div class="xr-modal-backdrop"></div>
    <div class="xr-modal-card">
      <h2 id="gearDetailTitle">Gear Details</h2>
      <div class="modal-grid">
        <label>
          Gear Name
          <input id="gearNameInput" type="text" maxlength="60" />
        </label>
        <div id="gearDetailBody" class="gear-details-list"></div>
      </div>
      <div class="gear-modal-actions">
        <button id="closeGearDetail" type="button">Close</button>
        <div class="right-actions">
          <button id="copyGearJson" type="button">Copy JSON</button>
          <button id="saveGearName" type="button">Save Name</button>
          <button id="deleteGear" type="button">Delete Gear</button>
          <button id="dissolveGear" type="button">Dissolve into Essence</button>
        </div>
      </div>
      <div id="gearDetailStatus" class="mono muted"></div>
    </div>
  </div>

  <div id="statusPopup" class="status-popup" aria-live="polite"></div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="/shared/auth.js"></script>
  <script src="/shared/nav.js"></script>
  <script>
    const sb = window.supabaseClient;
    const levelTable = [
      { level: 1, xp: 0, baseHp: 5, statPoints: 3, energyCap: 5, kernelSlots: 1, inventorySlots: 10, baseLuck: 1 },
      { level: 2, xp: 10, baseHp: 10, statPoints: 0, energyCap: 5, kernelSlots: 1, inventorySlots: 12, baseLuck: 2 },
      { level: 3, xp: 20, baseHp: 15, statPoints: 1, energyCap: 6, kernelSlots: 2, inventorySlots: 14, baseLuck: 3 },
      { level: 4, xp: 35, baseHp: 20, statPoints: 0, energyCap: 6, kernelSlots: 2, inventorySlots: 16, baseLuck: 4 },
      { level: 5, xp: 55, baseHp: 25, statPoints: 1, energyCap: 7, kernelSlots: 3, inventorySlots: 18, baseLuck: 5 },
      { level: 6, xp: 80, baseHp: 30, statPoints: 0, energyCap: 7, kernelSlots: 3, inventorySlots: 20, baseLuck: 6 },
      { level: 7, xp: 110, baseHp: 35, statPoints: 1, energyCap: 8, kernelSlots: 4, inventorySlots: 22, baseLuck: 7 },
      { level: 8, xp: 150, baseHp: 40, statPoints: 0, energyCap: 8, kernelSlots: 4, inventorySlots: 24, baseLuck: 8 },
      { level: 9, xp: 200, baseHp: 45, statPoints: 1, energyCap: 9, kernelSlots: 5, inventorySlots: 26, baseLuck: 9 },
      { level: 10, xp: 260, baseHp: 50, statPoints: 0, energyCap: 10, kernelSlots: 5, inventorySlots: 30, baseLuck: 10 }
    ];

    const defaults = {
      level: 1,
      xp: 0,
      luck: 1,
      hp: 5,
      current_hp: 5,
      essence: 0,
      power: 0,
      defense: 0,
      speed: 0,
      intelligence: 0,
      inventory_slots: 10,
      kernel_slots: 1,
      energy_cap: 5,
      energy_red: 0,
      energy_blue: 0,
      energy_gray: 0,
      energy_green: 0,
      status_burn: 0,
      status_freeze: 0,
      status_poison: 0
    };

    const statusEffectDefaults = {
      burn: 0,
      freeze: 0,
      poison: 0
    };

    let currentUser = null;
    let activeCharacter = null;
    let isDirty = false;
    let isSaving = false;
    let autosaveTimer = null;
    let characterGear = [];
    let generatedGear = [];
    let activeGearRow = null;
    let pyodideClient = null;
    let pyodideReady = false;

    const elements = {
      nameInput: document.getElementById("characterName"),
      saveButton: document.getElementById("saveCharacter"),
      displayName: document.getElementById("displayName"),
      displayLevel: document.getElementById("displayLevel"),
      displayLuck: document.getElementById("displayLuck"),
      displayHp: document.getElementById("displayHp"),
      displayEnergyCap: document.getElementById("displayEnergyCap"),
      inputXp: document.getElementById("inputXp"),
      inputEssence: document.getElementById("inputEssence"),
      inputCurrentHp: document.getElementById("inputCurrentHp"),
      inputEnergyRed: document.getElementById("inputEnergyRed"),
      inputEnergyBlue: document.getElementById("inputEnergyBlue"),
      inputEnergyGray: document.getElementById("inputEnergyGray"),
      inputEnergyGreen: document.getElementById("inputEnergyGreen"),
      inputPower: document.getElementById("inputPower"),
      inputDefense: document.getElementById("inputDefense"),
      inputSpeed: document.getElementById("inputSpeed"),
      inputIntelligence: document.getElementById("inputIntelligence"),
      inputStatusBurn: document.getElementById("inputStatusBurn"),
      inputStatusFreeze: document.getElementById("inputStatusFreeze"),
      inputStatusPoison: document.getElementById("inputStatusPoison"),
      displayAttackPlus: document.getElementById("displayAttackPlus"),
      displayDamagePlus: document.getElementById("displayDamagePlus"),
      displayDefenseDc: document.getElementById("displayDefenseDc"),
      displayArmor: document.getElementById("displayArmor"),
      displayDamageTaken: document.getElementById("displayDamageTaken"),
      displayStatusDefenseDc: document.getElementById("displayStatusDefenseDc"),
      displayStatusArmor: document.getElementById("displayStatusArmor"),
      displayStatusAttackPlus: document.getElementById("displayStatusAttackPlus"),
      displayStatusDamagePlus: document.getElementById("displayStatusDamagePlus"),
      displayInitiative: document.getElementById("displayInitiative"),
      displayMovementSpeed: document.getElementById("displayMovementSpeed"),
      displayRange: document.getElementById("displayRange"),
      displayPerception: document.getElementById("displayPerception"),
      displayAoeRange: document.getElementById("displayAoeRange"),
      displayHacking: document.getElementById("displayHacking"),
      displayInventorySlots: document.getElementById("displayInventorySlots"),
      displayKernelSlots: document.getElementById("displayKernelSlots"),
      equippedSlots: document.getElementById("equippedSlots"),
      inventorySlots: document.getElementById("inventorySlots"),
      localNodeSlots: document.getElementById("localNodeSlots"),
      inventorySlotCount: document.getElementById("inventorySlotCount"),
      localNodeSlotCount: document.getElementById("localNodeSlotCount"),
      abilitiesList: document.getElementById("abilitiesList"),
      openGearGenerator: document.getElementById("openGearGenerator"),
      gearGeneratorStatus: document.getElementById("gearGeneratorStatus"),
      statusPopup: document.getElementById("statusPopup"),
      deletedGearHistory: document.getElementById("deletedGearHistory"),
      notesInput: document.getElementById("characterNotes")
    };

    const modal = document.getElementById("levelupModal");
    const modalBackdrop = modal.querySelector(".xr-modal-backdrop");
    const targetLevelSelect = document.getElementById("targetLevel");
    const levelPreview = document.getElementById("levelPreview");
    const levelPower = document.getElementById("levelPower");
    const levelDefense = document.getElementById("levelDefense");
    const levelSpeed = document.getElementById("levelSpeed");
    const levelIntelligence = document.getElementById("levelIntelligence");
    const pointsRemaining = document.getElementById("pointsRemaining");
    const levelError = document.getElementById("levelError");

    const gearGeneratorModal = document.getElementById("gearGeneratorModal");
    const gearGeneratorBackdrop = gearGeneratorModal.querySelector(".xr-modal-backdrop");
    const gearBonusLuck = document.getElementById("gearBonusLuck");
    const gearAmount = document.getElementById("gearAmount");
    const gearTypeNumber = document.getElementById("gearTypeNumber");
    const gearRarity = document.getElementById("gearRarity");
    const gearColor = document.getElementById("gearColor");
    const gearColor2 = document.getElementById("gearColor2");
    const gearTotalLuck = document.getElementById("gearTotalLuck");
    const generateGearButton = document.getElementById("generateGear");
    const addAllGeneratedGearButton = document.getElementById("addAllGeneratedGear");
    const closeGearGenerator = document.getElementById("closeGearGenerator");
    const generatedGearList = document.getElementById("generatedGearList");
    const gearPasteInput = document.getElementById("gearPasteInput");
    const addPastedGear = document.getElementById("addPastedGear");
    const pasteStatus = document.getElementById("pasteStatus");
    const manualGearName = document.getElementById("manualGearName");
    const manualGearType = document.getElementById("manualGearType");
    const manualGearRarity = document.getElementById("manualGearRarity");
    const manualGearColor = document.getElementById("manualGearColor");
    const manualGearColor2 = document.getElementById("manualGearColor2");
    const manualGearItemType = document.getElementById("manualGearItemType");
    const manualGearAesthetic = document.getElementById("manualGearAesthetic");
    const manualGearEssence = document.getElementById("manualGearEssence");
    const manualGearCredit = document.getElementById("manualGearCredit");
    const manualGearStatsList = document.getElementById("manualGearStatsList");
    const addManualGearStat = document.getElementById("addManualGearStat");
    const manualGearAbilitiesList = document.getElementById("manualGearAbilitiesList");
    const addManualGearAbility = document.getElementById("addManualGearAbility");
    const addManualGearButton = document.getElementById("addManualGear");
    const manualGearStatus = document.getElementById("manualGearStatus");
    const gearSortField = document.getElementById("gearSortField");
    const gearSortDirection = document.getElementById("gearSortDirection");
    const gearFilterRarity = document.getElementById("gearFilterRarity");
    const gearFilterType = document.getElementById("gearFilterType");
    const gearFilterColor = document.getElementById("gearFilterColor");
    const gearFilterStat = document.getElementById("gearFilterStat");

    const gearDetailModal = document.getElementById("gearDetailModal");
    const gearDetailBackdrop = gearDetailModal.querySelector(".xr-modal-backdrop");
    const gearDetailTitle = document.getElementById("gearDetailTitle");
    const gearNameInput = document.getElementById("gearNameInput");
    const gearDetailBody = document.getElementById("gearDetailBody");
    const closeGearDetail = document.getElementById("closeGearDetail");
    const copyGearJson = document.getElementById("copyGearJson");
    const saveGearName = document.getElementById("saveGearName");
    const deleteGearButton = document.getElementById("deleteGear");
    const dissolveGearButton = document.getElementById("dissolveGear");
    const gearDetailStatus = document.getElementById("gearDetailStatus");

    const deletedGearHistory = [];

    const gearSlotLabels = {
      weapon_1: "Weapon 1",
      weapon_2: "Weapon 2",
      head: "Head",
      torso: "Torso",
      hands: "Hands",
      legs: "Legs",
      feet: "Feet",
      ring_1: "Ring 1",
      ring_2: "Ring 2",
      neck: "Neck",
      kernel_1: "Kernel 1",
      kernel_2: "Kernel 2",
      kernel_3: "Kernel 3",
      kernel_4: "Kernel 4",
      kernel_5: "Kernel 5"
    };

    const gearTypeToSlots = {
      "One-Handed Weapon": ["weapon_1", "weapon_2"],
      "Two-Handed Weapon": ["weapon_1", "weapon_2"],
      "Head": ["head"],
      "Torso": ["torso"],
      "Hands": ["hands"],
      "Legs": ["legs"],
      "Feet": ["feet"],
      "Ring": ["ring_1", "ring_2"],
      "Neck": ["neck"],
      "Kernel": ["kernel_1", "kernel_2", "kernel_3", "kernel_4", "kernel_5"]
    };

    const statKeyMap = {
      Luck: "luck",
      "Inventory Slots": "inventory_slots",
      "Energy Cap": "energy_cap",
      "Kernel Slots": "kernel_slots",
      HP: "hp",
      Power: "power",
      Defense: "defense",
      Speed: "speed",
      Intelligence: "intelligence",
      "Attack Plus": "attackPlus",
      "Damage Plus": "damagePlus",
      "Defense DC": "defenseDc",
      Armor: "armor",
      Initiative: "initiative",
      "Movement Speed": "movementSpeed",
      Range: "range",
      Perception: "perception",
      "AOE Range": "aoeRange",
      Hacking: "hacking",
      "Group XP Gain": "group_xp_gain",
      "HP Regen": "hp_regen",
      "Energy Conversion": "energy_conversion",
      "Energy Generation": "energy_generation",
      "Resell Value": "resell_value"
    };

    const statOptions = [
      "Power",
      "Defense",
      "Speed",
      "Intelligence",
      "Luck",
      "HP",
      "Attack Plus",
      "Damage Plus",
      "Defense DC",
      "Armor",
      "Initiative",
      "Movement Speed",
      "Range",
      "Perception",
      "AOE Range",
      "Hacking",
      "Inventory Slots",
      "Kernel Slots",
      "Energy Cap",
      "Energy Conversion",
      "Energy Generation",
      "Group XP Gain",
      "HP Regen",
      "Resell Value"
    ];

    const baubleFormulaOptions = [
      "G÷4",
      "G÷3",
      "G÷2",
      "G",
      "Gx1.25",
      "Gx1.5",
      "Gx1.75",
      "Gx2.5",
      "+1",
      "+2",
      "+3",
      "+4",
      "+5"
    ];

    const gearTypeSortOrder = [
      "One-Handed Weapon",
      "Two-Handed Weapon",
      "Head",
      "Torso",
      "Hands",
      "Legs",
      "Feet",
      "Ring",
      "Neck",
      "Kernel",
      "Bauble",
      "Consumable"
    ];

    const raritySortOrder = ["Basic", "Common", "Uncommon", "Rare", "Epic", "Legendary"];
    const colorSortOrder = ["Neutral", "Red", "Blue", "Green", "Gray"];

    let availableAbilities = [];

    function deriveSecondaryStats(stats) {
      const power = stats.power || 0;
      const defense = stats.defense || 0;
      const speed = stats.speed || 0;
      const intelligence = stats.intelligence || 0;
      const perception = intelligence * 2;

      return {
        attackPlus: power,
        damagePlus: power,
        defenseDc: 10 + defense,
        armor: defense,
        initiative: speed,
        movementSpeed: (speed * 2) + 10,
        range: speed + 5,
        perception,
        aoeRange: perception,
        hacking: intelligence
      };
    }

    function normalizeStats(stats) {
      const normalized = {
        ...defaults,
        ...stats
      };
      if (normalized.current_hp == null) {
        normalized.current_hp = normalized.hp;
      }
      return normalized;
    }

    function currentStats() {
      if (!activeCharacter) {
        return normalizeStats({});
      }
      return normalizeStats(activeCharacter.base_stats || {});
    }

    function getStatusStacks(stats) {
      return {
        burn: Math.max(0, Number(stats.status_burn) || 0),
        freeze: Math.max(0, Number(stats.status_freeze) || 0),
        poison: Math.max(0, Number(stats.status_poison) || 0)
      };
    }

    function getStatusEffectsPayload(stats) {
      const stacks = getStatusStacks(stats);
      return {
        burn: stacks.burn,
        freeze: stacks.freeze,
        poison: stacks.poison
      };
    }

    function mergeStatusEffectsIntoStats(baseStats = {}, statusEffects) {
      if (!statusEffects) return baseStats;
      const merged = { ...baseStats };
      merged.status_burn = Number(statusEffects.burn) || 0;
      merged.status_freeze = Number(statusEffects.freeze) || 0;
      merged.status_poison = Number(statusEffects.poison) || 0;
      return merged;
    }

    function normalizeStatusEffects(statusEffects) {
      const normalized = { ...statusEffectDefaults };
      if (!statusEffects) return normalized;
      return {
        burn: Math.max(0, Number(statusEffects.burn) || 0),
        freeze: Math.max(0, Number(statusEffects.freeze) || 0),
        poison: Math.max(0, Number(statusEffects.poison) || 0)
      };
    }

    function pushStatus(message, { tone = "info", actionLabel, onAction, duration = 4500 } = {}) {
      if (!elements.statusPopup) return;
      const toast = document.createElement("div");
      toast.className = `status-toast ${tone}`;
      const messageSpan = document.createElement("span");
      messageSpan.className = "status-message";
      messageSpan.textContent = message;
      toast.appendChild(messageSpan);
      if (actionLabel && typeof onAction === "function") {
        const actionButton = document.createElement("button");
        actionButton.type = "button";
        actionButton.textContent = actionLabel;
        actionButton.addEventListener("click", () => {
          onAction();
          toast.remove();
        });
        toast.appendChild(actionButton);
      }
      elements.statusPopup.appendChild(toast);
      if (duration !== null) {
        setTimeout(() => {
          toast.remove();
        }, duration);
      }
    }

    function calculateFormulaValue(formula, luck, statName, context = {}) {
      if (formula == null) return 0;
      if (typeof formula === "number") return formula;
      const trimmed = String(formula).trim();
      if (!trimmed) return 0;
      if (trimmed.startsWith("x")) {
        return 0;
      }
      if (trimmed === "D") {
        return String(luck).length;
      }
      if (trimmed === "D+1") {
        return String(luck).length + 1;
      }
      const normalized = trimmed.replace(/^\+/, "");
      if (/^\d+(\.\d+)?$/.test(normalized)) {
        return Number(normalized);
      }
      const match = normalized.match(/^([LG])([x÷])([\d.]+)$/);
      if (!match) return 0;
      const [, symbol, op, raw] = match;
      const value = Number(raw);
      const gValue = Number(context.g) || 0;
      const baseValue = symbol === "G" ? gValue : luck;
      let result = 0;
      if (op === "x") {
        result = Math.floor(baseValue * value);
      } else {
        result = Math.floor(baseValue / value);
      }
      if (statName === "Kernel Slots") {
        return Math.min(3, Math.max(1, result));
      }
      return Math.max(1, result);
    }

    function parseAbilityLines(ability) {
      if (!ability) return [];
      if (typeof ability === "string") return [ability];
      const details = ability.tierDetails;
      if (!details) return [];
      if (typeof details === "string") {
        return details.split("\n");
      }
      return Object.values(details).flatMap(detail => String(detail || "").split("\n"));
    }

    function parseAbilityStatLine(line) {
      const cleaned = String(line || "").trim().replace(/^[-•]\s*/, "");
      if (!cleaned.includes(":")) return null;
      const [rawStat, ...rest] = cleaned.split(":");
      const statName = rawStat.trim();
      if (!statName || statName.toLowerCase().includes("basic stat of your choice")) return null;
      const rawValue = rest.join(":").trim();
      if (!rawValue) return null;
      if (/^[+-]?\d+(\.\d+)?$/.test(rawValue.replace(/^\+/, ""))) {
        return { statName, value: Number(rawValue.replace(/^\+/, "")) };
      }
      return { statName, formula: rawValue.replace(/^\+/, "") };
    }

    function parseStatusAbilityLine(line, statusStacks) {
      const cleaned = String(line || "").trim().replace(/^[-•]\s*/, "");
      if (!cleaned) return [];
      const results = [];
      const freezeDefenseMatch = cleaned.match(/freezing.*\+([\d.]+)\s+defense dc and armor/i);
      if (freezeDefenseMatch && statusStacks.freeze > 0) {
        const value = Number(freezeDefenseMatch[1]);
        if (!Number.isNaN(value)) {
          results.push({ statName: "Defense DC", value });
          results.push({ statName: "Armor", value });
        }
      }
      const freezeDamageMatch = cleaned.match(/deal\s*\+?([\d.]+)\s*points?\s*of damage for each stack of freeze/i);
      if (freezeDamageMatch && statusStacks.freeze > 0) {
        const perStack = Number(freezeDamageMatch[1]);
        if (!Number.isNaN(perStack)) {
          results.push({ statName: "Damage Plus", value: perStack * statusStacks.freeze });
        }
      }
      return results;
    }

    function getAoeBuffMultiplier() {
      let multiplier = 1;
      characterGear.forEach(entry => {
        if (!entry.equipped || !entry.gear) return;
        const gearType = entry.gear.gear_type || entry.gear.gearType;
        if (gearType !== "Kernel") return;
        (entry.gear.abilities || []).forEach(ability => {
          if (!ability || ability.name !== "AOE Buff") return;
          parseAbilityLines(ability).forEach(line => {
            const match = String(line).match(/AOE Radius now = Perception x([\d.]+)/i);
            if (match) {
              const value = Number(match[1]);
              if (!Number.isNaN(value)) {
                multiplier = Math.max(multiplier, value);
              }
            }
          });
        });
      });
      return multiplier;
    }

    function mergeBonuses(target, source) {
      ["base", "derived", "misc"].forEach(section => {
        Object.keys(source[section]).forEach(key => {
          target[section][key] += source[section][key] || 0;
        });
      });
      return target;
    }

    function getEquippedColorCounts() {
      const counts = {};
      characterGear.forEach(entry => {
        if (!entry.equipped || !entry.gear) return;
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        if (gearType === "Bauble") return;
        [gear.color, gear.color2].filter(Boolean).forEach(color => {
          counts[color] = (counts[color] || 0) + 1;
        });
      });
      return counts;
    }

    function hasAllCoreColorsEquipped() {
      const counts = getEquippedColorCounts();
      return ["Red", "Blue", "Green", "Gray"].every(color => (counts[color] || 0) > 0);
    }

    function createEmptyBonus() {
      return {
        base: {
          luck: 0,
          inventory_slots: 0,
          energy_cap: 0,
          kernel_slots: 0,
          hp: 0,
          power: 0,
          defense: 0,
          speed: 0,
          intelligence: 0
        },
        derived: {
          attackPlus: 0,
          damagePlus: 0,
          defenseDc: 0,
          armor: 0,
          initiative: 0,
          movementSpeed: 0,
          range: 0,
          perception: 0,
          aoeRange: 0,
          hacking: 0
        },
        misc: {
          group_xp_gain: 0,
          hp_regen: 0,
          energy_conversion: 0,
          energy_generation: 0,
          resell_value: 0
        }
      };
    }

    function createEmptyBonusSources() {
      return {
        base: {
          luck: [],
          inventory_slots: [],
          energy_cap: [],
          kernel_slots: [],
          hp: [],
          power: [],
          defense: [],
          speed: [],
          intelligence: []
        },
        derived: {
          attackPlus: [],
          damagePlus: [],
          defenseDc: [],
          armor: [],
          initiative: [],
          movementSpeed: [],
          range: [],
          perception: [],
          aoeRange: [],
          hacking: []
        },
        misc: {
          group_xp_gain: [],
          hp_regen: [],
          energy_conversion: [],
          energy_generation: [],
          resell_value: []
        }
      };
    }

    function applyStatBonus(target, statName, value, sourceLabel, sources) {
      const key = statKeyMap[statName];
      if (!key || !value) return;
      if (Object.prototype.hasOwnProperty.call(target.derived, key)) {
        target.derived[key] += value;
        if (sources && sourceLabel) {
          sources.derived[key].push({ value, label: sourceLabel });
        }
      } else if (Object.prototype.hasOwnProperty.call(target.misc, key)) {
        target.misc[key] += value;
        if (sources && sourceLabel) {
          sources.misc[key].push({ value, label: sourceLabel });
        }
      } else if (Object.prototype.hasOwnProperty.call(target.base, key)) {
        target.base[key] += value;
        if (sources && sourceLabel) {
          sources.base[key].push({ value, label: sourceLabel });
        }
      }
    }

    function calculateGearBonuses(baseStats) {
      const equippedColorCounts = getEquippedColorCounts();
      const baseLuck = baseStats.luck || 0;
      const statusStacks = getStatusStacks(baseStats);
      const nonBaubleBonus = createEmptyBonus();
      const abilityBonus = createEmptyBonus();
      const baubleBonus = createEmptyBonus();
      const sources = createEmptyBonusSources();

      characterGear.forEach(entry => {
        if (!entry.gear) return;
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        const isBauble = gearType === "Bauble";
        const isEquipped = entry.equipped;
        const isInventory = entry.gear_slot === "inventory";

        if (!isBauble && isEquipped) {
          (gear.stats || []).forEach(stat => {
            const statName = stat.name || stat.stat || stat.label;
            if (!statName) return;
            const value = stat.value ?? stat.calc ?? calculateFormulaValue(stat.formula, baseLuck, statName);
            if (typeof value !== "number") return;
            applyStatBonus(nonBaubleBonus, statName, value, gearType, sources);
          });
        }
      });

      const interimLuck = applyGearBonuses(baseStats, nonBaubleBonus).luck || baseLuck;

      characterGear.forEach(entry => {
        if (!entry.gear) return;
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        if (gearType !== "Kernel" || !entry.equipped) return;
        (gear.abilities || []).forEach(ability => {
          const lines = parseAbilityLines(ability);
          const hasColorSpread = lines.some(line => line.toLowerCase().includes("each color equipped"));
          if (hasColorSpread && !hasAllCoreColorsEquipped()) return;
          const abilityLabel = typeof ability === "string" ? "Kernel Ability" : ability.name || "Kernel Ability";
          const gLine = lines.find(line => line.includes("G ="));
          let gValue = 0;
          if (gLine) {
            const match = gLine.match(/G = The amount of (\w+)/i);
            if (match) {
              const color = match[1];
              gValue = equippedColorCounts[color] || 0;
            }
          }
          lines.forEach(line => {
            if (line.includes("G =")) return;
            const parsed = parseAbilityStatLine(line);
            if (parsed) {
              const value = parsed.value ?? calculateFormulaValue(parsed.formula, interimLuck, parsed.statName, { g: gValue });
              if (typeof value === "number") {
                applyStatBonus(abilityBonus, parsed.statName, value, abilityLabel, sources);
              }
            }
            const statusBonuses = parseStatusAbilityLine(line, statusStacks);
            statusBonuses.forEach(statusBonus => {
              applyStatBonus(abilityBonus, statusBonus.statName, statusBonus.value, abilityLabel, sources);
            });
          });
        });
      });

      const combinedBeforeBauble = mergeBonuses(mergeBonuses(createEmptyBonus(), nonBaubleBonus), abilityBonus);
      const interimStats = applyGearBonuses(baseStats, combinedBeforeBauble);
      const updatedLuck = interimStats.luck || baseLuck;

      characterGear.forEach(entry => {
        if (!entry.gear) return;
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        const isBauble = gearType === "Bauble";
        const isInventory = entry.gear_slot === "inventory";
        if (!isBauble || !isInventory) return;
        const gValue = gear.color ? (equippedColorCounts[gear.color] || 0) : 0;
        (gear.stat_modifiers || []).forEach(stat => {
          const statName = stat.name || stat.stat || stat.label;
          if (!statName) return;
          const value = calculateFormulaValue(stat.formula, updatedLuck, statName, { g: gValue });
          if (typeof value !== "number") return;
          applyStatBonus(baubleBonus, statName, value, "Bauble", sources);
        });
      });

      const combined = mergeBonuses(mergeBonuses(nonBaubleBonus, abilityBonus), baubleBonus);
      combined.sources = sources;
      return combined;
    }

    function applyGearBonuses(baseStats, gearBonus) {
      const combined = { ...baseStats };
      Object.keys(gearBonus.base).forEach(key => {
        combined[key] = (combined[key] || 0) + (gearBonus.base[key] || 0);
      });
      combined.current_hp = Math.min(combined.current_hp ?? combined.hp, combined.hp);
      return combined;
    }

    function getGearGeneratorLuck(stats) {
      const baseLuck = stats.luck || 0;
      const bonus = Number(gearBonusLuck.value) || 0;
      return baseLuck + bonus;
    }

    function updateGearGeneratorLuck(stats) {
      gearTotalLuck.textContent = getGearGeneratorLuck(stats);
    }

    function getKernelSlots(stats) {
      const count = Math.max(Number(stats.kernel_slots) || 0, 0);
      return Array.from({ length: Math.min(count, 5) }, (_, i) => `kernel_${i + 1}`);
    }

    function getEquippedSlotList(stats) {
      return [
        "weapon_1",
        "weapon_2",
        "head",
        "torso",
        "hands",
        "legs",
        "feet",
        "ring_1",
        "ring_2",
        "neck",
        ...getKernelSlots(stats)
      ];
    }

    function formatSlotLabel(slot) {
      return gearSlotLabels[slot] || slot;
    }

    function formatSignedValue(value) {
      const rounded = Number.isFinite(value) ? value : 0;
      return `${rounded >= 0 ? "+" : ""}${rounded}`;
    }

    function summarizeSources(sourceList = []) {
      if (!sourceList.length) return "";
      const totals = sourceList.reduce((acc, item) => {
        if (!item || !item.label || !item.value) return acc;
        acc[item.label] = (acc[item.label] || 0) + item.value;
        return acc;
      }, {});
      const parts = Object.entries(totals)
        .filter(([, value]) => value)
        .map(([label, value]) => `${formatSignedValue(value)} ${label}`);
      return parts.length ? parts.join(", ") : "";
    }

    function scaleSourceList(list = [], factor = 1) {
      return list.map(item => ({
        label: item.label,
        value: item.value * factor
      }));
    }

    function combineSourceLists(...lists) {
      return lists.flat().filter(Boolean);
    }

    function setStatDisplay(element, value, summary) {
      if (!element) return;
      element.textContent = "";
      element.append(String(value));
      if (summary) {
        const summarySpan = document.createElement("span");
        summarySpan.className = "muted";
        summarySpan.style.marginLeft = "0.4rem";
        summarySpan.textContent = `(${summary})`;
        element.appendChild(summarySpan);
      }
    }

    function formatGearName(gear) {
      if (!gear) return "Unknown Gear";
      if (gear.name && gear.name.trim()) return gear.name.trim();
      const colors = [gear.color, gear.color2].filter(Boolean).join("/");
      const colorLabel = colors ? `${colors} ` : "";
      return `${gear.rarity || ""} ${colorLabel}${gear.item_type || gear.itemType || gear.gear_type || gear.gearType || "Gear"}`.trim();
    }

    const gearTagPalette = {
      type: {
        "One-Handed Weapon": "#94a3b8",
        "Two-Handed Weapon": "#94a3b8",
        "Head": "#94a3b8",
        "Torso": "#94a3b8",
        "Hands": "#94a3b8",
        "Legs": "#94a3b8",
        "Feet": "#94a3b8",
        "Ring": "#94a3b8",
        "Neck": "#94a3b8",
        "Kernel": "#94a3b8",
        "Consumable": "#94a3b8",
        "Bauble": "#94a3b8"
      },
      rarity: {
        "Basic": "#cbd5f5",
        "Common": "#94a3b8",
        "Uncommon": "#22c55e",
        "Rare": "#38bdf8",
        "Epic": "#a855f7",
        "Legendary": "#f59e0b"
      },
      color: {
        "Neutral": "#cbd5f5",
        "Red": "#f87171",
        "Blue": "#60a5fa",
        "Green": "#4ade80",
        "Gray": "#9aa3b2"
      }
    };

    function hexToRgba(hex, alpha) {
      const normalized = hex.replace("#", "");
      const bigint = parseInt(normalized, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function renderGearTag(label, group, options = {}) {
      const palette = gearTagPalette[group] || {};
      const primaryKey = options.primary || label;
      const primary = palette[primaryKey] || "#94a3b8";
      const secondaryKey = options.secondary;
      const secondary = secondaryKey ? (palette[secondaryKey] || primary) : null;
      const bg = hexToRgba(primary, 0.22);
      const style = [
        `--tag-color: ${primary}`,
        `--tag-bg: ${bg}`,
        secondary ? `--tag-color-secondary: ${secondary}` : ""
      ]
        .filter(Boolean)
        .join("; ");
      const className = `gear-tag gear-tag--${group}${secondary ? " dual" : ""}`;
      return `<span class="${className}" style="${style}">${label}</span>`;
    }

    function normalizeLabel(value) {
      return String(value || "").trim().toLowerCase();
    }

    function getGearTypeLabel(gear) {
      return gear?.gear_type || gear?.gearType || "";
    }

    function gearHasStat(gear, targetStat) {
      if (!targetStat) return true;
      const target = normalizeLabel(targetStat);
      const allStats = [...(gear.stats || []), ...(gear.stat_modifiers || [])];
      return allStats.some(stat => normalizeLabel(stat.label || stat.name) === target);
    }

    function matchesGearFilters(gear) {
      if (!gear) return false;
      const filterRarity = gearFilterRarity?.value || "";
      const filterType = gearFilterType?.value || "";
      const filterColor = gearFilterColor?.value || "";
      const filterStat = gearFilterStat?.value || "";
      const gearType = getGearTypeLabel(gear);
      const gearColor = gear.color || "Neutral";
      if (filterRarity && gear.rarity !== filterRarity) return false;
      if (filterType && gearType !== filterType) return false;
      if (filterColor && gearColor !== filterColor) return false;
      if (filterStat && !gearHasStat(gear, filterStat)) return false;
      return true;
    }

    function sortGearEntries(entries) {
      const sortField = gearSortField?.value || "rarity";
      const direction = gearSortDirection?.value === "desc" ? -1 : 1;
      const rarityIndex = entry => raritySortOrder.indexOf(entry.gear.rarity);
      const typeIndex = entry => gearTypeSortOrder.indexOf(getGearTypeLabel(entry.gear));
      const colorIndex = entry => colorSortOrder.indexOf(entry.gear.color || "Neutral");

      return [...entries].sort((a, b) => {
        let aKey = "";
        let bKey = "";
        if (sortField === "rarity") {
          aKey = rarityIndex(a);
          bKey = rarityIndex(b);
        } else if (sortField === "type") {
          aKey = typeIndex(a);
          bKey = typeIndex(b);
        } else if (sortField === "color") {
          aKey = colorIndex(a);
          bKey = colorIndex(b);
        } else {
          aKey = formatGearName(a.gear);
          bKey = formatGearName(b.gear);
        }

        if (aKey === bKey) {
          return formatGearName(a.gear).localeCompare(formatGearName(b.gear)) * direction;
        }
        if (typeof aKey === "number" && typeof bKey === "number") {
          const normalizedA = aKey === -1 ? Number.MAX_SAFE_INTEGER : aKey;
          const normalizedB = bKey === -1 ? Number.MAX_SAFE_INTEGER : bKey;
          return normalizedA > normalizedB ? direction : -direction;
        }
        return String(aKey).localeCompare(String(bKey)) * direction;
      });
    }

    function availableSlotsForGear(gear, stats) {
      const gearType = gear?.gear_type || gear?.gearType;
      if (!gear || gearType === "Bauble") return [];
      const slots = gearTypeToSlots[gearType] || [];
      const kernelSlots = getKernelSlots(stats);
      const filteredSlots = slots.filter(slot => slot.startsWith("kernel_") ? kernelSlots.includes(slot) : true);
      return filteredSlots.filter(slot => !characterGear.some(entry => entry.equipped && entry.gear_slot === slot));
    }

    function getSwapOptionsForGear(gear, stats) {
      const gearType = gear?.gear_type || gear?.gearType;
      if (!gear || gearType === "Bauble") return [];
      const slots = gearTypeToSlots[gearType] || [];
      const kernelSlots = getKernelSlots(stats);
      const filteredSlots = slots.filter(slot => slot.startsWith("kernel_") ? kernelSlots.includes(slot) : true);
      return filteredSlots
        .map(slot => {
          const entry = characterGear.find(item => item.equipped && item.gear_slot === slot);
          return entry ? { slot, entry } : null;
        })
        .filter(Boolean);
    }

    function selectSwapSlot(options) {
      return options.length ? options[0] : null;
    }

    function renderGearStatsList(stats, statModifiers, luck, context = {}) {
      const rows = [];
      (stats || []).forEach(stat => {
        const statName = stat.label || stat.name;
        if (!statName) return;
        rows.push(`<li class="gear-stat gear-stat--base">${statName}: ${stat.value ?? "?"} <span class="muted">(${stat.formula || "?"})</span></li>`);
      });
      (statModifiers || []).forEach(stat => {
        const statName = stat.label || stat.name;
        if (!statName) return;
        const value = calculateFormulaValue(stat.formula, luck, stat.name || statName, context);
        rows.push(`<li class="gear-stat gear-stat--bonus">${statName}: ${value} <span class="muted">(${stat.formula || "?"})</span></li>`);
      });
      return rows.length ? `<ul>${rows.join("")}</ul>` : `<p class="muted">No stat changes.</p>`;
    }

    function buildGearStatSummary(gear, luck, context = {}) {
      const parts = [];
      (gear.stats || []).forEach(stat => {
        const statName = stat.label || stat.name;
        if (!statName) return;
        const value = stat.value ?? stat.calc;
        if (typeof value !== "number" || value === 0) return;
        parts.push(`${formatSignedValue(value)} ${statName}`);
      });
      (gear.stat_modifiers || []).forEach(stat => {
        const statName = stat.label || stat.name;
        if (!statName) return;
        const value = calculateFormulaValue(stat.formula, luck, stat.name || statName, context);
        if (typeof value !== "number" || value === 0) return;
        parts.push(`${formatSignedValue(value)} ${statName}`);
      });
      return parts.length ? parts.join(", ") : "No stat modifiers";
    }

    function formatTierLabel(tier) {
      const tierText = String(tier || "").trim();
      if (!tierText) return "Tier";
      return /tier/i.test(tierText) ? tierText : `Tier ${tierText}`;
    }

    function renderAbilityDetails(abilities) {
      if (!abilities || !abilities.length) {
        return `<p class="muted">No abilities.</p>`;
      }
      return abilities
        .map(ability => {
          if (typeof ability === "string") {
            return `
              <div>
                <strong>${ability}</strong>
                <div class="muted">No tier details.</div>
              </div>
            `;
          }
          const tiers = ability.tierDetails || {};
          const tierEntries = Object.entries(tiers);
          const tierList = tierEntries.length
            ? `<ul>${tierEntries.map(([tier, detail]) => `<li><strong>${formatTierLabel(tier)}:</strong> ${detail}</li>`).join("")}</ul>`
            : `<p class="muted">No tier details.</p>`;
          return `
            <div>
              <strong><a href="${ability.link}" target="_blank" rel="noopener">${ability.name}</a></strong>
              <div class="muted">Tiers available: ${tierEntries.length}</div>
              ${tierList}
            </div>
          `;
        })
        .join("");
    }

    function extractTierNumbers(ability) {
      if (!ability) return [];
      const tiers = new Set();
      const details = typeof ability === "string" ? null : ability.tierDetails;
      if (details && typeof details === "object") {
        Object.keys(details).forEach(key => {
          const match = String(key).match(/(\d+)/);
          if (match) {
            tiers.add(Number(match[1]));
          }
        });
      }
      parseAbilityLines(ability).forEach(line => {
        const match = String(line).match(/tier\s*(\d+)/i);
        if (match) {
          tiers.add(Number(match[1]));
        }
      });
      return [...tiers]
        .filter(value => Number.isFinite(value))
        .sort((a, b) => a - b);
    }

    function renderGearSections(stats) {
      renderEquippedSlots(stats);
      renderInventory(stats);
      renderLocalNode(stats);
    }

    function renderEquippedSlots(stats) {
      const container = elements.equippedSlots;
      container.innerHTML = "";
      const slots = getEquippedSlotList(stats);
      if (!slots.length) {
        container.innerHTML = `<span class="muted">No gear slots yet.</span>`;
        return;
      }
      slots.forEach(slot => {
        const entry = characterGear.find(item => item.equipped && item.gear_slot === slot);
        const card = document.createElement("div");
        card.className = "gear-item";
        if (!entry) {
          card.innerHTML = `
            <div class="gear-summary">
              <div class="gear-meta">
                <strong>${formatSlotLabel(slot)}</strong>
                <span class="muted">Empty</span>
              </div>
            </div>
          `;
        } else {
          card.classList.add("gear-item--equipped");
          const gear = entry.gear;
          const gearType = gear.gear_type || gear.gearType;
          const colorLabel = [gear.color, gear.color2].filter(Boolean).join(" / ") || "Neutral";
          const statSummary = buildGearStatSummary(gear, stats.luck);
          card.innerHTML = `
            <div class="gear-slot-badge">${formatSlotLabel(slot)}</div>
            <div class="gear-summary">
              <div class="gear-meta">
                <strong>${formatGearName(gear)}</strong>
                <div class="gear-tags">
                  ${renderGearTag(gearType, "type")}
                  ${renderGearTag(gear.rarity, "rarity")}
                  ${renderGearTag(colorLabel, "color", { primary: gear.color || "Neutral", secondary: gear.color2 })}
                </div>
                <span class="muted">Stats: ${statSummary}</span>
              </div>
              <div class="gear-actions">
                <button type="button" data-action="view" data-gear="${entry.gear_id}">View Details</button>
                <button type="button" data-action="unequip" data-gear="${entry.gear_id}">Move to Inventory</button>
                <button type="button" data-action="dissolve" data-gear="${entry.gear_id}">Dissolve</button>
                <button type="button" data-action="delete" data-gear="${entry.gear_id}">Delete</button>
              </div>
            </div>
          `;
        }
        container.appendChild(card);
      });
    }

    function renderInventory(stats) {
      const container = elements.inventorySlots;
      container.innerHTML = "";
      if (elements.inventorySlotCount) {
        elements.inventorySlotCount.textContent = `${inventoryCount()}/${inventoryCapacity(stats)}`;
      }
      const inventoryItems = characterGear.filter(item => item.gear_slot === "inventory");
      if (!inventoryItems.length) {
        container.innerHTML = `<span class="muted">No gear in inventory.</span>`;
        return;
      }
      const filteredItems = sortGearEntries(inventoryItems.filter(entry => matchesGearFilters(entry.gear)));
      if (!filteredItems.length) {
        container.innerHTML = `<span class="muted">No inventory gear matches the selected filters.</span>`;
        return;
      }
      filteredItems.forEach(entry => {
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        const colorLabel = [gear.color, gear.color2].filter(Boolean).join(" / ") || "Neutral";
        const availableSlots = availableSlotsForGear(gear, stats);
        const swapOptions = gearType === "Bauble" ? [] : getSwapOptionsForGear(gear, stats);
        const slotHint = gearType === "Bauble"
          ? "Baubles cannot be equipped."
          : (availableSlots.length
            ? availableSlots.map(formatSlotLabel).join(", ")
            : (swapOptions.length ? "No slots open (swap available)" : "No slots open"));
        const canEquip = gearType !== "Bauble" && (availableSlots.length || swapOptions.length);
        const equipLabel = availableSlots.length ? "Equip" : (swapOptions.length ? "Swap" : "Equip");
        const colorCounts = getEquippedColorCounts();
        const gValue = gearType === "Bauble" && gear.color ? (colorCounts[gear.color] || 0) : 0;
        const statSummary = buildGearStatSummary(gear, stats.luck, { g: gValue });
        const card = document.createElement("div");
        card.className = "gear-item";
        card.innerHTML = `
          <div class="gear-summary">
            <div class="gear-meta">
              <strong>${formatGearName(gear)}</strong>
              <div class="gear-tags">
                ${renderGearTag(gearType, "type")}
                ${renderGearTag(gear.rarity, "rarity")}
                ${renderGearTag(colorLabel, "color", { primary: gear.color || "Neutral", secondary: gear.color2 })}
              </div>
              <span class="muted">Equip Slots: ${slotHint}</span>
              <span class="muted">Stats: ${statSummary}</span>
            </div>
            <div class="gear-actions">
              <button type="button" data-action="view" data-gear="${entry.gear_id}">View Details</button>
              ${gearType === "Bauble" ? "" : `<button type="button" data-action="equip" data-gear="${entry.gear_id}" ${canEquip ? "" : "disabled"}>${equipLabel}</button>`}
              <button type="button" data-action="local" data-gear="${entry.gear_id}">Move to Local Node Storage</button>
              <button type="button" data-action="dissolve" data-gear="${entry.gear_id}">Dissolve</button>
              <button type="button" data-action="delete" data-gear="${entry.gear_id}">Delete</button>
            </div>
          </div>
        `;
        container.appendChild(card);
      });
    }

    function renderLocalNode(stats) {
      const container = elements.localNodeSlots;
      container.innerHTML = "";
      if (elements.localNodeSlotCount) {
        elements.localNodeSlotCount.textContent = `${localNodeCount()}/${localNodeCapacity(stats)}`;
      }
      const localItems = characterGear.filter(item => item.gear_slot === "local_node");
      if (!localItems.length) {
        container.innerHTML = `<span class="muted">No gear in local node storage.</span>`;
        return;
      }
      const filteredItems = sortGearEntries(localItems.filter(entry => matchesGearFilters(entry.gear)));
      if (!filteredItems.length) {
        container.innerHTML = `<span class="muted">No local node gear matches the selected filters.</span>`;
        return;
      }
      filteredItems.forEach(entry => {
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        const colorLabel = [gear.color, gear.color2].filter(Boolean).join(" / ") || "Neutral";
        const colorCounts = getEquippedColorCounts();
        const gValue = gearType === "Bauble" && gear.color ? (colorCounts[gear.color] || 0) : 0;
        const statSummary = buildGearStatSummary(gear, stats.luck, { g: gValue });
        const card = document.createElement("div");
        card.className = "gear-item";
        card.innerHTML = `
          <div class="gear-summary">
            <div class="gear-meta">
              <strong>${formatGearName(gear)}</strong>
              <div class="gear-tags">
                ${renderGearTag(gearType, "type")}
                ${renderGearTag(gear.rarity, "rarity")}
                ${renderGearTag(colorLabel, "color", { primary: gear.color || "Neutral", secondary: gear.color2 })}
              </div>
              <span class="muted">Stored in Local Node</span>
              <span class="muted">Stats: ${statSummary}</span>
            </div>
            <div class="gear-actions">
              <button type="button" data-action="view" data-gear="${entry.gear_id}">View Details</button>
              <button type="button" data-action="inventory" data-gear="${entry.gear_id}">Move to Inventory</button>
              <button type="button" data-action="dissolve" data-gear="${entry.gear_id}">Dissolve</button>
              <button type="button" data-action="delete" data-gear="${entry.gear_id}">Delete</button>
            </div>
          </div>
        `;
        container.appendChild(card);
      });
    }

    function renderAbilities() {
      const container = elements.abilitiesList;
      if (!container) return;
      const actives = [];
      const passives = [];
      const effects = [];

      characterGear.forEach(entry => {
        if (!entry.gear) return;
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        if (gearType === "Bauble" && entry.gear_slot === "inventory") {
          (gear.abilities || []).forEach(ability => effects.push(ability));
          return;
        }
        if (!entry.equipped) return;
        if (gearType === "Kernel") {
          (gear.abilities || []).forEach(ability => passives.push(ability));
        } else {
          (gear.abilities || []).forEach(ability => actives.push(ability));
        }
      });

      const renderAbilityDropdowns = (list, { showTierEnergy = false } = {}) => {
        if (!list.length) {
          return `<p class="muted">None.</p>`;
        }
        return list
          .map(ability => {
            const abilityName = typeof ability === "string" ? ability : ability.name;
            const abilityLink = typeof ability === "string" ? "" : ability.link;
            const lines = parseAbilityLines(ability).filter(Boolean);
            const tierDetails = typeof ability === "string" ? null : ability.tierDetails;
            const tierEntries = tierDetails && typeof tierDetails === "object" && !Array.isArray(tierDetails)
              ? Object.entries(tierDetails)
              : [];
            const detailsList = tierEntries.length
              ? `<ul>${tierEntries
                .map(([tier, detail]) => `<li><strong>${formatTierLabel(tier)}:</strong> ${detail}</li>`)
                .join("")}</ul>`
              : (lines.length
                ? `<ul>${lines.map(line => `<li>${line}</li>`).join("")}</ul>`
                : `<p class="muted">No details.</p>`);
            const tiers = showTierEnergy ? extractTierNumbers(ability) : [];
            const tierSummary = showTierEnergy
              ? (tiers.length
                ? `<div class="muted">Tiers: ${tiers.map(tier => `Tier ${tier} (Energy ${tier})`).join(", ")}</div>`
                : `<div class="muted">Tier info unavailable.</div>`)
              : "";
            return `
              <details class="ability-dropdown">
                <summary>${abilityName}</summary>
                <div class="ability-details">
                  ${detailsList}
                  ${tierSummary}
                  ${abilityLink ? `<a href="${abilityLink}" target="_blank" rel="noopener">View full ability details</a>` : ""}
                </div>
              </details>
            `;
          })
          .join("");
      };

      const renderAbilityGroup = (title, list, options = {}) => `
        <div class="ability-group">
          <h3>${title}</h3>
          ${renderAbilityDropdowns(list, options)}
        </div>
      `;

      container.innerHTML = `
        ${renderAbilityGroup("Actives", actives, { showTierEnergy: true })}
        ${renderAbilityGroup("Passives", passives)}
        ${renderAbilityGroup("Effects", effects)}
      `;
    }

    function inventoryCapacity(stats) {
      return Math.max(Number(stats.inventory_slots) || 0, 0);
    }

    function localNodeCapacity(stats) {
      return inventoryCapacity(stats) * 3;
    }

    function inventoryCount() {
      return characterGear.filter(entry => entry.gear_slot === "inventory").length;
    }

    function localNodeCount() {
      return characterGear.filter(entry => entry.gear_slot === "local_node").length;
    }

    function findGearEntry(gearId) {
      return characterGear.find(entry => String(entry.gear_id) === String(gearId));
    }

    async function ensurePyodide() {
      if (pyodideReady) return pyodideClient;
      elements.gearGeneratorStatus.textContent = "Loading gear generator…";
      elements.openGearGenerator.classList.add("hidden");
      try {
        const { loadPyodide } = await import("https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.mjs");
        pyodideClient = await loadPyodide();

        const pyFiles = [
          "abilityCatalog.py",
          "ability.py",
          "statbuff.py",
          "miscFunc.py",
          "gear.py",
          "helperFunc.py"
        ];

        for (const name of pyFiles) {
          const resp = await fetch(name);
          if (!resp.ok) throw new Error(`Failed to fetch ${name}: ${resp.status}`);
          const code = await resp.text();
          pyodideClient.FS.writeFile(name, code);
        }

        pyodideClient.runPython(`
          import json, random
          from gear import Gear
          from helperFunc import gearTypeMap

          def _serialize_ability(ability):
              if isinstance(ability, str):
                  return {
                      "name": ability,
                      "link": "",
                      "tierDetails": "No tier details."
                  }
              details = ability.tierDetails
              if isinstance(details, str):
                  details = { "Detail": details }
              return {
                  "name": ability.name,
                  "link": ability.link,
                  "tierDetails": details
              }

          def _serialize_gear(gear):
              stats = []
              for buff in gear.basicStatBuffs + gear.colorStatBuffs:
                  stats.append({
                      "name": buff.normalName,
                      "label": buff.name,
                      "formula": buff.formula,
                      "value": buff.calc
                  })
              abilities = [_serialize_ability(ab) for ab in gear.abilities]
              aesthetic = getattr(gear, "aesthetic", None) or getattr(gear, "baubleAesthetic", None)
              payload = {
                  "rarity": gear.rarity,
                  "color": gear.color,
                  "color2": gear.color2,
                  "gear_type": gear.gearType,
                  "item_type": gear.specificItem,
                  "aesthetic": aesthetic,
                  "essence_value": gear.essenceValue,
                  "credit_value": gear.creditValue,
                  "abilities": abilities,
                  "stats": stats,
                  "stat_modifiers": []
              }
              if gear.gearType == "Bauble":
                  payload["stat_modifiers"] = [
                      {
                          "name": buff.normalName,
                          "label": buff.name,
                          "formula": buff.formula
                      }
                      for buff in gear.colorStatBuffs
                  ]
                  payload["stats"] = []
              return payload

          def generate_gear_json(luck:int, amount:int, gearTypeNumber:int, rarity, color, color2):
              rarity = rarity if rarity else None
              color = color if color else None
              color2 = color2 if color2 else None
              output = []
              for _ in range(amount):
                  gearType = gearTypeMap.get(gearTypeNumber)
                  if gearType is None:
                      gearType = random.choice([v for v in gearTypeMap.values() if v])
                  gear = Gear(luck, gearType, rarity, color, color2)
                  output.append(_serialize_gear(gear))
              return json.dumps(output)

          def list_abilities_json():
              import abilityCatalog
              abilities = set()
              colors = ["Neutral", "Red", "Blue", "Green", "Gray"]
              color2_options = [None, "Neutral", "Red", "Blue", "Green", "Gray"]

              for name, cls in abilityCatalog.__dict__.items():
                  if not isinstance(cls, type):
                      continue
                  if not issubclass(cls, abilityCatalog.AbilityCatalog):
                      continue
                  if cls is abilityCatalog.AbilityCatalog:
                      continue
                  for color in colors:
                      for color2 in color2_options:
                          try:
                              instance = cls(color, color2)
                          except TypeError:
                              try:
                                  instance = cls(color)
                              except Exception:
                                  continue
                          except Exception:
                              continue
                          if isinstance(instance.abilities, dict):
                              abilities.update(instance.abilities.keys())
                          elif isinstance(instance.abilities, list):
                              abilities.update(instance.abilities)
              return json.dumps(sorted(list(abilities)))
        `);

        pyodideReady = true;
        if (!availableAbilities.length) {
          try {
            const abilityJson = pyodideClient.runPython("list_abilities_json()");
            availableAbilities = JSON.parse(abilityJson) || [];
            refreshAbilitySelectOptions();
          } catch (abilityError) {
            console.warn("Failed to load ability list", abilityError);
          }
        }
        elements.gearGeneratorStatus.textContent = "";
        elements.openGearGenerator.classList.remove("hidden");
        pushStatus("Gear generator ready.", { tone: "success", duration: 2500 });
        return pyodideClient;
      } catch (error) {
        console.error(error);
        elements.gearGeneratorStatus.textContent = "Failed to load gear generator.";
        pushStatus("Failed to load gear generator.", { tone: "error" });
        throw error;
      }
    }

    async function openGearGeneratorModal() {
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      updateGearGeneratorLuck(stats);
      gearGeneratorModal.classList.remove("hidden");
      await ensurePyodide();
    }

    function closeGearGeneratorModal() {
      gearGeneratorModal.classList.add("hidden");
    }

    function renderGeneratedGear(stats) {
      generatedGearList.innerHTML = "";
      if (!generatedGear.length) {
        generatedGearList.innerHTML = `<span class="muted">No gear generated yet.</span>`;
        if (addAllGeneratedGearButton) {
          addAllGeneratedGearButton.disabled = true;
        }
        return;
      }
      if (addAllGeneratedGearButton) {
        addAllGeneratedGearButton.disabled = false;
      }
      const totalLuck = getGearGeneratorLuck(stats);
      const colorCounts = getEquippedColorCounts();
      generatedGear.forEach((gear, index) => {
        const card = document.createElement("div");
        card.className = "gear-item";
        const gearType = gear.gear_type || gear.gearType;
        const colorLabel = [gear.color, gear.color2].filter(Boolean).join(" / ") || "Neutral";
        const gValue = gearType === "Bauble" && gear.color ? (colorCounts[gear.color] || 0) : 0;
        const statList = renderGearStatsList(gear.stats, gear.stat_modifiers, totalLuck, { g: gValue });
        const isAdded = gear.__added;
        const availableSlots = availableSlotsForGear(gear, stats);
        const swapOptions = gearType === "Bauble" ? [] : getSwapOptionsForGear(gear, stats);
        const canEquip = gearType !== "Bauble" && (availableSlots.length || swapOptions.length);
        const equipLabel = availableSlots.length ? "Equip" : (swapOptions.length ? "Swap" : "Equip");
        card.innerHTML = `
          <div class="gear-summary">
            <div class="gear-meta">
              <strong>${formatGearName(gear)}</strong>
              <div class="gear-tags">
                ${renderGearTag(gearType, "type")}
                ${renderGearTag(gear.rarity, "rarity")}
                ${renderGearTag(colorLabel, "color", { primary: gear.color || "Neutral", secondary: gear.color2 })}
              </div>
            </div>
            <div class="gear-actions">
              <button type="button" data-action="add" data-index="${index}" ${isAdded ? "disabled" : ""}>${isAdded ? "Added" : "Add to Inventory"}</button>
              ${gearType === "Bauble" ? "" : `<button type="button" data-action="equip" data-index="${index}" ${isAdded || !canEquip ? "disabled" : ""}>${isAdded ? "Added" : equipLabel}</button>`}
              <button type="button" data-action="remove" data-index="${index}" ${!isAdded ? "disabled" : ""}>${isAdded ? "Remove from Character" : "Not Added"}</button>
            </div>
          </div>
          <div class="gear-details-list">
            <strong>Stats</strong>
            ${statList}
            <strong>Abilities</strong>
            ${renderAbilityDetails(gear.abilities)}
          </div>
        `;
        generatedGearList.appendChild(card);
      });
    }

    async function handleGenerateGear() {
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const totalLuck = getGearGeneratorLuck(stats);
      const amount = Math.max(Number(gearAmount.value) || 1, 1);
      const gearTypeValue = parseInt(gearTypeNumber.value, 10);
      const rarity = gearRarity.value;
      const color = gearColor.value;
      const color2 = gearColor2.value;

      try {
        await ensurePyodide();
        const result = pyodideClient.runPython(
          `generate_gear_json(${totalLuck}, ${amount}, ${gearTypeValue}, ${JSON.stringify(rarity)}, ${JSON.stringify(color)}, ${JSON.stringify(color2)})`
        );
        generatedGear = JSON.parse(result);
        generatedGear.forEach(gear => {
          if (!gear.name) {
            gear.name = formatGearName(gear);
          }
        });
        renderGeneratedGear(stats);
      } catch (error) {
        console.error(error);
        pushStatus("Failed to generate gear.", { tone: "error" });
      }
    }

    function buildStatOptionList(selectedValue = "") {
      return statOptions
        .map(stat => `<option value="${stat}" ${stat === selectedValue ? "selected" : ""}>${stat}</option>`)
        .join("");
    }

    function buildFormulaOptionList(selectedValue = "") {
      return baubleFormulaOptions
        .map(formula => `<option value="${formula}" ${formula === selectedValue ? "selected" : ""}>${formula}</option>`)
        .join("");
    }

    function buildAbilityOptionList(selectedValue = "") {
      const list = availableAbilities.length ? [...availableAbilities] : ["Custom Ability"];
      if (selectedValue && !list.includes(selectedValue)) {
        list.unshift(selectedValue);
      }
      return list
        .map(ability => `<option value="${ability}" ${ability === selectedValue ? "selected" : ""}>${ability}</option>`)
        .join("");
    }

    function createManualStatRow({ statName = "", value = 0, formula = "" } = {}) {
      const row = document.createElement("div");
      row.className = "manual-gear-row";
      row.innerHTML = `
        <select class="manual-gear-stat-name">
          ${buildStatOptionList(statName || statOptions[0])}
        </select>
        <div class="manual-gear-stat-value"></div>
        <button type="button" class="manual-gear-remove">Remove</button>
      `;
      const valueContainer = row.querySelector(".manual-gear-stat-value");
      const removeButton = row.querySelector(".manual-gear-remove");
      removeButton.addEventListener("click", () => {
        row.remove();
      });
      const isBauble = manualGearType.value === "Bauble";
      if (isBauble) {
        valueContainer.innerHTML = `
          <select class="manual-gear-formula">
            ${buildFormulaOptionList(formula || baubleFormulaOptions[0])}
          </select>
        `;
      } else {
        valueContainer.innerHTML = `
          <input class="manual-gear-value" type="number" value="${value}" />
        `;
      }
      manualGearStatsList.appendChild(row);
    }

    function refreshManualStatRowsForType() {
      const isBauble = manualGearType.value === "Bauble";
      manualGearStatsList.querySelectorAll(".manual-gear-row").forEach(row => {
        const valueContainer = row.querySelector(".manual-gear-stat-value");
        if (!valueContainer) return;
        if (isBauble) {
          const currentFormula = row.querySelector(".manual-gear-formula")?.value || baubleFormulaOptions[0];
          valueContainer.innerHTML = `
            <select class="manual-gear-formula">
              ${buildFormulaOptionList(currentFormula)}
            </select>
          `;
        } else {
          const currentValue = row.querySelector(".manual-gear-value")?.value || 0;
          valueContainer.innerHTML = `<input class="manual-gear-value" type="number" value="${currentValue}" />`;
        }
      });
    }

    function createManualAbilityRow(selectedValue = "") {
      const row = document.createElement("div");
      row.className = "manual-gear-row";
      row.innerHTML = `
        <select class="manual-gear-ability">
          ${buildAbilityOptionList(selectedValue)}
        </select>
        <div class="manual-gear-stat-value"></div>
        <button type="button" class="manual-gear-remove">Remove</button>
      `;
      const removeButton = row.querySelector(".manual-gear-remove");
      removeButton.addEventListener("click", () => {
        row.remove();
      });
      manualGearAbilitiesList.appendChild(row);
    }

    function readManualStatRows() {
      const isBauble = manualGearType.value === "Bauble";
      const rows = Array.from(manualGearStatsList.querySelectorAll(".manual-gear-row"));
      if (isBauble) {
        return rows
          .map(row => {
            const statName = row.querySelector(".manual-gear-stat-name")?.value;
            const formula = row.querySelector(".manual-gear-formula")?.value;
            if (!statName || !formula) return null;
            return { name: statName, label: statName, formula };
          })
          .filter(Boolean);
      }
      return rows
        .map(row => {
          const statName = row.querySelector(".manual-gear-stat-name")?.value;
          const rawValue = Number(row.querySelector(".manual-gear-value")?.value || 0);
          if (!statName) return null;
          return {
            name: statName,
            label: statName,
            formula: formatSignedValue(rawValue),
            value: rawValue
          };
        })
        .filter(Boolean);
    }

    function readManualAbilities() {
      return Array.from(manualGearAbilitiesList.querySelectorAll(".manual-gear-ability"))
        .map(select => select.value)
        .filter(Boolean);
    }

    function buildManualGearPayload() {
      const isBauble = manualGearType.value === "Bauble";
      const stats = isBauble ? [] : readManualStatRows();
      const statModifiers = isBauble ? readManualStatRows() : [];
      const abilities = readManualAbilities();
      const payload = {
        name: manualGearName.value.trim() || null,
        rarity: manualGearRarity.value,
        color: manualGearColor.value,
        color2: manualGearColor2.value || null,
        gear_type: manualGearType.value,
        item_type: manualGearItemType.value.trim() || null,
        aesthetic: manualGearAesthetic.value.trim() || null,
        essence_value: Number(manualGearEssence.value) || 0,
        credit_value: Number(manualGearCredit.value) || 0,
        stats,
        stat_modifiers: statModifiers,
        abilities
      };
      if (!payload.name) {
        payload.name = formatGearName(payload);
      }
      return payload;
    }

    function populateGearFilterSelects() {
      const unique = list => Array.from(new Set(list));
      const appendOptions = (select, options) => {
        if (!select) return;
        const current = select.value;
        select.querySelectorAll("option:not([value=''])").forEach(option => option.remove());
        options.forEach(option => {
          const element = document.createElement("option");
          element.value = option;
          element.textContent = option;
          select.appendChild(element);
        });
        if (options.includes(current)) {
          select.value = current;
        }
      };

      appendOptions(gearFilterRarity, unique(raritySortOrder));
      appendOptions(gearFilterType, unique(gearTypeSortOrder));
      appendOptions(gearFilterColor, unique(colorSortOrder));
      appendOptions(gearFilterStat, unique(statOptions));
    }

    function refreshAbilitySelectOptions() {
      manualGearAbilitiesList.querySelectorAll(".manual-gear-ability").forEach(select => {
        const current = select.value;
        select.innerHTML = buildAbilityOptionList(current);
      });
    }

    function resetManualGearStatus() {
      manualGearStatus.textContent = "";
    }

    function handleManualGearAdd() {
      resetManualGearStatus();
      try {
        const payload = buildManualGearPayload();
        generatedGear.unshift(payload);
        renderGeneratedGear(applyGearBonuses(currentStats(), calculateGearBonuses(currentStats())));
        manualGearStatus.textContent = "Manual gear added.";
      } catch (error) {
        console.error(error);
        manualGearStatus.textContent = "Failed to add manual gear.";
      }
    }

    async function addAllGeneratedGear() {
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const available = inventoryCapacity(stats) - inventoryCount();
      if (available <= 0) {
        pushStatus("No inventory slots available.", { tone: "warning" });
        return;
      }
      let added = 0;
      for (const gear of generatedGear) {
        if (gear.__added) continue;
        if (added >= available) break;
        const inserted = await insertGearToInventory(gear);
        if (inserted) {
          gear.__added = true;
          added += 1;
        }
      }
      if (added) {
        pushStatus(`Added ${added} gear item(s) to inventory.`, { tone: "success" });
      } else {
        pushStatus("No new gear was added.", { tone: "warning" });
      }
      renderGeneratedGear(applyGearBonuses(currentStats(), calculateGearBonuses(currentStats())));
    }

    function buildGearInsertPayload(gear) {
      return {
        name: gear.name || formatGearName(gear),
        rarity: gear.rarity,
        color: gear.color,
        color2: gear.color2 || null,
        gear_type: gear.gear_type || gear.gearType,
        aesthetic: gear.aesthetic || null,
        item_type: gear.item_type || gear.itemType || null,
        stats: gear.stats || [],
        essence_value: gear.essence_value || gear.essenceValue || 0,
        credit_value: gear.credit_value || gear.creditValue || 0,
        abilities: gear.abilities || [],
        stat_modifiers: gear.stat_modifiers || gear.statModifiers || []
      };
    }

    function gearSignature(gear) {
      return JSON.stringify(buildGearInsertPayload(gear));
    }

    function isDuplicateGear(gear) {
      const signature = gearSignature(gear);
      return characterGear.some(entry => entry.gear && gearSignature(entry.gear) === signature);
    }

    async function insertGearToInventory(gear, options = {}) {
      if (!activeCharacter?.id) {
        pushStatus("Save the character before adding gear.", { tone: "warning" });
        return null;
      }
      if (isDuplicateGear(gear)) {
        pushStatus("That gear is already stored on this character.", { tone: "warning" });
        return null;
      }
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const slot = options.slot || "inventory";
      if (slot === "inventory" && inventoryCount() >= inventoryCapacity(stats)) {
        pushStatus("No inventory slots available.", { tone: "warning" });
        return null;
      }
      const payload = buildGearInsertPayload(gear);
      const { data, error } = await sb
        .from("webrunning_gear")
        .insert(payload)
        .select("*")
        .maybeSingle();
      if (error) throw error;

      const linkPayload = {
        character_id: activeCharacter.id,
        gear_id: data.id,
        equipped: slot !== "inventory" && slot !== "local_node",
        gear_slot: slot
      };
      const { error: linkError } = await sb
        .from("webrunning_character_gear")
        .insert(linkPayload);
      if (linkError) throw linkError;

      characterGear.push({
        gear_id: data.id,
        equipped: linkPayload.equipped,
        gear_slot: slot,
        gear: data
      });
      render();
      return data;
    }

    async function addGeneratedGear(index, action) {
      const gear = generatedGear[index];
      if (!gear) return;
      if (gear.__added) {
        pushStatus("That gear has already been added.", { tone: "warning" });
        return;
      }
      if (action === "equip") {
        const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
        const slots = availableSlotsForGear(gear, stats);
        if (!slots.length) {
          const swapOptions = getSwapOptionsForGear(gear, stats);
          if (!swapOptions.length) {
            pushStatus("No open slots for that gear.", { tone: "warning" });
            return;
          }
          if (inventoryCount() >= inventoryCapacity(stats)) {
            pushStatus("No inventory slots available to swap gear.", { tone: "warning" });
            return;
          }
          const selected = selectSwapSlot(swapOptions);
          if (!selected) {
            pushStatus("No swap targets available.", { tone: "warning" });
            return;
          }
          const inserted = await insertGearToInventory(gear, { slot: selected.slot });
          if (!inserted) return;
          await updateGearSlot(selected.entry, "inventory");
        } else {
          const inserted = await insertGearToInventory(gear, { slot: slots[0] });
          if (!inserted) return;
        }
      } else {
        const inserted = await insertGearToInventory(gear);
        if (!inserted) return;
      }
      gear.__added = true;
      pushStatus("Gear added.", { tone: "success" });
      renderGeneratedGear(applyGearBonuses(currentStats(), calculateGearBonuses(currentStats())));
    }

    async function removeGeneratedGearFromCharacter(gear) {
      if (!gear) return;
      const signature = gearSignature(gear);
      const entry = characterGear.find(item => item.gear && gearSignature(item.gear) === signature);
      if (!entry) {
        pushStatus("That gear isn't on this character.", { tone: "warning" });
        gear.__added = false;
        renderGeneratedGear(applyGearBonuses(currentStats(), calculateGearBonuses(currentStats())));
        return;
      }
      activeGearRow = entry;
      await deleteGear({ mode: "delete" });
      gear.__added = false;
      renderGeneratedGear(applyGearBonuses(currentStats(), calculateGearBonuses(currentStats())));
    }

    async function addPastedGearFromJson() {
      pasteStatus.textContent = "";
      try {
        const parsed = JSON.parse(gearPasteInput.value.trim());
        const gearItems = Array.isArray(parsed) ? parsed : [parsed];
        let added = 0;
        for (const gear of gearItems) {
          const inserted = await insertGearToInventory(gear);
          if (inserted) {
            added += 1;
          }
        }
        gearPasteInput.value = "";
        if (added) {
          pasteStatus.textContent = "Pasted gear added.";
          pushStatus(`Added ${added} pasted gear item(s).`, { tone: "success" });
        } else {
          pasteStatus.textContent = "No gear added.";
          pushStatus("No new gear was added.", { tone: "warning" });
        }
      } catch (error) {
        console.error(error);
        pasteStatus.textContent = "Invalid JSON.";
        pushStatus("Invalid gear JSON.", { tone: "error" });
      }
    }

    function openGearDetailModal(entry) {
      if (!entry) return;
      activeGearRow = entry;
      const gear = entry.gear;
      const gearType = gear.gear_type || gear.gearType;
      gearDetailTitle.textContent = formatGearName(gear);
      gearNameInput.value = gear.name || formatGearName(gear);
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const colorCounts = getEquippedColorCounts();
      const gValue = gearType === "Bauble" && gear.color ? (colorCounts[gear.color] || 0) : 0;
      const statList = renderGearStatsList(gear.stats, gear.stat_modifiers, stats.luck, { g: gValue });
      gearDetailBody.innerHTML = `
        <div>
          <strong>Summary</strong>
          <ul>
            <li>Type: ${gearType}</li>
            <li>Rarity: ${gear.rarity}</li>
            <li>Color: ${[gear.color, gear.color2].filter(Boolean).join(" / ") || "Neutral"}</li>
            <li>Item: ${gear.item_type || "Unknown"}</li>
            <li>Aesthetic: ${gear.aesthetic || "None"}</li>
            <li>Essence Value: ${gear.essence_value}</li>
          </ul>
        </div>
        <div>
          <strong>Stats</strong>
          ${statList}
        </div>
        <div>
          <strong>Abilities</strong>
          ${renderAbilityDetails(gear.abilities)}
        </div>
      `;
      gearDetailStatus.textContent = "";
      gearDetailModal.classList.remove("hidden");
    }

    function closeGearDetailModal() {
      gearDetailModal.classList.add("hidden");
    }

    async function saveGearNameUpdate() {
      if (!activeGearRow) return;
      const newName = gearNameInput.value.trim();
      if (!newName) {
        gearDetailStatus.textContent = "Name cannot be empty.";
        pushStatus("Gear name cannot be empty.", { tone: "warning" });
        return;
      }
      const { error } = await sb
        .from("webrunning_gear")
        .update({ name: newName })
        .eq("id", activeGearRow.gear_id);
      if (error) {
        gearDetailStatus.textContent = error.message;
        pushStatus(error.message, { tone: "error" });
        return;
      }
      activeGearRow.gear.name = newName;
      gearDetailTitle.textContent = newName;
      gearDetailStatus.textContent = "Name saved.";
      pushStatus("Gear name saved.", { tone: "success" });
      render();
    }

    async function copyGearJsonToClipboard() {
      if (!activeGearRow) return;
      const gear = activeGearRow.gear;
      const payload = {
        name: gear.name,
        rarity: gear.rarity,
        color: gear.color,
        color2: gear.color2,
        gear_type: gear.gear_type,
        aesthetic: gear.aesthetic,
        item_type: gear.item_type,
        stats: gear.stats,
        essence_value: gear.essence_value,
        credit_value: gear.credit_value,
        abilities: gear.abilities,
        stat_modifiers: gear.stat_modifiers
      };
      try {
        await navigator.clipboard.writeText(JSON.stringify(payload, null, 2));
        gearDetailStatus.textContent = "Copied to clipboard.";
        pushStatus("Copied gear JSON to clipboard.", { tone: "success" });
      } catch (error) {
        console.error(error);
        gearDetailStatus.textContent = "Copy failed.";
        pushStatus("Copy failed.", { tone: "error" });
      }
    }

    function addDeletedGearHistory(entry, mode) {
      const snapshot = {
        id: `${Date.now()}-${Math.random().toString(16).slice(2)}`,
        deletedAt: new Date(),
        mode,
        entry: {
          gear_id: entry.gear_id,
          gear_slot: entry.gear_slot,
          equipped: entry.equipped,
          gear: entry.gear
        }
      };
      deletedGearHistory.unshift(snapshot);
      renderDeletedGearHistory();
      return snapshot;
    }

    function renderDeletedGearHistory() {
      if (!elements.deletedGearHistory) return;
      if (!deletedGearHistory.length) {
        elements.deletedGearHistory.innerHTML = `<span class="muted">No deleted gear yet.</span>`;
        return;
      }
      elements.deletedGearHistory.innerHTML = deletedGearHistory
        .map(record => `
          <div class="deletion-history-item">
            <div>
              <strong>${formatGearName(record.entry.gear)}</strong>
              <div class="muted">${record.deletedAt.toLocaleString()}</div>
            </div>
            <button type="button" data-action="restore" data-record="${record.id}">Restore</button>
          </div>
        `)
        .join("");
    }

    function resolveRestoreSlot(entry, stats) {
      const gearType = entry.gear.gear_type || entry.gear.gearType;
      if (entry.gear_slot === "inventory") {
        if (inventoryCount() < inventoryCapacity(stats)) return "inventory";
        return null;
      }
      if (entry.gear_slot === "local_node") {
        if (localNodeCount() < localNodeCapacity(stats)) return "local_node";
        return null;
      }
      const available = availableSlotsForGear(entry.gear, stats);
      if (available.includes(entry.gear_slot)) return entry.gear_slot;
      if (available.length) return available[0];
      return gearType === "Bauble" ? "inventory" : null;
    }

    async function restoreDeletedGear(recordId) {
      const recordIndex = deletedGearHistory.findIndex(record => record.id === recordId);
      if (recordIndex === -1) return;
      const record = deletedGearHistory[recordIndex];
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const slot = resolveRestoreSlot(record.entry, stats);
      if (!slot) {
        pushStatus("No available slot to restore that gear.", { tone: "warning" });
        return;
      }
      try {
        const inserted = await insertGearToInventory(record.entry.gear, { slot });
        if (!inserted) return;
        deletedGearHistory.splice(recordIndex, 1);
        renderDeletedGearHistory();
        pushStatus("Gear restored.", { tone: "success" });
      } catch (error) {
        console.error(error);
        pushStatus("Failed to restore gear.", { tone: "error" });
      }
    }

    async function deleteGear({ mode = "delete" } = {}) {
      if (!activeGearRow) return;
      const gear = activeGearRow.gear;
      try {
        if (mode === "dissolve") {
          const updatedEssence = (activeCharacter.base_stats?.essence || 0) + (gear.essence_value || 0);
          const { error: characterError } = await sb
            .from("webrunning_characters")
            .update({ base_stats: { ...activeCharacter.base_stats, essence: updatedEssence } })
            .eq("id", activeCharacter.id)
            .eq("user_id", currentUser.id);
          if (characterError) throw characterError;
          activeCharacter.base_stats.essence = updatedEssence;
          pushStatus(`Added ${gear.essence_value || 0} essence to your bank.`, { tone: "success" });
        }

        const { error: linkError } = await sb
          .from("webrunning_character_gear")
          .delete()
          .eq("character_id", activeCharacter.id)
          .eq("gear_id", activeGearRow.gear_id);
        if (linkError) throw linkError;

        const { error: gearError } = await sb
          .from("webrunning_gear")
          .delete()
          .eq("id", activeGearRow.gear_id);
        if (gearError) throw gearError;

        const deletedRecord = addDeletedGearHistory(activeGearRow, mode);
        characterGear = characterGear.filter(entry => entry.gear_id !== activeGearRow.gear_id);
        generatedGear.forEach(item => {
          if (item && gearSignature(item) === gearSignature(gear)) {
            item.__added = false;
          }
        });
        closeGearDetailModal();
        render();
        pushStatus("Gear deleted.", {
          tone: "warning",
          actionLabel: "Undo",
          onAction: () => restoreDeletedGear(deletedRecord.id),
          duration: 8000
        });
      } catch (error) {
        console.error(error);
        gearDetailStatus.textContent = "Failed to delete gear.";
        pushStatus("Failed to delete gear.", { tone: "error" });
      }
    }

    async function updateGearSlot(entry, slot) {
      const equipped = slot !== "inventory" && slot !== "local_node";
      const { error } = await sb
        .from("webrunning_character_gear")
        .update({ gear_slot: slot, equipped })
        .eq("character_id", activeCharacter.id)
        .eq("gear_id", entry.gear_id);
      if (error) throw error;
      entry.gear_slot = slot;
      entry.equipped = equipped;
      render();
    }

    async function equipGear(entry) {
      if (!entry) return;
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const availableSlots = availableSlotsForGear(entry.gear, stats);
      if (!availableSlots.length) {
        const swapOptions = getSwapOptionsForGear(entry.gear, stats);
        if (!swapOptions.length) {
          pushStatus("No open slots for that gear.", { tone: "warning" });
          return;
        }
        if (inventoryCount() >= inventoryCapacity(stats)) {
          pushStatus("No inventory slots available to swap gear.", { tone: "warning" });
          return;
        }
        const selected = selectSwapSlot(swapOptions);
        if (!selected) {
          pushStatus("No swap targets available.", { tone: "warning" });
          return;
        }
        await updateGearSlot(entry, selected.slot);
        await updateGearSlot(selected.entry, "inventory");
        return;
      }
      await updateGearSlot(entry, availableSlots[0]);
    }

    async function moveGearToInventory(entry) {
      if (!entry) return;
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      if (inventoryCount() >= inventoryCapacity(stats)) {
        pushStatus("No inventory slots available.", { tone: "warning" });
        return;
      }
      await updateGearSlot(entry, "inventory");
    }

    async function moveGearToLocalNode(entry) {
      if (!entry) return;
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      if (localNodeCount() >= localNodeCapacity(stats)) {
        pushStatus("No local node slots available.", { tone: "warning" });
        return;
      }
      await updateGearSlot(entry, "local_node");
    }

    function updateDerived(stats, gearBonus) {
      const derived = deriveSecondaryStats(stats);
      const derivedBonus = gearBonus?.derived || {};
      const sources = gearBonus?.sources || createEmptyBonusSources();
      const statusStacks = getStatusStacks(stats);
      const statusAdjustments = {
        attackPlus: -statusStacks.poison,
        damagePlus: -statusStacks.poison,
        defenseDc: -statusStacks.freeze,
        armor: -statusStacks.freeze
      };
      const totalPerception = derived.perception + (derivedBonus.perception || 0);
      const aoeMultiplier = getAoeBuffMultiplier();
      const aoeRange = (totalPerception * aoeMultiplier) + (derivedBonus.aoeRange || 0);

      const attackSources = combineSourceLists(
        sources.derived.attackPlus,
        sources.base.power,
        statusStacks.poison ? [{ label: "Poison", value: statusAdjustments.attackPlus }] : []
      );
      const damageSources = combineSourceLists(
        sources.derived.damagePlus,
        sources.base.power,
        statusStacks.poison ? [{ label: "Poison", value: statusAdjustments.damagePlus }] : []
      );
      const defenseDcSources = combineSourceLists(
        sources.derived.defenseDc,
        sources.base.defense,
        statusStacks.freeze ? [{ label: "Freeze", value: statusAdjustments.defenseDc }] : []
      );
      const armorSources = combineSourceLists(
        sources.derived.armor,
        sources.base.defense,
        statusStacks.freeze ? [{ label: "Freeze", value: statusAdjustments.armor }] : []
      );
      const initiativeSources = combineSourceLists(sources.derived.initiative, sources.base.speed);
      const movementSources = combineSourceLists(sources.derived.movementSpeed, scaleSourceList(sources.base.speed, 2));
      const rangeSources = combineSourceLists(sources.derived.range, sources.base.speed);
      const perceptionSources = combineSourceLists(sources.derived.perception, scaleSourceList(sources.base.intelligence, 2));
      const aoeRangeSources = combineSourceLists(sources.derived.aoeRange, scaleSourceList(sources.base.intelligence, 2 * aoeMultiplier));
      const hackingSources = combineSourceLists(sources.derived.hacking, sources.base.intelligence);

      setStatDisplay(
        elements.displayAttackPlus,
        derived.attackPlus + (derivedBonus.attackPlus || 0) + statusAdjustments.attackPlus,
        summarizeSources(attackSources)
      );
      setStatDisplay(
        elements.displayDamagePlus,
        derived.damagePlus + (derivedBonus.damagePlus || 0) + statusAdjustments.damagePlus,
        summarizeSources(damageSources)
      );
      setStatDisplay(
        elements.displayDefenseDc,
        derived.defenseDc + (derivedBonus.defenseDc || 0) + statusAdjustments.defenseDc,
        summarizeSources(defenseDcSources)
      );
      setStatDisplay(
        elements.displayArmor,
        derived.armor + (derivedBonus.armor || 0) + statusAdjustments.armor,
        summarizeSources(armorSources)
      );
      setStatDisplay(
        elements.displayInitiative,
        derived.initiative + (derivedBonus.initiative || 0),
        summarizeSources(initiativeSources)
      );
      setStatDisplay(
        elements.displayMovementSpeed,
        derived.movementSpeed + (derivedBonus.movementSpeed || 0),
        summarizeSources(movementSources)
      );
      setStatDisplay(
        elements.displayRange,
        derived.range + (derivedBonus.range || 0),
        summarizeSources(rangeSources)
      );
      setStatDisplay(
        elements.displayPerception,
        totalPerception,
        summarizeSources(perceptionSources)
      );
      setStatDisplay(
        elements.displayAoeRange,
        aoeRange,
        summarizeSources(aoeRangeSources)
      );
      setStatDisplay(
        elements.displayHacking,
        derived.hacking + (derivedBonus.hacking || 0),
        summarizeSources(hackingSources)
      );

      if (elements.displayDamageTaken) {
        elements.displayDamageTaken.textContent = formatSignedValue(statusStacks.burn);
      }
      if (elements.displayStatusDefenseDc) {
        elements.displayStatusDefenseDc.textContent = formatSignedValue(statusAdjustments.defenseDc);
      }
      if (elements.displayStatusArmor) {
        elements.displayStatusArmor.textContent = formatSignedValue(statusAdjustments.armor);
      }
      if (elements.displayStatusAttackPlus) {
        elements.displayStatusAttackPlus.textContent = formatSignedValue(statusAdjustments.attackPlus);
      }
      if (elements.displayStatusDamagePlus) {
        elements.displayStatusDamagePlus.textContent = formatSignedValue(statusAdjustments.damagePlus);
      }
    }

    function render() {
      const baseStats = currentStats();
      const gearBonus = calculateGearBonuses(baseStats);
      const stats = applyGearBonuses(baseStats, gearBonus);

      elements.displayName.textContent = activeCharacter?.name || "";
      elements.displayLevel.textContent = stats.level;
      elements.inputXp.value = baseStats.xp;
      const sources = gearBonus?.sources || createEmptyBonusSources();
      setStatDisplay(elements.displayLuck, stats.luck, summarizeSources(sources.base.luck));
      setStatDisplay(elements.displayHp, stats.hp, summarizeSources(sources.base.hp));
      setStatDisplay(elements.displayEnergyCap, stats.energy_cap, summarizeSources(sources.base.energy_cap));
      elements.inputEssence.value = baseStats.essence;
      elements.inputCurrentHp.value = baseStats.current_hp;
      elements.inputEnergyRed.value = baseStats.energy_red;
      elements.inputEnergyBlue.value = baseStats.energy_blue;
      elements.inputEnergyGreen.value = baseStats.energy_green;
      elements.inputEnergyGray.value = baseStats.energy_gray;
      setStatDisplay(elements.displayInventorySlots, stats.inventory_slots, summarizeSources(sources.base.inventory_slots));
      setStatDisplay(elements.displayKernelSlots, stats.kernel_slots, summarizeSources(sources.base.kernel_slots));

      elements.inputPower.value = baseStats.power;
      elements.inputDefense.value = baseStats.defense;
      elements.inputSpeed.value = baseStats.speed;
      elements.inputIntelligence.value = baseStats.intelligence;
      elements.inputStatusBurn.value = baseStats.status_burn;
      elements.inputStatusFreeze.value = baseStats.status_freeze;
      elements.inputStatusPoison.value = baseStats.status_poison;

      updateDerived(stats, gearBonus);
      renderGearSections(stats);
      renderAbilities();
      renderDeletedGearHistory();
      updateGearGeneratorLuck(stats);
    }

    async function requireUser() {
      const { data: { user } } = await sb.auth.getUser();
      if (!user) {
        pushStatus("Not logged in.", { tone: "error" });
        throw new Error("No user");
      }
      return user;
    }

    function formatSaveTimestamp(date = new Date()) {
      return date.toLocaleString(undefined, {
        month: "short",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      });
    }

    function updateSaveStatus(label) {
      pushStatus(`${label} ${formatSaveTimestamp()}`, { tone: "success" });
    }

    function markDirty() {
      isDirty = true;
    }

    async function autoSaveCharacter() {
      if (!isDirty || isSaving) return;
      await saveCharacter({ mode: "auto" });
    }

    function startAutosave() {
      if (autosaveTimer) {
        clearInterval(autosaveTimer);
      }
      autosaveTimer = setInterval(autoSaveCharacter, 45000);
    }

    async function loadCharacter() {
      try {
        currentUser = await requireUser();
        const params = new URLSearchParams(window.location.search);
        const characterId = params.get("id");
        let query = sb
          .from("webrunning_characters")
          .select("id, name, base_stats, status_effects, notes")
          .eq("user_id", currentUser.id);

        if (characterId) {
          query = query.eq("id", characterId);
        } else {
          query = query.order("created_at", { ascending: true }).limit(1);
        }

        const { data, error } = await query.maybeSingle();

        if (error) throw error;

        activeCharacter = data || {
          id: null,
          name: "",
          base_stats: { ...defaults },
          status_effects: null
        };

        if (activeCharacter.status_effects) {
          activeCharacter.status_effects = normalizeStatusEffects(activeCharacter.status_effects);
        }
        if (activeCharacter.base_stats) {
          activeCharacter.base_stats = mergeStatusEffectsIntoStats(
            activeCharacter.base_stats,
            activeCharacter.status_effects
          );
        }

        elements.nameInput.value = activeCharacter.name || "";
        if (elements.notesInput) {
          elements.notesInput.value = activeCharacter.notes || "";
        }
        render();
        if (activeCharacter.id) {
          await loadCharacterGear();
        }
      } catch (e) {
        console.error(e);
        pushStatus("Failed to load character.", { tone: "error" });
      }
    }

    async function loadCharacterGear() {
      if (!activeCharacter?.id) return;
      try {
        const { data, error } = await sb
          .from("webrunning_character_gear")
          .select("gear_id, equipped, gear_slot, gear:webrunning_gear(*)")
          .eq("character_id", activeCharacter.id);
        if (error) throw error;
        characterGear = (data || []).map(row => ({
          gear_id: row.gear_id,
          equipped: row.equipped,
          gear_slot: row.gear_slot,
          gear: row.gear
        }));
        render();
      } catch (error) {
        console.error(error);
        pushStatus("Failed to load gear.", { tone: "error" });
      }
    }

    function readBaseStatsFromForm() {
      const stats = currentStats();
      stats.xp = Number(elements.inputXp.value) || 0;
      stats.essence = Number(elements.inputEssence.value) || 0;
      stats.current_hp = Number(elements.inputCurrentHp.value) || 0;
      stats.energy_red = Number(elements.inputEnergyRed.value) || 0;
      stats.energy_blue = Number(elements.inputEnergyBlue.value) || 0;
      stats.energy_gray = Number(elements.inputEnergyGray.value) || 0;
      stats.energy_green = Number(elements.inputEnergyGreen.value) || 0;
      stats.power = Number(elements.inputPower.value) || 0;
      stats.defense = Number(elements.inputDefense.value) || 0;
      stats.speed = Number(elements.inputSpeed.value) || 0;
      stats.intelligence = Number(elements.inputIntelligence.value) || 0;
      stats.status_burn = Number(elements.inputStatusBurn.value) || 0;
      stats.status_freeze = Number(elements.inputStatusFreeze.value) || 0;
      stats.status_poison = Number(elements.inputStatusPoison.value) || 0;
      return stats;
    }

    async function saveCharacter({ mode = "manual" } = {}) {
      if (isSaving) return;
      const name = elements.nameInput.value.trim();
      if (!name) {
        if (mode === "manual") {
          pushStatus("Name cannot be empty.", { tone: "warning" });
        }
        return;
      }

      if (!/^[a-zA-Z0-9 _-]+$/.test(name)) {
        if (mode === "manual") {
          pushStatus("Invalid characters in name.", { tone: "warning" });
        }
        return;
      }

      try {
        isSaving = true;
        currentUser = await requireUser();
        const baseStats = readBaseStatsFromForm();
        const notes = elements.notesInput ? elements.notesInput.value.trim() : "";

        if (activeCharacter?.id) {
          const { error } = await sb
            .from("webrunning_characters")
            .update({
              name,
              base_stats: baseStats,
              status_effects: getStatusEffectsPayload(baseStats),
              notes
            })
            .eq("id", activeCharacter.id)
            .eq("user_id", currentUser.id);
          if (error) throw error;
        } else {
          const { data, error } = await sb
            .from("webrunning_characters")
            .insert({
              user_id: currentUser.id,
              name,
              base_stats: baseStats,
              status_effects: getStatusEffectsPayload(baseStats),
              notes
            })
            .select("id, name, base_stats, status_effects, notes")
            .maybeSingle();
          if (error) throw error;
          activeCharacter = data;
          if (activeCharacter?.status_effects) {
            activeCharacter.status_effects = normalizeStatusEffects(activeCharacter.status_effects);
            activeCharacter.base_stats = mergeStatusEffectsIntoStats(
              activeCharacter.base_stats,
              activeCharacter.status_effects
            );
          }
        }

        isDirty = false;
        activeCharacter.name = name;
        activeCharacter.base_stats = baseStats;
        activeCharacter.status_effects = getStatusEffectsPayload(baseStats);
        activeCharacter.notes = notes;
        render();
        updateSaveStatus(mode === "auto" ? "Autosaved:" : "Saved:");
      } catch (e) {
        console.error(e);
        pushStatus(e.message, { tone: "error" });
      } finally {
        isSaving = false;
      }
    }

    function populateLevelSelect() {
      targetLevelSelect.innerHTML = "";
      const stats = currentStats();
      levelTable.forEach(entry => {
        const option = document.createElement("option");
        option.value = entry.level;
        option.textContent = entry.level === stats.level ? `Level ${entry.level} (Current)` : `Level ${entry.level}`;
        targetLevelSelect.appendChild(option);
      });
      targetLevelSelect.value = String(stats.level);
    }

    function getLevelEntry(level) {
      return levelTable.find(entry => entry.level === Number(level));
    }

    function calculatePointDelta(startLevel, targetLevel) {
      if (targetLevel === startLevel) return 0;
      const minLevel = Math.min(startLevel, targetLevel);
      const maxLevel = Math.max(startLevel, targetLevel);
      const points = levelTable
        .filter(entry => entry.level > minLevel && entry.level <= maxLevel)
        .reduce((sum, entry) => sum + (entry.statPoints || 0), 0);
      return targetLevel > startLevel ? points : -points;
    }

    function updateLevelPreview() {
      const stats = currentStats();
      const targetLevel = Number(targetLevelSelect.value);
      const entry = getLevelEntry(targetLevel);
      if (!entry) {
        levelPreview.innerHTML = "";
        return;
      }
      const pointDelta = calculatePointDelta(stats.level, targetLevel);
      const pointsLabel = pointDelta > 0
        ? "Stat Points to allocate"
        : pointDelta < 0
          ? "Stat Points to remove"
          : "Stat Points";
      const pointsValue = Math.abs(pointDelta);
      levelPreview.innerHTML = `
        <li>Level: ${stats.level} → ${entry.level}</li>
        <li>XP: ${stats.xp} (manual)</li>
        <li>Base HP: ${stats.hp} → ${entry.baseHp}</li>
        <li>Energy Cap: ${stats.energy_cap} → ${entry.energyCap}</li>
        <li>Kernel Slots: ${stats.kernel_slots} → ${entry.kernelSlots}</li>
        <li>Inventory Slots: ${stats.inventory_slots} → ${entry.inventorySlots}</li>
        <li>Luck: ${stats.luck} → ${entry.baseLuck}</li>
        <li>${pointsLabel}: ${pointsValue}</li>
      `;
      updateRemainingPoints(pointsValue);
    }

    function updateRemainingPoints(availablePoints) {
      const allocated =
        (Number(levelPower.value) || 0) +
        (Number(levelDefense.value) || 0) +
        (Number(levelSpeed.value) || 0) +
        (Number(levelIntelligence.value) || 0);
      pointsRemaining.textContent = Math.max(availablePoints - allocated, 0);
    }

    function resetLevelInputs() {
      levelPower.value = 0;
      levelDefense.value = 0;
      levelSpeed.value = 0;
      levelIntelligence.value = 0;
      levelError.textContent = "";
    }

    function openLevelModal() {
      populateLevelSelect();
      if (!targetLevelSelect.options.length) {
        pushStatus("No other levels available.", { tone: "warning" });
        return;
      }
      resetLevelInputs();
      updateLevelPreview();
      modal.classList.remove("hidden");
    }

    function closeLevelModal() {
      modal.classList.add("hidden");
    }

    function initCollapsibles() {
      document.querySelectorAll("[data-collapsible]").forEach(section => {
        const button = section.querySelector(".collapse-toggle");
        if (!button) return;
        const isCollapsed = section.classList.contains("collapsed");
        button.textContent = isCollapsed ? "Show" : "Hide";
        button.addEventListener("click", () => {
          const nowCollapsed = section.classList.toggle("collapsed");
          button.textContent = nowCollapsed ? "Show" : "Hide";
        });
      });
    }

    async function applyLevelUp() {
      const stats = currentStats();
      const targetLevel = Number(targetLevelSelect.value);
      const entry = getLevelEntry(targetLevel);
      if (!entry) return;

      const pointDelta = calculatePointDelta(stats.level, targetLevel);
      const requiredPoints = Math.abs(pointDelta);
      const powerPoints = Number(levelPower.value) || 0;
      const defensePoints = Number(levelDefense.value) || 0;
      const speedPoints = Number(levelSpeed.value) || 0;
      const intelligencePoints = Number(levelIntelligence.value) || 0;
      const totalAllocated = powerPoints + defensePoints + speedPoints + intelligencePoints;

      if (totalAllocated !== requiredPoints) {
        levelError.textContent = pointDelta > 0
          ? "Allocate all available stat points before applying."
          : pointDelta < 0
            ? "Remove all required stat points before applying."
            : "No stat points are required for this level.";
        return;
      }

      if (
        pointDelta < 0 &&
        (stats.power - powerPoints < 0 ||
          stats.defense - defensePoints < 0 ||
          stats.speed - speedPoints < 0 ||
          stats.intelligence - intelligencePoints < 0)
      ) {
        levelError.textContent = "Cannot remove more stat points than you currently have.";
        return;
      }

      const updatedStats = {
        ...stats,
        level: entry.level,
        hp: entry.baseHp,
        energy_cap: entry.energyCap,
        kernel_slots: entry.kernelSlots,
        inventory_slots: entry.inventorySlots,
        luck: entry.baseLuck,
        power: stats.power + (pointDelta >= 0 ? powerPoints : -powerPoints),
        defense: stats.defense + (pointDelta >= 0 ? defensePoints : -defensePoints),
        speed: stats.speed + (pointDelta >= 0 ? speedPoints : -speedPoints),
        intelligence: stats.intelligence + (pointDelta >= 0 ? intelligencePoints : -intelligencePoints)
      };
      updatedStats.current_hp = Math.min(updatedStats.current_hp ?? updatedStats.hp, updatedStats.hp);

      try {
        currentUser = await requireUser();
        if (!activeCharacter?.id) {
          levelError.textContent = "Save the character before leveling up.";
          return;
        }
        const { error } = await sb
          .from("webrunning_characters")
          .update({ base_stats: updatedStats })
          .eq("id", activeCharacter.id)
          .eq("user_id", currentUser.id);
        if (error) throw error;

        activeCharacter.base_stats = updatedStats;
        render();
        closeLevelModal();
      } catch (e) {
        console.error(e);
        levelError.textContent = e.message;
      }
    }

    [
      elements.inputXp,
      elements.inputEssence,
      elements.inputCurrentHp,
      elements.inputEnergyRed,
      elements.inputEnergyBlue,
      elements.inputEnergyGreen,
      elements.inputEnergyGray,
      elements.inputPower,
      elements.inputDefense,
      elements.inputSpeed,
      elements.inputIntelligence,
      elements.inputStatusBurn,
      elements.inputStatusFreeze,
      elements.inputStatusPoison
    ]
      .forEach(input => {
        input.addEventListener("input", () => {
          markDirty();
          const stats = readBaseStatsFromForm();
          if (activeCharacter) {
            activeCharacter.base_stats = stats;
          }
          render();
        });
      });

    [levelPower, levelDefense, levelSpeed, levelIntelligence].forEach(input => {
      input.addEventListener("input", () => {
        const stats = currentStats();
        const targetLevel = Number(targetLevelSelect.value);
        const pointDelta = calculatePointDelta(stats.level, targetLevel);
        updateRemainingPoints(Math.abs(pointDelta));
      });
    });

    targetLevelSelect.addEventListener("change", () => {
      resetLevelInputs();
      updateLevelPreview();
    });

    document.getElementById("levelUpButton").addEventListener("click", openLevelModal);
    document.getElementById("confirmLevelUp").addEventListener("click", applyLevelUp);
    document.getElementById("cancelLevelUp").addEventListener("click", closeLevelModal);
    modalBackdrop.addEventListener("click", closeLevelModal);
    elements.saveButton.addEventListener("click", saveCharacter);
    elements.nameInput.addEventListener("input", markDirty);
    if (elements.notesInput) {
      elements.notesInput.addEventListener("input", () => {
        markDirty();
        if (activeCharacter) {
          activeCharacter.notes = elements.notesInput.value;
        }
      });
    }

    elements.openGearGenerator.addEventListener("click", openGearGeneratorModal);
    closeGearGenerator.addEventListener("click", closeGearGeneratorModal);
    gearGeneratorBackdrop.addEventListener("click", closeGearGeneratorModal);
    generateGearButton.addEventListener("click", handleGenerateGear);
    addAllGeneratedGearButton.addEventListener("click", addAllGeneratedGear);
    gearBonusLuck.addEventListener("input", () => {
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      updateGearGeneratorLuck(stats);
    });
    addPastedGear.addEventListener("click", addPastedGearFromJson);
    addManualGearButton.addEventListener("click", handleManualGearAdd);
    addManualGearStat.addEventListener("click", () => createManualStatRow());
    addManualGearAbility.addEventListener("click", () => createManualAbilityRow());
    manualGearType.addEventListener("change", refreshManualStatRowsForType);

    [gearSortField, gearSortDirection, gearFilterRarity, gearFilterType, gearFilterColor, gearFilterStat]
      .forEach(select => {
        if (!select) return;
        select.addEventListener("change", () => {
          const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
          renderGearSections(stats);
        });
      });

    generatedGearList.addEventListener("click", event => {
      const button = event.target.closest("button");
      if (!button) return;
      const action = button.dataset.action;
      const index = Number(button.dataset.index);
      if (action === "add") {
        addGeneratedGear(index, "add");
      } else if (action === "equip") {
        addGeneratedGear(index, "equip");
      } else if (action === "remove") {
        if (!Number.isFinite(index)) return;
        removeGeneratedGearFromCharacter(generatedGear[index]);
      }
    });

    function handleGearListClick(event) {
      const button = event.target.closest("button");
      if (!button) return;
      const action = button.dataset.action;
      const gearId = button.dataset.gear;
      if (!action || !gearId) return;
      const entry = findGearEntry(gearId);
      if (!entry) return;
      if (action === "view") {
        openGearDetailModal(entry);
      } else if (action === "equip") {
        equipGear(entry);
      } else if (action === "unequip" || action === "inventory") {
        moveGearToInventory(entry);
      } else if (action === "local") {
        moveGearToLocalNode(entry);
      } else if (action === "dissolve") {
        activeGearRow = entry;
        deleteGear({ mode: "dissolve" });
      } else if (action === "delete") {
        activeGearRow = entry;
        deleteGear({ mode: "delete" });
      }
    }

    elements.equippedSlots.addEventListener("click", handleGearListClick);
    elements.inventorySlots.addEventListener("click", handleGearListClick);
    elements.localNodeSlots.addEventListener("click", handleGearListClick);

    closeGearDetail.addEventListener("click", closeGearDetailModal);
    gearDetailBackdrop.addEventListener("click", closeGearDetailModal);
    saveGearName.addEventListener("click", saveGearNameUpdate);
    gearNameInput.addEventListener("change", saveGearNameUpdate);
    gearNameInput.addEventListener("blur", saveGearNameUpdate);
    copyGearJson.addEventListener("click", copyGearJsonToClipboard);
    deleteGearButton.addEventListener("click", () => deleteGear({ mode: "delete" }));
    dissolveGearButton.addEventListener("click", () => deleteGear({ mode: "dissolve" }));

    if (elements.deletedGearHistory) {
      elements.deletedGearHistory.addEventListener("click", event => {
        const button = event.target.closest("button");
        if (!button) return;
        const action = button.dataset.action;
        if (action !== "restore") return;
        const recordId = button.dataset.record;
        restoreDeletedGear(recordId);
      });
    }

    window.addEventListener("DOMContentLoaded", () => {
      populateGearFilterSelects();
      if (manualGearStatsList && !manualGearStatsList.children.length) {
        createManualStatRow();
      }
      if (manualGearAbilitiesList && !manualGearAbilitiesList.children.length) {
        createManualAbilityRow();
      }
      loadCharacter();
      initCollapsibles();
      startAutosave();
      ensurePyodide().catch(() => {});
    });
  </script>
</body>
</html>
