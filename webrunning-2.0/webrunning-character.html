<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Webrunning Character Sheet</title>
  <link rel="stylesheet" href="/shared/style.css">
</head>
<body class="wr-scope">
  <div id="nav"></div>

  <main class="wrap sheet">
    <header>
      <a href="/webrunning-2.0/webrunning-character-manager.html" aria-label="Back to character manager">← Back to Character Manager</a>
      <h1>Webrunning Character Sheet</h1>
      <p>Use this page to track your character stats, gear, and progression.</p>
    </header>

    <section class="card">
      <h2>Character</h2>
      <div class="sheet-actions">
        <label>
          <span class="muted">Character Name</span>
          <input id="characterName" type="text" maxlength="32" placeholder="Character name" />
        </label>
        <button id="saveCharacter" type="button" aria-label="Save character" title="Save character"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M5 4h12l2 2v14H5z"></path><path d="M8 4v6h8V4"></path><path d="M8 16h8"></path></svg></button>
        <button id="levelUpButton" type="button" aria-label="Level up" title="Level up"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 19V5"></path><path d="M7 10l5-5 5 5"></path></svg><span>Level Up</span></button>
      </div>
    </section>

    <section class="card">
      <h2>Core Info</h2>
      <div class="stats-grid core-info">
        <dl>
          <dt>Name:</dt>
          <dd id="displayName"></dd>
          <dt>Level:</dt>
          <dd id="displayLevel">1</dd>
          <dt>XP:</dt>
          <dd>
            <input id="inputXp" type="number" min="0" value="0" />
          </dd>
          <dt>Luck:</dt>
          <dd id="displayLuck">1</dd>
        </dl>
        <dl>
          <dt>Max HP:</dt>
          <dd id="displayHp">10</dd>
          <dt>Current HP:</dt>
          <dd>
            <input id="inputCurrentHp" type="number" min="0" value="10" />
          </dd>
          <dt>Energy Cap:</dt>
          <dd id="displayEnergyCap">5</dd>
          <dt>Essence:</dt>
          <dd>
            <input id="inputEssence" type="number" min="0" value="0" />
          </dd>
        </dl>
      </div>
      <div class="stat-inputs" style="margin-top: 0.75rem;">
        <label>Energy (Red)
          <input id="inputEnergyRed" type="number" min="0" value="0" />
        </label>
        <label>Energy (Blue)
          <input id="inputEnergyBlue" type="number" min="0" value="0" />
        </label>
        <label>Energy (Green)
          <input id="inputEnergyGreen" type="number" min="0" value="0" />
        </label>
        <label>Energy (Gray)
          <input id="inputEnergyGray" type="number" min="0" value="0" />
        </label>
      </div>
    </section>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>Stats</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
      <div class="collapsible-body section-stack">
        <section class="card section-card">
          <h3>Basic Stats</h3>
          <div class="stat-inputs">
            <label>Power
              <input id="inputPower" type="number" min="0" value="0" />
            </label>
            <label>Defense
              <input id="inputDefense" type="number" min="0" value="0" />
            </label>
            <label>Speed
              <input id="inputSpeed" type="number" min="0" value="0" />
            </label>
            <label>Intelligence
              <input id="inputIntelligence" type="number" min="0" value="0" />
            </label>
          </div>
        </section>

        <section class="card collapsible section-card" data-collapsible>
          <div class="collapsible-header">
            <h3>Secondary Stats</h3>
            <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
          </div>
          <div class="collapsible-body">
            <p class="muted">Tied to Basic Stats and increased by equipping gear.</p>
            <div class="stats-grid">
              <dl>
                <dt>Attack Plus:</dt>
                <dd id="displayAttackPlus">0</dd>
                <dt>Damage Plus:</dt>
                <dd id="displayDamagePlus">0</dd>
                <dt>Attack Damage Limit:</dt>
                <dd id="displayAttackDamageLimit">0</dd>
                <dt>Combo Damage Limit:</dt>
                <dd id="displayComboDamageLimit">0</dd>
                <dt>Defense DC:</dt>
                <dd id="displayDefenseDc">10</dd>
                <dt>Armor:</dt>
                <dd id="displayArmor">0</dd>
                <dt>Initiative:</dt>
                <dd id="displayInitiative">0</dd>
                <dt>Movement Speed:</dt>
                <dd id="displayMovementSpeed">10</dd>
                <dt>Range:</dt>
                <dd id="displayRange">5</dd>
                <dt>Perception:</dt>
                <dd id="displayPerception">0</dd>
                <dt>AOE Range:</dt>
                <dd id="displayAoeRange">0</dd>
                <dt>Hacking:</dt>
                <dd id="displayHacking">0</dd>
              </dl>
            </div>
          </div>
        </section>

        <section class="card collapsible section-card" data-collapsible>
          <div class="collapsible-header">
            <h3>Neutral Buffs</h3>
            <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
          </div>
          <div class="collapsible-body">
            <div class="stats-grid">
              <dl>
                <dt>Inventory Slots:</dt>
                <dd id="displayInventorySlots">10</dd>
                <dt>Kernel Slots:</dt>
                <dd id="displayKernelSlots">1</dd>
                <dt>Energy Conversion:</dt>
                <dd>0</dd>
                <dt>Group XP Gain:</dt>
                <dd>0</dd>
                <dt>HP Regen:</dt>
                <dd>0</dd>
                <dt>Resell Value:</dt>
                <dd>0</dd>
              </dl>
              <dl id="adventuringPlusesColumn" class="hidden">
                <dt>Adventuring Pluses:</dt>
                <dd id="displayAdventuringPluses"></dd>
              </dl>
            </div>
          </div>
        </section>

        <section class="card collapsible section-card" data-collapsible>
          <div class="collapsible-header">
            <h3>Status Effects</h3>
            <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
          </div>
          <div class="collapsible-body">
            <div class="stat-inputs">
              <label>Burn
                <input id="inputStatusBurn" type="number" min="0" value="0" />
              </label>
              <label>Freeze
                <input id="inputStatusFreeze" type="number" min="0" value="0" />
              </label>
              <label>Poison
                <input id="inputStatusPoison" type="number" min="0" value="0" />
              </label>
            </div>
            <br>
            <div class="stats-grid">
              <dl>
                <dt>Damage Taken Modifier:</dt>
                <dd id="displayDamageTaken">+0</dd>
                <dt>Defense DC Modifier:</dt>
                <dd id="displayStatusDefenseDc">+0</dd>
                <dt>Armor Modifier:</dt>
                <dd id="displayStatusArmor">+0</dd>
                <dt>Attack Plus Modifier:</dt>
                <dd id="displayStatusAttackPlus">+0</dd>
                <dt>Damage Plus Modifier:</dt>
                <dd id="displayStatusDamagePlus">+0</dd>
              </dl>
            </div>
          </div>
        </section>

        <section id="tempBuffSection" class="card collapsible section-card hidden" data-collapsible>
          <div class="collapsible-header">
            <h3>Active Temp Buffs</h3>
            <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
          </div>
          <div class="collapsible-body">
            <div class="gear-generator-actions">
              <span class="muted" id="tempBuffSummary">No active temporary consumable buffs.</span>
              <button id="clearTempBuffs" type="button" class="hidden" aria-label="Clear temporary buffs" title="Clear temporary buffs"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M3 14l7-7a2 2 0 0 1 3 0l8 8a2 2 0 0 1 0 3l-3 3H10z"></path><path d="M12 20l6-6"></path><path d="M3 21h7"></path></svg><span>Clear Buffs</span></button>
            </div>
          </div>
        </section>
      </div>
    </section>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>Abilities</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
      <div class="collapsible-body">
        <div id="abilitiesList" class="ability-section"></div>
      </div>
    </section>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>Gear</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
      <div class="collapsible-body section-stack">
        <section class="card collapsible section-card" data-collapsible>
          <div class="collapsible-header">
            <h3>Gear Generator</h3>
            <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
          </div>
          <div class="collapsible-body">
            <p class="muted">Click <a href="https://publish.obsidian.md/xeonrapture/xr/XRRPG+2.0/Sub-RPGs/Webrunning+2.0/Gear+Generation/Gear+Generation+and+Modification">here</a> for an explanation of gear generation.</p>
            <p class="muted">Generate gear with your current luck plus a bonus and add it to your inventory or equip it.</p>
            <div class="gear-generator-actions">
              <button id="openGearGenerator" type="button" class="hidden" aria-label="Generate gear" title="Generate gear"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="3"></circle><path d="M12 3v3M12 18v3M3 12h3M18 12h3M5.6 5.6l2.1 2.1M16.3 16.3l2.1 2.1M18.4 5.6l-2.1 2.1M7.7 16.3l-2.1 2.1"></path></svg><span>Generate Gear</span></button>
              <span id="gearGeneratorStatus" class="mono muted"></span>
            </div>
          </div>
        </section>

        <section class="card collapsible section-card" data-collapsible>
      <div class="collapsible-header">
        <h2>Gear Slots</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
      <div class="collapsible-body">
        <div id="equippedSlots" class="gear-grid"></div>
      </div>
        </section>

        <section class="card collapsible section-card" data-collapsible>
      <div class="collapsible-header">
        <h2>Inventory Slots</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
        <div class="collapsible-body">
        <div class="gear-controls">
          <div class="gear-controls-section">
            <div class="gear-controls-row">
              <label>
                Sort By
                <select id="gearSortField">
                  <option value="rarity">Rarity</option>
                  <option value="type">Gear Type</option>
                  <option value="color">Color</option>
                  <option value="name">Name</option>
                </select>
              </label>
              <label>
                Direction
                <select id="gearSortDirection">
                  <option value="asc">Ascending</option>
                  <option value="desc">Descending</option>
                </select>
              </label>
            </div>
          </div>
          <div class="gear-controls-divider" role="presentation"></div>
          <div class="gear-controls-section">
            <div class="gear-controls-row">
              <label>
                Filter Rarity
                <select id="gearFilterRarity">
                  <option value="">All</option>
                </select>
              </label>
              <label>
                Filter Gear Type
                <select id="gearFilterType">
                  <option value="">All</option>
                </select>
              </label>
              <label>
                Filter Color
                <select id="gearFilterColor">
                  <option value="">All</option>
                </select>
              </label>
            </div>
            <div class="gear-controls-row">
              <label>
                Filter Stat Modified
                <select id="gearFilterStat">
                  <option value="">All</option>
                </select>
              </label>
              <label>
                Filter Free Slot
                <select id="gearFilterFreeSlot">
                  <option value="">All</option>
                  <option value="has">Has Free Slot</option>
                  <option value="none">No Free Slot</option>
                </select>
              </label>
            </div>
            <span class="muted">Filters apply to inventory gear.</span>
          </div>
        </div>
        <div class="slot-count">Slots used: <span id="inventorySlotCount">0/0</span></div>
        <div id="inventorySlots" class="gear-grid"></div>
      </div>
        </section>

        <section class="card collapsible collapsed section-card" data-collapsible>
      <div class="collapsible-header">
        <h2>Local Node Storage</h2>
        <button class="collapse-toggle" type="button" aria-label="Show section" title="Show section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><circle cx="12" cy="12" r="2.5"></circle></svg></button>
      </div>
      <div class="collapsible-body">
        <p class="muted">Stored and can only be accessed in your local node.</p>
        <div class="gear-controls">
          <div class="gear-controls-section">
            <div class="gear-controls-row">
              <label>
                Filter Rarity
                <select id="localGearFilterRarity">
                  <option value="">All</option>
                </select>
              </label>
              <label>
                Filter Gear Type
                <select id="localGearFilterType">
                  <option value="">All</option>
                </select>
              </label>
              <label>
                Filter Color
                <select id="localGearFilterColor">
                  <option value="">All</option>
                </select>
              </label>
            </div>
            <div class="gear-controls-row">
              <label>
                Filter Stat Modified
                <select id="localGearFilterStat">
                  <option value="">All</option>
                </select>
              </label>
              <label>
                Filter Free Slot
                <select id="localGearFilterFreeSlot">
                  <option value="">All</option>
                  <option value="has">Has Free Slot</option>
                  <option value="none">No Free Slot</option>
                </select>
              </label>
            </div>
            <span class="muted">Filters apply to local node storage.</span>
          </div>
        </div>
        <div class="slot-count">Slots used: <span id="localNodeSlotCount">0/0</span></div>
        <div id="localNodeSlots" class="gear-grid"></div>
      </div>
        </section>

        <section class="card collapsible collapsed section-card" data-collapsible>
          <div class="collapsible-header">
            <h3>Deleted Gear History</h3>
            <button class="collapse-toggle" type="button" aria-label="Show section" title="Show section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><circle cx="12" cy="12" r="2.5"></circle></svg></button>
          </div>
          <div class="collapsible-body">
            <div id="deletedGearHistory" class="deletion-history"></div>
          </div>
        </section>
      </div>
    </section>

    <section class="card collapsible" data-collapsible>
      <div class="collapsible-header">
        <h2>Character Info</h2>
        <button class="collapse-toggle" type="button" aria-label="Hide section" title="Hide section"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg></button>
      </div>
      <div class="collapsible-body section-stack">
        <section class="card notes-area section-card">
          <h3>Character Notes</h3>
          <textarea id="characterNotes" placeholder="Add notes about your character, gear, or story beats..."></textarea>
        </section>
      </div>
    </section>

  </main>

  <div id="levelupModal" class="xr-modal hidden">
    <div class="xr-modal-backdrop"></div>
    <div class="xr-modal-card">
      <h2>Level Up</h2>
      <div class="modal-grid">
        <label>
          Target Level
          <select id="targetLevel"></select>
        </label>
        <div class="level-preview">
          <strong>Preview</strong>
          <ul id="levelPreview"></ul>
        </div>
        <div>
          <strong>Add Stat Points </strong>
          <div class="stat-inputs">
            <label>Power
              <input id="levelPower" type="number" min="0" value="0" />
            </label>
            <label>Defense
              <input id="levelDefense" type="number" min="0" value="0" />
            </label>
            <label>Speed
              <input id="levelSpeed" type="number" min="0" value="0" />
            </label>
            <label>Intelligence
              <input id="levelIntelligence" type="number" min="0" value="0" />
            </label>
          </div>
          <p class="muted">Points remaining: <span id="pointsRemaining">0</span></p>
          <p class="muted"><br>(these points subtract when levelling down)</p>
        </div>
        <div id="levelError" class="mono muted"></div>
      </div>
      <div class="xr-modal-actions">
        <button id="confirmLevelUp" type="button" aria-label="Apply level" title="Apply level"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><path d="M8 12l3 3 5-6"></path></svg></button>
        <button id="cancelLevelUp" type="button" aria-label="Cancel" title="Cancel"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M6 6l12 12"></path><path d="M18 6L6 18"></path></svg></button>
      </div>
    </div>
  </div>

  <div id="gearGeneratorModal" class="xr-modal hidden">
    <div class="xr-modal-backdrop"></div>
    <div class="xr-modal-card">
      <h2>Generate Gear</h2>
      <div class="modal-grid">
        <label>
          Bonus Luck
          <input id="gearBonusLuck" type="number" min="0" value="0" />
        </label>
        <label>
          Pieces
          <input id="gearAmount" type="number" min="1" value="1" />
        </label>
        <label>
          Gear Type
          <select id="gearTypeNumber">
            <option value="0">Random (None)</option>
            <option value="1">One-Handed Weapon</option>
            <option value="2">Two-Handed Weapon</option>
            <option value="3">Head</option>
            <option value="4">Torso</option>
            <option value="5">Hands</option>
            <option value="6">Legs</option>
            <option value="7">Feet</option>
            <option value="8">Ring</option>
            <option value="9">Neck</option>
            <option value="10">Kernel</option>
            <option value="11">Consumable</option>
            <option value="12">Bauble</option>
          </select>
        </label>
        <label>
          Rarity
          <select id="gearRarity">
            <option value="">Random (None)</option>
            <option value="Common">Common</option>
            <option value="Uncommon">Uncommon</option>
            <option value="Rare">Rare</option>
            <option value="Epic">Epic</option>
            <option value="Legendary">Legendary</option>
          </select>
        </label>
        <label>
          Color
          <select id="gearColor">
            <option value="">Random (None)</option>
            <option value="Neutral">Neutral</option>
            <option value="Red">Red</option>
            <option value="Blue">Blue</option>
            <option value="Green">Green</option>
            <option value="Gray">Gray</option>
          </select>
        </label>
        <label>
          Color 2
          <select id="gearColor2">
            <option value="">None</option>
            <option value="Neutral">Neutral</option>
            <option value="Red">Red</option>
            <option value="Blue">Blue</option>
            <option value="Green">Green</option>
            <option value="Gray">Gray</option>
          </select>
        </label>
        <div class="muted">Total luck used: <span id="gearTotalLuck">0</span></div>
      </div>
      <div class="xr-modal-actions">
        <button id="generateGear" type="button" aria-label="Generate" title="Generate"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="3"></circle><path d="M12 3v3M12 18v3M3 12h3M18 12h3M5.6 5.6l2.1 2.1M16.3 16.3l2.1 2.1M18.4 5.6l-2.1 2.1M7.7 16.3l-2.1 2.1"></path></svg><span>Generate</span></button>
        <button id="addAllGeneratedGear" type="button" disabled aria-label="Add all to inventory" title="Add all to inventory"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 4v10"></path><path d="M8 10l4 4 4-4"></path><path d="M4 20h16"></path></svg><span>Add All</span></button>
        <button id="closeGearGenerator" type="button" aria-label="Close" title="Close"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M6 6l12 12"></path><path d="M18 6L6 18"></path></svg><span>Close</span></button>
      </div>
      <div class="gear-details-list" style="margin-top:1rem;">
        <strong>Generated Gear</strong>
        <div id="generatedGearList" class="gear-grid"></div>
      </div>
      <details class="manual-gear-section">
        <summary>Generate Gear Manually</summary>
        <div class="manual-gear-grid">
          <label>
            Gear Name
            <input id="manualGearName" type="text" maxlength="60" placeholder="Optional custom name" />
          </label>
          <label>
            Gear Type
            <select id="manualGearType">
              <option value="One-Handed Weapon">One-Handed Weapon</option>
              <option value="Two-Handed Weapon">Two-Handed Weapon</option>
              <option value="Head">Head</option>
              <option value="Torso">Torso</option>
              <option value="Hands">Hands</option>
              <option value="Legs">Legs</option>
              <option value="Feet">Feet</option>
              <option value="Ring">Ring</option>
              <option value="Neck">Neck</option>
              <option value="Kernel">Kernel</option>
              <option value="Consumable">Consumable</option>
              <option value="Bauble">Bauble</option>
            </select>
          </label>
          <label>
            Rarity
            <select id="manualGearRarity">
              <option value="Basic">Basic</option>
              <option value="Common">Common</option>
              <option value="Uncommon">Uncommon</option>
              <option value="Rare">Rare</option>
              <option value="Epic">Epic</option>
              <option value="Legendary">Legendary</option>
            </select>
          </label>
          <label>
            Color
            <select id="manualGearColor">
              <option value="Neutral">Neutral</option>
              <option value="Red">Red</option>
              <option value="Blue">Blue</option>
              <option value="Green">Green</option>
              <option value="Gray">Gray</option>
            </select>
          </label>
          <label>
            Color 2
            <select id="manualGearColor2">
              <option value="">None</option>
              <option value="Neutral">Neutral</option>
              <option value="Red">Red</option>
              <option value="Blue">Blue</option>
              <option value="Green">Green</option>
              <option value="Gray">Gray</option>
            </select>
          </label>
          <label>
            Item Type
            <input id="manualGearItemType" type="text" placeholder="e.g. Laser Dagger" />
          </label>
          <label>
            Aesthetic
            <input id="manualGearAesthetic" type="text" placeholder="Optional aesthetic detail" />
          </label>
          <label>
            Essence Value
            <input id="manualGearEssence" type="number" min="0" value="0" />
          </label>
          <label>
            Credit Value
            <input id="manualGearCredit" type="number" min="0" value="0" />
          </label>
        </div>
        <div>
          <strong>Stat Modifiers</strong>
          <div id="manualGearStatsList" class="manual-gear-list"></div>
          <button id="addManualGearStat" type="button" aria-label="Add stat" title="Add stat"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M5 19h14"></path><path d="M7 16V9M12 16V6M17 16v-4"></path><path d="M4 5h4M6 3v4"></path></svg><span>Add Stat</span></button>
        </div>
        <div>
          <strong>Abilities</strong>
          <div id="manualGearAbilitiesList" class="manual-gear-list"></div>
          <button id="addManualGearAbility" type="button" aria-label="Add ability" title="Add ability"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 4l1.5 3.5L17 9l-3.5 1.5L12 14l-1.5-3.5L7 9l3.5-1.5z"></path><path d="M4 18h4M6 16v4"></path></svg><span>Add Ability</span></button>
        </div>
        <div class="manual-gear-actions">
          <button id="addManualGear" type="button" aria-label="Add manual gear" title="Add manual gear"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M14 6l4 4-8 8-4 1 1-4z"></path><path d="M4 6h4M6 4v4"></path></svg><span>Add Manual</span></button>
          <span id="manualGearStatus" class="mono muted"></span>
        </div>
      </details>
      <div class="paste-area" style="margin-top:1rem;">
        <strong>Paste Gear JSON</strong>
        <textarea id="gearPasteInput" placeholder="Paste gear JSON here"></textarea>
        <div class="gear-generator-actions">
          <button id="addPastedGear" type="button" aria-label="Add pasted gear" title="Add pasted gear"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><rect x="5" y="4" width="10" height="14" rx="2"></rect><path d="M9 4V2h4v2"></path><path d="M18 17h4M20 15v4"></path></svg><span>Add Pasted</span></button>
          <span id="pasteStatus" class="mono muted"></span>
        </div>
      </div>
    </div>
  </div>

  <div id="gearDetailModal" class="xr-modal hidden">
    <div class="xr-modal-backdrop"></div>
    <div class="xr-modal-card">
      <h2 id="gearDetailTitle">Gear Details</h2>
      <div class="modal-grid">
        <label>
          Gear Name
          <input id="gearNameInput" type="text" maxlength="60" />
        </label>
        <label>
          Notes
          <textarea id="gearNotesInput" rows="3" placeholder="Add optional notes about this gear..."></textarea>
        </label>
        <div id="gearDetailBody" class="gear-details-list"></div>
      </div>
      <div class="gear-modal-actions">
        <div class="right-actions">
          <button id="saveGearName" type="button" aria-label="Save details" title="Save details"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M5 4h12l2 2v14H5z"></path><path d="M8 4v6h8V4"></path><path d="M8 16h8"></path></svg></button>
          <button id="copyGearJson" type="button" aria-label="Copy JSON" title="Copy JSON"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><rect x="6" y="5" width="12" height="16" rx="2"></rect><path d="M9 5V3h6v2"></path><path d="M9 11h6M9 15h6"></path></svg><span>Copy JSON</span></button>
          <button id="dissolveGear" type="button" aria-label="Dissolve into essence" title="Dissolve into essence"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M10 3h4"></path><path d="M11 3v6l-5 8a3 3 0 0 0 2.6 4h6.8A3 3 0 0 0 18 17l-5-8V3"></path><path d="M8 14h8"></path></svg><span>Dissolve</span></button>
          <button id="deleteGear" type="button" aria-label="Delete gear" title="Delete gear"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 7h16"></path><path d="M9 7V4h6v3"></path><path d="M7 7l1 13h8l1-13"></path><path d="M10 11v6M14 11v6"></path></svg><span>Delete</span></button>
        </div>
        <button id="closeGearDetail" type="button" aria-label="Close" title="Close"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M6 6l12 12"></path><path d="M18 6L6 18"></path></svg><span>Close</span></button>
      </div>
      <div id="gearDetailStatus" class="mono muted"></div>
    </div>
  </div>


  <div id="respecModal" class="xr-modal hidden">
    <div class="xr-modal-backdrop"></div>
    <div class="xr-modal-card">
      <h2>Use Respec Consumable</h2>
      <p class="muted" id="respecModalHint"></p>
      <div class="stat-inputs">
        <label>Power
          <input id="respecPower" type="number" min="0" value="0" />
        </label>
        <label>Defense
          <input id="respecDefense" type="number" min="0" value="0" />
        </label>
        <label>Speed
          <input id="respecSpeed" type="number" min="0" value="0" />
        </label>
        <label>Intelligence
          <input id="respecIntelligence" type="number" min="0" value="0" />
        </label>
      </div>
      <p class="muted">Points remaining: <span id="respecPointsRemaining">0</span></p>
      <div class="xr-modal-actions">
        <button id="respecApplyBtn" type="button" aria-label="Apply respec" title="Apply respec"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><path d="M8 12l3 3 5-6"></path></svg></button>
        <button id="respecCancelBtn" type="button" aria-label="Cancel" title="Cancel"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M6 6l12 12"></path><path d="M18 6L6 18"></path></svg></button>
      </div>
      <div id="respecModalMsg" class="mono muted"></div>
    </div>
  </div>

  <div id="energyModal" class="xr-modal hidden">
    <div class="xr-modal-backdrop"></div>
    <div class="xr-modal-card">
      <h2>Use Energy Consumable</h2>
      <p class="muted">Choose which energy color to restore.</p>
      <label>
        Energy Color
        <select id="energyColorSelect">
          <option value="red">Red</option>
          <option value="blue">Blue</option>
          <option value="green">Green</option>
          <option value="gray">Gray</option>
        </select>
      </label>
      <div class="xr-modal-actions">
        <button id="energyApplyBtn" type="button" aria-label="Apply" title="Apply"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><path d="M8 12l3 3 5-6"></path></svg></button>
        <button id="energyCancelBtn" type="button" aria-label="Cancel" title="Cancel"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M6 6l12 12"></path><path d="M18 6L6 18"></path></svg></button>
      </div>
    </div>
  </div>

  <div id="statusPopup" class="status-popup" aria-live="polite"></div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="/shared/auth.js"></script>
  <script src="/shared/nav.js"></script>
  <script>
    const sb = window.supabaseClient;
    const levelTable = [
      { level: 1, xp: 0, baseHp: 5, statPoints: 3, energyCap: 5, kernelSlots: 1, inventorySlots: 10, baseLuck: 1 },
      { level: 2, xp: 10, baseHp: 10, statPoints: 0, energyCap: 5, kernelSlots: 1, inventorySlots: 12, baseLuck: 2 },
      { level: 3, xp: 20, baseHp: 15, statPoints: 1, energyCap: 6, kernelSlots: 2, inventorySlots: 14, baseLuck: 3 },
      { level: 4, xp: 35, baseHp: 20, statPoints: 0, energyCap: 6, kernelSlots: 2, inventorySlots: 16, baseLuck: 4 },
      { level: 5, xp: 55, baseHp: 25, statPoints: 1, energyCap: 7, kernelSlots: 3, inventorySlots: 18, baseLuck: 5 },
      { level: 6, xp: 80, baseHp: 30, statPoints: 0, energyCap: 7, kernelSlots: 3, inventorySlots: 20, baseLuck: 6 },
      { level: 7, xp: 110, baseHp: 35, statPoints: 1, energyCap: 8, kernelSlots: 4, inventorySlots: 22, baseLuck: 7 },
      { level: 8, xp: 150, baseHp: 40, statPoints: 0, energyCap: 8, kernelSlots: 4, inventorySlots: 24, baseLuck: 8 },
      { level: 9, xp: 200, baseHp: 45, statPoints: 1, energyCap: 9, kernelSlots: 5, inventorySlots: 26, baseLuck: 9 },
      { level: 10, xp: 260, baseHp: 50, statPoints: 0, energyCap: 10, kernelSlots: 5, inventorySlots: 30, baseLuck: 10 }
    ];

    const statLimitTable = {
      1: { hp: 20, defenseDc: 17, attackDamage: 20, comboDamage: 40, luck: 5 },
      2: { hp: 25, defenseDc: 18, attackDamage: 30, comboDamage: 60, luck: 7 },
      3: { hp: 30, defenseDc: 19, attackDamage: 40, comboDamage: 80, luck: 9 },
      4: { hp: 35, defenseDc: 20, attackDamage: 50, comboDamage: 100, luck: 11 },
      5: { hp: 40, defenseDc: 21, attackDamage: 60, comboDamage: 120, luck: 13 },
      6: { hp: 50, defenseDc: 23, attackDamage: 80, comboDamage: 160, luck: 15 },
      7: { hp: 60, defenseDc: 25, attackDamage: 100, comboDamage: 200, luck: 18 },
      8: { hp: 80, defenseDc: 28, attackDamage: 125, comboDamage: 250, luck: 21 },
      9: { hp: 100, defenseDc: 30, attackDamage: 150, comboDamage: 300, luck: 25 },
      10: { hp: null, defenseDc: null, attackDamage: null, comboDamage: null, luck: null }
    };

    const defaults = {
      level: 1,
      xp: 0,
      luck: 1,
      hp: 5,
      current_hp: 5,
      essence: 0,
      power: 0,
      defense: 0,
      speed: 0,
      intelligence: 0,
      inventory_slots: 10,
      kernel_slots: 1,
      energy_cap: 5,
      energy_red: 0,
      energy_blue: 0,
      energy_gray: 0,
      energy_green: 0,
      status_burn: 0,
      status_freeze: 0,
      status_poison: 0
    };

    const statusEffectDefaults = {
      burn: 0,
      freeze: 0,
      poison: 0
    };

    let currentUser = null;
    let activeCharacter = null;
    let isDirty = false;
    let isSaving = false;
    let autosaveTimer = null;
    let characterGear = [];
    let generatedGear = [];
    let activeGearRow = null;
    let pyodideClient = null;
    let pyodideReady = false;

    const elements = {
      nameInput: document.getElementById("characterName"),
      saveButton: document.getElementById("saveCharacter"),
      displayName: document.getElementById("displayName"),
      displayLevel: document.getElementById("displayLevel"),
      displayLuck: document.getElementById("displayLuck"),
      displayHp: document.getElementById("displayHp"),
      displayEnergyCap: document.getElementById("displayEnergyCap"),
      inputXp: document.getElementById("inputXp"),
      inputEssence: document.getElementById("inputEssence"),
      inputCurrentHp: document.getElementById("inputCurrentHp"),
      inputEnergyRed: document.getElementById("inputEnergyRed"),
      inputEnergyBlue: document.getElementById("inputEnergyBlue"),
      inputEnergyGray: document.getElementById("inputEnergyGray"),
      inputEnergyGreen: document.getElementById("inputEnergyGreen"),
      inputPower: document.getElementById("inputPower"),
      inputDefense: document.getElementById("inputDefense"),
      inputSpeed: document.getElementById("inputSpeed"),
      inputIntelligence: document.getElementById("inputIntelligence"),
      inputStatusBurn: document.getElementById("inputStatusBurn"),
      inputStatusFreeze: document.getElementById("inputStatusFreeze"),
      inputStatusPoison: document.getElementById("inputStatusPoison"),
      displayAttackPlus: document.getElementById("displayAttackPlus"),
      displayDamagePlus: document.getElementById("displayDamagePlus"),
      displayAttackDamageLimit: document.getElementById("displayAttackDamageLimit"),
      displayComboDamageLimit: document.getElementById("displayComboDamageLimit"),
      displayDefenseDc: document.getElementById("displayDefenseDc"),
      displayArmor: document.getElementById("displayArmor"),
      displayDamageTaken: document.getElementById("displayDamageTaken"),
      displayStatusDefenseDc: document.getElementById("displayStatusDefenseDc"),
      displayStatusArmor: document.getElementById("displayStatusArmor"),
      displayStatusAttackPlus: document.getElementById("displayStatusAttackPlus"),
      displayStatusDamagePlus: document.getElementById("displayStatusDamagePlus"),
      displayInitiative: document.getElementById("displayInitiative"),
      displayMovementSpeed: document.getElementById("displayMovementSpeed"),
      displayRange: document.getElementById("displayRange"),
      displayPerception: document.getElementById("displayPerception"),
      displayAoeRange: document.getElementById("displayAoeRange"),
      displayHacking: document.getElementById("displayHacking"),
      displayInventorySlots: document.getElementById("displayInventorySlots"),
      displayKernelSlots: document.getElementById("displayKernelSlots"),
      adventuringPlusesColumn: document.getElementById("adventuringPlusesColumn"),
      displayAdventuringPluses: document.getElementById("displayAdventuringPluses"),
      tempBuffSection: document.getElementById("tempBuffSection"),
      tempBuffSummary: document.getElementById("tempBuffSummary"),
      clearTempBuffs: document.getElementById("clearTempBuffs"),
      equippedSlots: document.getElementById("equippedSlots"),
      inventorySlots: document.getElementById("inventorySlots"),
      localNodeSlots: document.getElementById("localNodeSlots"),
      inventorySlotCount: document.getElementById("inventorySlotCount"),
      localNodeSlotCount: document.getElementById("localNodeSlotCount"),
      abilitiesList: document.getElementById("abilitiesList"),
      openGearGenerator: document.getElementById("openGearGenerator"),
      gearGeneratorStatus: document.getElementById("gearGeneratorStatus"),
      statusPopup: document.getElementById("statusPopup"),
      deletedGearHistory: document.getElementById("deletedGearHistory"),
      notesInput: document.getElementById("characterNotes")
    };

    const modal = document.getElementById("levelupModal");
    const modalBackdrop = modal.querySelector(".xr-modal-backdrop");
    const targetLevelSelect = document.getElementById("targetLevel");
    const levelPreview = document.getElementById("levelPreview");
    const levelPower = document.getElementById("levelPower");
    const levelDefense = document.getElementById("levelDefense");
    const levelSpeed = document.getElementById("levelSpeed");
    const levelIntelligence = document.getElementById("levelIntelligence");
    const pointsRemaining = document.getElementById("pointsRemaining");
    const levelError = document.getElementById("levelError");

    const gearGeneratorModal = document.getElementById("gearGeneratorModal");
    const gearGeneratorBackdrop = gearGeneratorModal.querySelector(".xr-modal-backdrop");
    const gearBonusLuck = document.getElementById("gearBonusLuck");
    const gearAmount = document.getElementById("gearAmount");
    const gearTypeNumber = document.getElementById("gearTypeNumber");
    const gearRarity = document.getElementById("gearRarity");
    const gearColor = document.getElementById("gearColor");
    const gearColor2 = document.getElementById("gearColor2");
    const gearTotalLuck = document.getElementById("gearTotalLuck");
    const generateGearButton = document.getElementById("generateGear");
    const addAllGeneratedGearButton = document.getElementById("addAllGeneratedGear");
    const closeGearGenerator = document.getElementById("closeGearGenerator");
    const generatedGearList = document.getElementById("generatedGearList");
    const gearPasteInput = document.getElementById("gearPasteInput");
    const addPastedGear = document.getElementById("addPastedGear");
    const pasteStatus = document.getElementById("pasteStatus");
    const manualGearName = document.getElementById("manualGearName");
    const manualGearType = document.getElementById("manualGearType");
    const manualGearRarity = document.getElementById("manualGearRarity");
    const manualGearColor = document.getElementById("manualGearColor");
    const manualGearColor2 = document.getElementById("manualGearColor2");
    const manualGearItemType = document.getElementById("manualGearItemType");
    const manualGearAesthetic = document.getElementById("manualGearAesthetic");
    const manualGearEssence = document.getElementById("manualGearEssence");
    const manualGearCredit = document.getElementById("manualGearCredit");
    const manualGearStatsList = document.getElementById("manualGearStatsList");
    const addManualGearStat = document.getElementById("addManualGearStat");
    const manualGearAbilitiesList = document.getElementById("manualGearAbilitiesList");
    const addManualGearAbility = document.getElementById("addManualGearAbility");
    const addManualGearButton = document.getElementById("addManualGear");
    const manualGearStatus = document.getElementById("manualGearStatus");
    const gearSortField = document.getElementById("gearSortField");
    const gearSortDirection = document.getElementById("gearSortDirection");
    const gearFilterRarity = document.getElementById("gearFilterRarity");
    const gearFilterType = document.getElementById("gearFilterType");
    const gearFilterColor = document.getElementById("gearFilterColor");
    const gearFilterStat = document.getElementById("gearFilterStat");
    const gearFilterFreeSlot = document.getElementById("gearFilterFreeSlot");
    const localGearFilterRarity = document.getElementById("localGearFilterRarity");
    const localGearFilterType = document.getElementById("localGearFilterType");
    const localGearFilterColor = document.getElementById("localGearFilterColor");
    const localGearFilterStat = document.getElementById("localGearFilterStat");
    const localGearFilterFreeSlot = document.getElementById("localGearFilterFreeSlot");

    const gearDetailModal = document.getElementById("gearDetailModal");
    const gearDetailBackdrop = gearDetailModal.querySelector(".xr-modal-backdrop");
    const gearDetailTitle = document.getElementById("gearDetailTitle");
    const gearNameInput = document.getElementById("gearNameInput");
    const gearNotesInput = document.getElementById("gearNotesInput");
    const gearDetailBody = document.getElementById("gearDetailBody");
    const closeGearDetail = document.getElementById("closeGearDetail");
    const copyGearJson = document.getElementById("copyGearJson");
    const saveGearName = document.getElementById("saveGearName");
    const deleteGearButton = document.getElementById("deleteGear");
    const dissolveGearButton = document.getElementById("dissolveGear");
    const gearDetailStatus = document.getElementById("gearDetailStatus");

    const respecModal = document.getElementById("respecModal");
    const respecModalBackdrop = respecModal?.querySelector(".xr-modal-backdrop");
    const respecModalHint = document.getElementById("respecModalHint");
    const respecPower = document.getElementById("respecPower");
    const respecDefense = document.getElementById("respecDefense");
    const respecSpeed = document.getElementById("respecSpeed");
    const respecIntelligence = document.getElementById("respecIntelligence");
    const respecPointsRemaining = document.getElementById("respecPointsRemaining");
    const respecApplyBtn = document.getElementById("respecApplyBtn");
    const respecCancelBtn = document.getElementById("respecCancelBtn");
    const respecModalMsg = document.getElementById("respecModalMsg");

    const energyModal = document.getElementById("energyModal");
    const energyModalBackdrop = energyModal?.querySelector(".xr-modal-backdrop");
    const energyColorSelect = document.getElementById("energyColorSelect");
    const energyApplyBtn = document.getElementById("energyApplyBtn");
    const energyCancelBtn = document.getElementById("energyCancelBtn");

    const deletedGearHistory = [];
    let tempConsumableBonus = createEmptyBonus();
    let tempConsumableSummary = [];

    const gearSlotLabels = {
      weapon_1: "Weapon 1",
      weapon_2: "Weapon 2",
      head: "Head",
      torso: "Torso",
      hands: "Hands",
      legs: "Legs",
      feet: "Feet",
      ring_1: "Ring 1",
      ring_2: "Ring 2",
      neck: "Neck",
      kernel_1: "Kernel 1",
      kernel_2: "Kernel 2",
      kernel_3: "Kernel 3",
      kernel_4: "Kernel 4",
      kernel_5: "Kernel 5"
    };

    const gearTypeToSlots = {
      "One-Handed Weapon": ["weapon_1", "weapon_2"],
      "Two-Handed Weapon": ["weapon_1", "weapon_2"],
      "Head": ["head"],
      "Torso": ["torso"],
      "Hands": ["hands"],
      "Legs": ["legs"],
      "Feet": ["feet"],
      "Ring": ["ring_1", "ring_2"],
      "Neck": ["neck"],
      "Kernel": ["kernel_1", "kernel_2", "kernel_3", "kernel_4", "kernel_5"]
    };

    const statKeyMap = {
      Luck: "luck",
      "Inventory Slots": "inventory_slots",
      "Energy Cap": "energy_cap",
      "Kernel Slots": "kernel_slots",
      HP: "hp",
      Power: "power",
      Defense: "defense",
      Speed: "speed",
      Intelligence: "intelligence",
      "Attack Plus": "attackPlus",
      "Damage Plus": "damagePlus",
      "Defense DC": "defenseDc",
      Armor: "armor",
      Initiative: "initiative",
      "Movement Speed": "movementSpeed",
      Range: "range",
      Perception: "perception",
      "AOE Range": "aoeRange",
      Hacking: "hacking",
      "Group XP Gain": "group_xp_gain",
      "HP Regen": "hp_regen",
      "Energy Conversion": "energy_conversion",
      "Energy Generation": "energy_generation",
      "Resell Value": "resell_value"
    };

    const statOptions = [
      "Power",
      "Defense",
      "Speed",
      "Intelligence",
      "Luck",
      "HP",
      "Attack Plus",
      "Damage Plus",
      "Defense DC",
      "Armor",
      "Initiative",
      "Movement Speed",
      "Range",
      "Perception",
      "AOE Range",
      "Hacking",
      "Inventory Slots",
      "Kernel Slots",
      "Energy Cap",
      "Energy Conversion",
      "Energy Generation",
      "Group XP Gain",
      "HP Regen",
      "Resell Value"
    ];

    const baubleFormulaOptions = [
      "G÷4",
      "G÷3",
      "G÷2",
      "G",
      "Gx1.25",
      "Gx1.5",
      "Gx1.75",
      "Gx2.5",
      "+1",
      "+2",
      "+3",
      "+4",
      "+5"
    ];

    const gearTypeSortOrder = [
      "One-Handed Weapon",
      "Two-Handed Weapon",
      "Head",
      "Torso",
      "Hands",
      "Legs",
      "Feet",
      "Ring",
      "Neck",
      "Kernel",
      "Bauble",
      "Consumable"
    ];

    const raritySortOrder = ["Basic", "Common", "Uncommon", "Rare", "Epic", "Legendary"];
    const colorSortOrder = ["Neutral", "Red", "Blue", "Green", "Gray"];

    let availableAbilities = [];
    let abilityDetailMap = new Map();

    function deriveSecondaryStats(stats) {
      const power = stats.power || 0;
      const defense = stats.defense || 0;
      const speed = stats.speed || 0;
      const intelligence = stats.intelligence || 0;
      const perception = intelligence * 2;

      return {
        attackPlus: power,
        damagePlus: power,
        defenseDc: 10 + defense,
        armor: defense,
        initiative: speed,
        movementSpeed: (speed * 2) + 10,
        range: speed + 5,
        perception,
        aoeRange: perception,
        hacking: intelligence
      };
    }

    function normalizeStats(stats) {
      const normalized = {
        ...defaults,
        ...stats
      };
      if (normalized.current_hp == null) {
        normalized.current_hp = normalized.hp;
      }
      return normalized;
    }

    function currentStats() {
      if (!activeCharacter) {
        return normalizeStats({});
      }
      return normalizeStats(activeCharacter.base_stats || {});
    }

    function getStatusStacks(stats) {
      return {
        burn: Math.max(0, Number(stats.status_burn) || 0),
        freeze: Math.max(0, Number(stats.status_freeze) || 0),
        poison: Math.max(0, Number(stats.status_poison) || 0)
      };
    }

    function getStatusEffectsPayload(stats) {
      const stacks = getStatusStacks(stats);
      return {
        burn: stacks.burn,
        freeze: stacks.freeze,
        poison: stacks.poison
      };
    }

    function mergeStatusEffectsIntoStats(baseStats = {}, statusEffects) {
      if (!statusEffects) return baseStats;
      const merged = { ...baseStats };
      merged.status_burn = Number(statusEffects.burn) || 0;
      merged.status_freeze = Number(statusEffects.freeze) || 0;
      merged.status_poison = Number(statusEffects.poison) || 0;
      return merged;
    }

    function normalizeStatusEffects(statusEffects) {
      const normalized = { ...statusEffectDefaults };
      if (!statusEffects) return normalized;
      return {
        burn: Math.max(0, Number(statusEffects.burn) || 0),
        freeze: Math.max(0, Number(statusEffects.freeze) || 0),
        poison: Math.max(0, Number(statusEffects.poison) || 0)
      };
    }

    function pushStatus(message, { tone = "info", actionLabel, onAction, duration = 4500 } = {}) {
      if (!elements.statusPopup) return;
      const toast = document.createElement("div");
      toast.className = `status-toast ${tone}`;
      const messageSpan = document.createElement("span");
      messageSpan.className = "status-message";
      messageSpan.textContent = message;
      toast.appendChild(messageSpan);
      if (actionLabel && typeof onAction === "function") {
        const actionButton = document.createElement("button");
        actionButton.type = "button";
        actionButton.textContent = actionLabel;
        actionButton.addEventListener("click", () => {
          onAction();
          toast.remove();
        });
        toast.appendChild(actionButton);
      }
      elements.statusPopup.appendChild(toast);
      toast.addEventListener("click", () => {
        toast.remove();
      });
      if (duration !== null) {
        setTimeout(() => {
          toast.remove();
        }, duration);
      }
    }

    function calculateFormulaValue(formula, luck, statName, context = {}) {
      if (formula == null) return 0;
      if (typeof formula === "number") return formula;
      const trimmed = String(formula).trim();
      if (!trimmed) return 0;
      if (trimmed.startsWith("x")) {
        return 0;
      }
      if (trimmed === "D") {
        return String(luck).length;
      }
      if (trimmed === "D+1") {
        return String(luck).length + 1;
      }
      const normalized = trimmed.replace(/^\+/, "");
      if (/^\d+(\.\d+)?$/.test(normalized)) {
        return Number(normalized);
      }
      const match = normalized.match(/^([LG])([x÷])([\d.]+)$/);
      if (!match) return 0;
      const [, symbol, op, raw] = match;
      const value = Number(raw);
      const gValue = Number(context.g) || 0;
      const baseValue = symbol === "G" ? gValue : luck;
      let result = 0;
      if (op === "x") {
        result = Math.floor(baseValue * value);
      } else {
        result = Math.floor(baseValue / value);
      }
      if (statName === "Kernel Slots") {
        return Math.min(3, Math.max(1, result));
      }
      return Math.max(1, result);
    }

    function resolveAbilityDetails(ability) {
      if (!ability || typeof ability !== "string") return ability;
      return abilityDetailMap.get(ability) || ability;
    }

    function parseAbilityLines(ability) {
      const resolved = resolveAbilityDetails(ability);
      if (!resolved) return [];
      if (typeof resolved === "string") return [resolved];
      const details = resolved.tierDetails;
      if (!details) return [];
      if (typeof details === "string") {
        return details.split("\n");
      }
      return Object.values(details).flatMap(detail => String(detail || "").split("\n"));
    }

    function parseAbilityStatLine(line) {
      const cleaned = String(line || "").trim().replace(/^[-•]\s*/, "");
      if (!cleaned.includes(":")) return null;
      const [rawStat, ...rest] = cleaned.split(":");
      const statName = rawStat.trim();
      if (!statName || statName.toLowerCase().includes("basic stat of your choice")) return null;
      const rawValue = rest.join(":").trim();
      if (!rawValue) return null;
      if (/^[+-]?\d+(\.\d+)?$/.test(rawValue.replace(/^\+/, ""))) {
        return { statName, value: Number(rawValue.replace(/^\+/, "")) };
      }
      return { statName, formula: rawValue.replace(/^\+/, "") };
    }

    function parseStatusAbilityLine(line, statusStacks) {
      const cleaned = String(line || "").trim().replace(/^[-•]\s*/, "");
      if (!cleaned) return [];
      const results = [];
      const freezeDefenseMatch = cleaned.match(/freezing.*\+([\d.]+)\s+defense dc and armor/i);
      if (freezeDefenseMatch && statusStacks.freeze > 0) {
        const value = Number(freezeDefenseMatch[1]);
        if (!Number.isNaN(value)) {
          results.push({ statName: "Defense DC", value });
          results.push({ statName: "Armor", value });
        }
      }
      const freezeDamageMatch = cleaned.match(/deal\s*\+?([\d.]+)\s*points?\s*of damage for each stack of freeze/i);
      if (freezeDamageMatch && statusStacks.freeze > 0) {
        const perStack = Number(freezeDamageMatch[1]);
        if (!Number.isNaN(perStack)) {
          results.push({ statName: "Damage Plus", value: perStack * statusStacks.freeze });
        }
      }
      return results;
    }

    function getAoeBuffMultiplier() {
      let multiplier = 1;
      characterGear.forEach(entry => {
        if (!entry.equipped || !entry.gear) return;
        const gearType = entry.gear.gear_type || entry.gear.gearType;
        if (gearType !== "Kernel") return;
        (entry.gear.abilities || []).forEach(ability => {
          if (!ability || ability.name !== "AOE Buff") return;
          parseAbilityLines(ability).forEach(line => {
            const match = String(line).match(/AOE Radius now = Perception x([\d.]+)/i);
            if (match) {
              const value = Number(match[1]);
              if (!Number.isNaN(value)) {
                multiplier = Math.max(multiplier, value);
              }
            }
          });
        });
      });
      return multiplier;
    }

    function mergeBonuses(target, source) {
      ["base", "derived", "misc"].forEach(section => {
        Object.keys(source[section]).forEach(key => {
          target[section][key] += source[section][key] || 0;
        });
      });
      return target;
    }

    function getEquippedColorCounts() {
      const counts = {};
      characterGear.forEach(entry => {
        if (!entry.equipped || !entry.gear) return;
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        if (gearType === "Bauble") return;
        [gear.color, gear.color2].filter(Boolean).forEach(color => {
          counts[color] = (counts[color] || 0) + 1;
        });
      });
      return counts;
    }

    function hasAllCoreColorsEquipped() {
      const counts = getEquippedColorCounts();
      return ["Red", "Blue", "Green", "Gray"].every(color => (counts[color] || 0) > 0);
    }

    function createEmptyBonus() {
      return {
        base: {
          luck: 0,
          inventory_slots: 0,
          energy_cap: 0,
          kernel_slots: 0,
          hp: 0,
          power: 0,
          defense: 0,
          speed: 0,
          intelligence: 0
        },
        derived: {
          attackPlus: 0,
          damagePlus: 0,
          defenseDc: 0,
          armor: 0,
          initiative: 0,
          movementSpeed: 0,
          range: 0,
          perception: 0,
          aoeRange: 0,
          hacking: 0
        },
        misc: {
          group_xp_gain: 0,
          hp_regen: 0,
          energy_conversion: 0,
          energy_generation: 0,
          resell_value: 0
        }
      };
    }

    function createEmptyBonusSources() {
      return {
        base: {
          luck: [],
          inventory_slots: [],
          energy_cap: [],
          kernel_slots: [],
          hp: [],
          power: [],
          defense: [],
          speed: [],
          intelligence: []
        },
        derived: {
          attackPlus: [],
          damagePlus: [],
          defenseDc: [],
          armor: [],
          initiative: [],
          movementSpeed: [],
          range: [],
          perception: [],
          aoeRange: [],
          hacking: []
        },
        misc: {
          group_xp_gain: [],
          hp_regen: [],
          energy_conversion: [],
          energy_generation: [],
          resell_value: []
        }
      };
    }

    function applyStatBonus(target, statName, value, sourceLabel, sources) {
      const key = statKeyMap[statName];
      if (!key || !value) return;
      if (Object.prototype.hasOwnProperty.call(target.derived, key)) {
        target.derived[key] += value;
        if (sources && sourceLabel) {
          sources.derived[key].push({ value, label: sourceLabel });
        }
      } else if (Object.prototype.hasOwnProperty.call(target.misc, key)) {
        target.misc[key] += value;
        if (sources && sourceLabel) {
          sources.misc[key].push({ value, label: sourceLabel });
        }
      } else if (Object.prototype.hasOwnProperty.call(target.base, key)) {
        target.base[key] += value;
        if (sources && sourceLabel) {
          sources.base[key].push({ value, label: sourceLabel });
        }
      }
    }

    function calculateGearBonuses(baseStats) {
      const equippedColorCounts = getEquippedColorCounts();
      const baseLuck = baseStats.luck || 0;
      const statusStacks = getStatusStacks(baseStats);
      const nonBaubleBonus = createEmptyBonus();
      const abilityBonus = createEmptyBonus();
      const baubleBonus = createEmptyBonus();
      const sources = createEmptyBonusSources();
      const adventuringPluses = [];

      characterGear.forEach(entry => {
        if (!entry.gear) return;
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        const isBauble = gearType === "Bauble";
        const isEquipped = entry.equipped;
        const isInventory = entry.gear_slot === "inventory";

        if (!isBauble && isEquipped) {
          (gear.stats || []).forEach(stat => {
            const statName = stat.name || stat.stat || stat.label;
            if (!statName) return;
            const value = stat.value ?? stat.calc ?? calculateFormulaValue(stat.formula, baseLuck, statName);
            if (typeof value !== "number") return;
            applyStatBonus(nonBaubleBonus, statName, value, gearType, sources);
          });
        }
      });

      const interimLuck = applyGearBonuses(baseStats, nonBaubleBonus).luck || baseLuck;

      characterGear.forEach(entry => {
        if (!entry.gear) return;
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        if (gearType !== "Kernel" || !entry.equipped) return;
        (gear.abilities || []).forEach(ability => {
          const lines = parseAbilityLines(ability);
          const hasColorSpread = lines.some(line => line.toLowerCase().includes("each color equipped"));
          if (hasColorSpread && !hasAllCoreColorsEquipped()) return;
          const abilityLabel = typeof ability === "string" ? "Kernel Ability" : ability.name || "Kernel Ability";
          const gLine = lines.find(line => line.includes("G ="));
          let gValue = 0;
          if (gLine) {
            const match = gLine.match(/G = The amount of (\w+)/i);
            if (match) {
              const color = match[1];
              gValue = equippedColorCounts[color] || 0;
            }
          }
          lines.forEach(line => {
            if (line.includes("G =")) return;
            const parsed = parseAbilityStatLine(line);
            if (parsed) {
              const value = parsed.value ?? calculateFormulaValue(parsed.formula, interimLuck, parsed.statName, { g: gValue });
              if (typeof value === "number") {
                applyStatBonus(abilityBonus, parsed.statName, value, abilityLabel, sources);
              }
            }
            const statusBonuses = parseStatusAbilityLine(line, statusStacks);
            statusBonuses.forEach(statusBonus => {
              applyStatBonus(abilityBonus, statusBonus.statName, statusBonus.value, abilityLabel, sources);
            });
          });
        });
      });

      const combinedBeforeBauble = mergeBonuses(mergeBonuses(createEmptyBonus(), nonBaubleBonus), abilityBonus);
      const interimStats = applyGearBonuses(baseStats, combinedBeforeBauble);
      const updatedLuck = interimStats.luck || baseLuck;

      characterGear.forEach(entry => {
        if (!entry.gear) return;
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        const isBauble = gearType === "Bauble";
        const isInventory = entry.gear_slot === "inventory";
        if (!isBauble || !isInventory) return;
        const gValue = gear.color ? (equippedColorCounts[gear.color] || 0) : 0;
        (gear.stat_modifiers || []).forEach(stat => {
          const statName = stat.name || stat.stat || stat.label;
          if (!statName) return;
          const value = calculateFormulaValue(stat.formula, updatedLuck, statName, { g: gValue });
          if (typeof value !== "number") return;
          if (statKeyMap[statName]) {
            applyStatBonus(baubleBonus, statName, value, "Bauble", sources);
          } else {
            adventuringPluses.push({ name: statName, value });
          }
        });
      });

      const combined = mergeBonuses(mergeBonuses(nonBaubleBonus, abilityBonus), baubleBonus);
      mergeBonuses(combined, tempConsumableBonus);
      Object.keys(tempConsumableBonus.base).forEach(key => {
        const value = tempConsumableBonus.base[key] || 0;
        if (value) {
          sources.base[key].push({ value, label: "Temp Buff" });
        }
      });
      Object.keys(tempConsumableBonus.derived).forEach(key => {
        const value = tempConsumableBonus.derived[key] || 0;
        if (value) {
          sources.derived[key].push({ value, label: "Temp Buff" });
        }
      });
      Object.keys(tempConsumableBonus.misc).forEach(key => {
        const value = tempConsumableBonus.misc[key] || 0;
        if (value) {
          sources.misc[key].push({ value, label: "Temp Buff" });
        }
      });
      combined.sources = sources;
      combined.adventuringPluses = adventuringPluses;
      return combined;
    }

    function applyGearBonuses(baseStats, gearBonus) {
      const combined = { ...baseStats };
      Object.keys(gearBonus.base).forEach(key => {
        combined[key] = (combined[key] || 0) + (gearBonus.base[key] || 0);
      });
      combined.current_hp = Math.min(combined.current_hp ?? combined.hp, combined.hp);
      return combined;
    }

    function getGearGeneratorLuck(stats) {
      const baseLuck = stats.luck || 0;
      const bonus = Number(gearBonusLuck.value) || 0;
      return baseLuck + bonus;
    }

    function updateGearGeneratorLuck(stats) {
      gearTotalLuck.textContent = getGearGeneratorLuck(stats);
    }

    function getKernelSlots(stats) {
      const count = Math.max(Number(stats.kernel_slots) || 0, 0);
      return Array.from({ length: Math.min(count, 5) }, (_, i) => `kernel_${i + 1}`);
    }

    function getEquippedSlotList(stats) {
      return [
        "weapon_1",
        "weapon_2",
        "head",
        "torso",
        "hands",
        "legs",
        "feet",
        "ring_1",
        "ring_2",
        "neck",
        ...getKernelSlots(stats)
      ];
    }

    function formatSlotLabel(slot) {
      return gearSlotLabels[slot] || slot;
    }

    function formatSignedValue(value) {
      const rounded = Number.isFinite(value) ? value : 0;
      return `${rounded >= 0 ? "+" : ""}${rounded}`;
    }

    function summarizeSources(sourceList = []) {
      if (!sourceList.length) return "";
      const totals = sourceList.reduce((acc, item) => {
        if (!item || !item.label || !item.value) return acc;
        acc[item.label] = (acc[item.label] || 0) + item.value;
        return acc;
      }, {});
      const parts = Object.entries(totals)
        .filter(([, value]) => value)
        .map(([label, value]) => `${formatSignedValue(value)} ${label}`);
      return parts.length ? parts.join(", ") : "";
    }

    function summarizeAdventuringPluses(list = []) {
      if (!list.length) return [];
      const totals = list.reduce((acc, item) => {
        if (!item || !item.name || !item.value) return acc;
        acc[item.name] = (acc[item.name] || 0) + item.value;
        return acc;
      }, {});
      return Object.entries(totals)
        .filter(([, value]) => value)
        .map(([name, value]) => ({ name, value }));
    }

    function scaleSourceList(list = [], factor = 1) {
      return list.map(item => ({
        label: item.label,
        value: item.value * factor
      }));
    }

    function combineSourceLists(...lists) {
      return lists.flat().filter(Boolean);
    }

    function getLevelLimits(level) {
      return statLimitTable[level] || statLimitTable[10];
    }

    function applyDisplayLimit(value, limit) {
      if (!Number.isFinite(limit)) {
        return { displayValue: value, limit: null };
      }
      return { displayValue: Math.min(value, limit), limit };
    }

    function sumSourceValues(sourceList = []) {
      return sourceList.reduce((total, item) => {
        if (!item || !Number.isFinite(item.value)) return total;
        return total + item.value;
      }, 0);
    }

    function setStatDisplay(element, value, summary, options = {}) {
      if (!element) return;
      const displayValue = options.displayValue ?? value;
      const limit = Number.isFinite(options.limit) ? options.limit : null;
      const limitLabel = options.limitLabel || "Limit";
      const rawValue = options.rawValue;
      const showRawValue = options.showRawValue && Number.isFinite(rawValue);


      element.textContent = "";
      const valueRow = document.createElement("span");
      valueRow.className = "stat-value-row";

      const valueGroup = document.createElement("span");
      valueGroup.className = "stat-main-group";

      const valueSpan = document.createElement("span");
      valueSpan.className = "stat-main-value";
      valueSpan.textContent = String(displayValue);
      valueGroup.appendChild(valueSpan);

      if (summary) {
        const summarySpan = document.createElement("span");
        summarySpan.className = "muted stat-summary";
        summarySpan.textContent = `(${summary})`;
        valueGroup.appendChild(summarySpan);
      }

      valueRow.appendChild(valueGroup);

      if (limit !== null) {
        const limitSpan = document.createElement("span");
        limitSpan.className = "stat-limit-value muted";
        const limitDetails = [`${limitLabel} ${limit}`];
        if (showRawValue) {
          limitDetails.push(`(${rawValue})`);
        }
        limitSpan.textContent = limitDetails.join(" • ");
        if (displayValue !== value) {
          limitSpan.title = `Limited from ${value}`;
        }
        valueRow.appendChild(limitSpan);
      }

      element.appendChild(valueRow);

      const details = [];
      if (details.length) {
        const detailsSpan = document.createElement("span");
        detailsSpan.className = "muted stat-summary";
        detailsSpan.textContent = `(${details.join(" • ")})`;
        element.appendChild(detailsSpan);
      }
    }

    function formatGearName(gear) {
      if (!gear) return "Unknown Gear";
      if (gear.name && gear.name.trim()) return gear.name.trim();
      const colors = [gear.color, gear.color2].filter(Boolean).join("/");
      const colorLabel = colors ? `${colors} ` : "";
      return `${gear.rarity || ""} ${colorLabel}${gear.item_type || gear.itemType || gear.gear_type || gear.gearType || "Gear"}`.trim();
    }

    const gearTagPalette = {
      type: {
        "One-Handed Weapon": "#94a3b8",
        "Two-Handed Weapon": "#94a3b8",
        "Head": "#94a3b8",
        "Torso": "#94a3b8",
        "Hands": "#94a3b8",
        "Legs": "#94a3b8",
        "Feet": "#94a3b8",
        "Ring": "#94a3b8",
        "Neck": "#94a3b8",
        "Kernel": "#94a3b8",
        "Consumable": "#94a3b8",
        "Bauble": "#94a3b8"
      },
      rarity: {
        "Basic": "#cbd5f5",
        "Common": "#94a3b8",
        "Uncommon": "#22c55e",
        "Rare": "#38bdf8",
        "Epic": "#a855f7",
        "Legendary": "#f59e0b"
      },
      color: {
        "Neutral": "#cbd5f5",
        "Red": "#f87171",
        "Blue": "#60a5fa",
        "Green": "#4ade80",
        "Gray": "#9aa3b2"
      }
    };

    function hexToRgba(hex, alpha) {
      const normalized = hex.replace("#", "");
      const bigint = parseInt(normalized, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function renderGearTag(label, group, options = {}) {
      const palette = gearTagPalette[group] || {};
      const primaryKey = options.primary || label;
      const primary = palette[primaryKey] || "#94a3b8";
      const secondaryKey = options.secondary;
      const secondary = secondaryKey ? (palette[secondaryKey] || primary) : null;
      const bg = hexToRgba(primary, 0.22);
      const style = [
        `--tag-color: ${primary}`,
        `--tag-bg: ${bg}`,
        secondary ? `--tag-color-secondary: ${secondary}` : ""
      ]
        .filter(Boolean)
        .join("; ");
      const className = `gear-tag gear-tag--${group}${secondary ? " dual" : ""}`;
      return `<span class="${className}" style="${style}">${label}</span>`;
    }

    function normalizeLabel(value) {
      return String(value || "").trim().toLowerCase();
    }

    function getGearTypeLabel(gear) {
      return gear?.gear_type || gear?.gearType || "";
    }

    function gearHasStat(gear, targetStat) {
      if (!targetStat) return true;
      const target = normalizeLabel(targetStat);
      const allStats = [...(gear.stats || []), ...(gear.stat_modifiers || [])];
      return allStats.some(stat => normalizeLabel(stat.label || stat.name) === target);
    }

    function matchesGearFilters(gear, stats, filters = {}) {
      if (!gear) return false;
      const filterRarity = filters.rarity || "";
      const filterType = filters.type || "";
      const filterColor = filters.color || "";
      const filterStat = filters.stat || "";
      const filterFreeSlot = filters.freeSlot || "";
      const gearType = getGearTypeLabel(gear);
      const gearColor = gear.color || "Neutral";
      if (filterRarity && gear.rarity !== filterRarity) return false;
      if (filterType && gearType !== filterType) return false;
      if (filterColor && gearColor !== filterColor) return false;
      if (filterStat && !gearHasStat(gear, filterStat)) return false;
      if (filterFreeSlot) {
        const resolvedStats = stats || applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
        const hasFreeSlot = availableSlotsForGear(gear, resolvedStats).length > 0;
        if (filterFreeSlot === "has" && !hasFreeSlot) return false;
        if (filterFreeSlot === "none" && hasFreeSlot) return false;
      }
      return true;
    }

    function getInventoryFilterState() {
      return {
        rarity: gearFilterRarity?.value || "",
        type: gearFilterType?.value || "",
        color: gearFilterColor?.value || "",
        stat: gearFilterStat?.value || "",
        freeSlot: gearFilterFreeSlot?.value || ""
      };
    }

    function getLocalNodeFilterState() {
      return {
        rarity: localGearFilterRarity?.value || "",
        type: localGearFilterType?.value || "",
        color: localGearFilterColor?.value || "",
        stat: localGearFilterStat?.value || "",
        freeSlot: localGearFilterFreeSlot?.value || ""
      };
    }

    function sortGearEntries(entries) {
      const sortField = gearSortField?.value || "rarity";
      const direction = gearSortDirection?.value === "desc" ? -1 : 1;
      const rarityIndex = entry => raritySortOrder.indexOf(entry.gear.rarity);
      const typeIndex = entry => gearTypeSortOrder.indexOf(getGearTypeLabel(entry.gear));
      const colorIndex = entry => colorSortOrder.indexOf(entry.gear.color || "Neutral");

      return [...entries].sort((a, b) => {
        let aKey = "";
        let bKey = "";
        if (sortField === "rarity") {
          aKey = rarityIndex(a);
          bKey = rarityIndex(b);
        } else if (sortField === "type") {
          aKey = typeIndex(a);
          bKey = typeIndex(b);
        } else if (sortField === "color") {
          aKey = colorIndex(a);
          bKey = colorIndex(b);
        } else {
          aKey = formatGearName(a.gear);
          bKey = formatGearName(b.gear);
        }

        if (aKey === bKey) {
          return formatGearName(a.gear).localeCompare(formatGearName(b.gear)) * direction;
        }
        if (typeof aKey === "number" && typeof bKey === "number") {
          const normalizedA = aKey === -1 ? Number.MAX_SAFE_INTEGER : aKey;
          const normalizedB = bKey === -1 ? Number.MAX_SAFE_INTEGER : bKey;
          return normalizedA > normalizedB ? direction : -direction;
        }
        return String(aKey).localeCompare(String(bKey)) * direction;
      });
    }

    function availableSlotsForGear(gear, stats) {
      const gearType = gear?.gear_type || gear?.gearType;
      if (!gear || gearType === "Bauble") return [];
      const slots = gearTypeToSlots[gearType] || [];
      const kernelSlots = getKernelSlots(stats);
      const filteredSlots = slots.filter(slot => slot.startsWith("kernel_") ? kernelSlots.includes(slot) : true);
      return filteredSlots.filter(slot => !characterGear.some(entry => entry.equipped && entry.gear_slot === slot));
    }

    function getSwapOptionsForGear(gear, stats) {
      const gearType = gear?.gear_type || gear?.gearType;
      if (!gear || gearType === "Bauble") return [];
      const slots = gearTypeToSlots[gearType] || [];
      const kernelSlots = getKernelSlots(stats);
      const filteredSlots = slots.filter(slot => slot.startsWith("kernel_") ? kernelSlots.includes(slot) : true);
      return filteredSlots
        .map(slot => {
          const entry = characterGear.find(item => item.equipped && item.gear_slot === slot);
          return entry ? { slot, entry } : null;
        })
        .filter(Boolean);
    }

    function selectSwapSlot(options) {
      return options.length ? options[0] : null;
    }

    function renderGearStatsList(stats, statModifiers, luck, context = {}) {
      const rows = [];
      (stats || []).forEach(stat => {
        const statName = stat.label || stat.name;
        if (!statName) return;
        rows.push(`<li class="gear-stat gear-stat--base">${statName}: ${stat.value ?? "?"} <span class="muted">(${stat.formula || "?"})</span></li>`);
      });
      (statModifiers || []).forEach(stat => {
        const statName = stat.label || stat.name;
        if (!statName) return;
        const value = calculateFormulaValue(stat.formula, luck, stat.name || statName, context);
        rows.push(`<li class="gear-stat gear-stat--bonus">${statName}: ${value} <span class="muted">(${stat.formula || "?"})</span></li>`);
      });
      return rows.length ? `<ul>${rows.join("")}</ul>` : `<p class="muted">No stat changes.</p>`;
    }

    function buildGearStatSummary(gear, luck, context = {}) {
      const parts = [];
      (gear.stats || []).forEach(stat => {
        const statName = stat.label || stat.name;
        if (!statName) return;
        const value = stat.value ?? stat.calc;
        if (typeof value !== "number" || value === 0) return;
        parts.push(`${formatSignedValue(value)} ${statName}`);
      });
      (gear.stat_modifiers || []).forEach(stat => {
        const statName = stat.label || stat.name;
        if (!statName) return;
        const value = calculateFormulaValue(stat.formula, luck, stat.name || statName, context);
        if (typeof value !== "number" || value === 0) return;
        parts.push(`${formatSignedValue(value)} ${statName}`);
      });
      return parts.length ? parts.join(", ") : "No stat modifiers";
    }

    function formatTierLabel(tier) {
      const tierText = String(tier || "").trim();
      if (!tierText) return "Tier";
      return /tier/i.test(tierText) ? tierText : `Tier ${tierText}`;
    }

    const abilityTierLimits = {
      Common: 0,
      Uncommon: 1,
      Rare: 2,
      Epic: 3,
      Legendary: 4
    };

    function getTierNumberFromLabel(label) {
      const normalized = String(label || "").trim();
      if (!normalized) return null;
      const numericMatch = normalized.match(/(\d+)/);
      if (numericMatch) {
        return Number(numericMatch[1]);
      }
      const lower = normalized.toLowerCase();
      const rarityTierMap = {
        common: 1,
        uncommon: 2,
        rare: 3,
        epic: 4,
        legendary: 5
      };
      if (lower in rarityTierMap) {
        return rarityTierMap[lower];
      }
      const romanMatch = lower.match(/tier\s*([ivx]+)/);
      if (!romanMatch) return null;
      const roman = romanMatch[1];
      const romanValues = { i: 1, v: 5, x: 10 };
      let total = 0;
      let prevValue = 0;
      for (let i = roman.length - 1; i >= 0; i -= 1) {
        const value = romanValues[roman[i]] || 0;
        if (value < prevValue) {
          total -= value;
        } else {
          total += value;
          prevValue = value;
        }
      }
      return total || null;
    }

    function getAbilityTierLimit(abilityName, rarity) {
      if (!rarity) return null;
      return abilityTierLimits[rarity] ?? 0;
    }

    function renderAbilityDetails(abilities, { showTierDetails = true, gearRarity = null } = {}) {
      if (!abilities || !abilities.length) {
        return `<p class="muted">No abilities.</p>`;
      }
      return abilities
        .map(ability => {
          const resolved = resolveAbilityDetails(ability);
          if (typeof resolved === "string") {
            return `
              <div>
                <strong>${resolved}</strong>
                ${showTierDetails ? `<div class="muted">No details.</div>` : ""}
              </div>
            `;
          }
          const tiers = resolved.tierDetails || {};
          const tierEntries = showTierDetails ? Object.entries(tiers) : [];
          const tierLimit = getAbilityTierLimit(resolved.name, gearRarity);
          const lines = parseAbilityLines(resolved).filter(Boolean);
          const filteredTierEntries = tierEntries.filter(([tier]) => {
            if (tierLimit === null) return true;
            const tierNumber = getTierNumberFromLabel(tier);
            return !tierNumber || tierNumber <= tierLimit;
          });
          const tierList = filteredTierEntries.length
            ? `<ul>${filteredTierEntries.map(([tier, detail]) => (
              `<li class="ability-tier"><strong>${formatTierLabel(tier)}:</strong> ${detail}</li>`
            )).join("")}</ul>`
            : (lines.length
              ? `<ul>${lines.map(line => `<li>${line}</li>`).join("")}</ul>`
              : `<p class="muted">No details.</p>`);
          return `
            <div>
              <strong><a href="${resolved.link}" target="_blank" rel="noopener">${resolved.name}</a></strong>
              ${tierList}
            </div>
          `;
        })
        .join("");
    }

    function extractTierNumbers(ability) {
      const resolved = resolveAbilityDetails(ability);
      if (!resolved || typeof resolved === "string") return [];
      const tiers = new Set();
      const details = resolved.tierDetails;
      if (details && typeof details === "object") {
        Object.keys(details).forEach(key => {
          const tierNumber = getTierNumberFromLabel(key);
          if (tierNumber) {
            tiers.add(tierNumber);
          }
        });
      }
      parseAbilityLines(resolved).forEach(line => {
        const tierNumber = getTierNumberFromLabel(line);
        if (tierNumber) {
          tiers.add(tierNumber);
        }
      });
      return [...tiers]
        .filter(value => Number.isFinite(value))
        .sort((a, b) => a - b);
    }

    function renderGearSections(stats) {
      renderEquippedSlots(stats);
      renderInventory(stats);
      renderLocalNode(stats);
    }

    function renderEquippedSlots(stats) {
      const container = elements.equippedSlots;
      container.innerHTML = "";
      const slots = getEquippedSlotList(stats);
      if (!slots.length) {
        container.innerHTML = `<span class="muted">No gear slots yet.</span>`;
        return;
      }
      slots.forEach(slot => {
        const entry = characterGear.find(item => item.equipped && item.gear_slot === slot);
        const card = document.createElement("div");
        card.className = "gear-item";
        if (!entry) {
          card.innerHTML = `
            <div class="gear-summary">
              <div class="gear-meta">
                <strong>${formatSlotLabel(slot)}</strong>
                <span class="muted">Empty</span>
              </div>
            </div>
          `;
        } else {
          card.classList.add("gear-item--equipped");
          const gear = entry.gear;
          const gearType = gear.gear_type || gear.gearType;
          const colorLabel = [gear.color, gear.color2].filter(Boolean).join(" / ") || "Neutral";
          const statSummary = buildGearStatSummary(gear, stats.luck);
          card.innerHTML = `
            <div class="gear-slot-badge">${formatSlotLabel(slot)}</div>
            <div class="gear-summary">
              <div class="gear-meta">
                <strong>${formatGearName(gear)}</strong>
                <div class="gear-tags">
                  ${renderGearTag(gearType, "type")}
                  ${renderGearTag(gear.rarity, "rarity")}
                  ${renderGearTag(colorLabel, "color", { primary: gear.color || "Neutral", secondary: gear.color2 })}
                </div>
              <span class="muted gear-stat-summary">Stats: ${statSummary}</span>
              ${isConsumable(gear) ? `<span class="muted">Consumable Summary: ${getConsumableSummary(gear)}</span>` : ""}
              </div>
              <div class="gear-actions">
                <button type="button" data-action="view" data-gear="${entry.gear_id}" aria-label="View details" title="View details"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="11" cy="11" r="6"></circle><path d="M16 16l5 5"></path></svg><span>Details</span></button>
                <button type="button" data-action="dissolve" data-gear="${entry.gear_id}" aria-label="Dissolve" title="Dissolve"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M10 3h4"></path><path d="M11 3v6l-5 8a3 3 0 0 0 2.6 4h6.8A3 3 0 0 0 18 17l-5-8V3"></path><path d="M8 14h8"></path></svg><span>Dissolve</span></button>
                <button type="button" data-action="unequip" data-gear="${entry.gear_id}" aria-label="Move to inventory" title="Move to inventory"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 4v10"></path><path d="M8 10l4 4 4-4"></path><path d="M4 20h16"></path></svg><span>Inventory</span></button>
                <button type="button" data-action="delete" data-gear="${entry.gear_id}" aria-label="Delete" title="Delete"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 7h16"></path><path d="M9 7V4h6v3"></path><path d="M7 7l1 13h8l1-13"></path><path d="M10 11v6M14 11v6"></path></svg><span>Delete</span></button>
              </div>
            </div>
          `;
        }
        container.appendChild(card);
      });
    }


    function isConsumable(gear) {
      const gearType = gear?.gear_type || gear?.gearType;
      return gearType === "Consumable";
    }

    function getConsumableType(gear) {
      return String(gear?.item_type || gear?.itemType || "").trim();
    }

    function getConsumableEffectText(gear) {
      if (!gear) return "";
      const abilities = Array.isArray(gear.abilities) ? gear.abilities : [];
      const lines = abilities
        .flatMap(ability => {
          if (!ability || typeof ability !== "object") return [];
          const details = ability.tierDetails;
          if (typeof details === "string") return [details];
          if (details && typeof details === "object") return Object.values(details).map(value => String(value || ""));
          return [];
        })
        .map(line => String(line || "").trim())
        .filter(Boolean);
      return lines[0] || "";
    }

    function getConsumableSummary(gear) {
      const type = getConsumableType(gear) || "Consumable";
      const effect = getConsumableEffectText(gear);
      if (!effect) return `${type}: Single-use consumable.`;
      return `${type}: ${effect}`;
    }

    function renderInventory(stats) {
      const container = elements.inventorySlots;
      container.innerHTML = "";
      if (elements.inventorySlotCount) {
        elements.inventorySlotCount.textContent = `${inventoryCount()}/${inventoryCapacity(stats)}`;
      }
      const inventoryItems = characterGear.filter(item => item.gear_slot === "inventory");
      if (!inventoryItems.length) {
        container.innerHTML = `<span class="muted">No gear in inventory.</span>`;
        return;
      }
      const filteredItems = sortGearEntries(inventoryItems.filter(entry => matchesGearFilters(entry.gear, stats, getInventoryFilterState())));
      if (!filteredItems.length) {
        container.innerHTML = `<span class="muted">No inventory gear matches the selected filters.</span>`;
        return;
      }
      filteredItems.forEach(entry => {
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        const colorLabel = [gear.color, gear.color2].filter(Boolean).join(" / ") || "Neutral";
        const availableSlots = availableSlotsForGear(gear, stats);
        const swapOptions = gearType === "Bauble" ? [] : getSwapOptionsForGear(gear, stats);
        const consumable = isConsumable(gear);
        const slotHint = gearType === "Bauble"
          ? "Baubles cannot be equipped."
          : (consumable
            ? "Consumable (single use)."
          : (availableSlots.length
            ? availableSlots.map(formatSlotLabel).join(", ")
            : (swapOptions.length ? "No slots open (swap available)" : "No slots open")));
        const canEquip = gearType !== "Bauble" && !consumable && (availableSlots.length || swapOptions.length);
        const colorCounts = getEquippedColorCounts();
        const gValue = gearType === "Bauble" && gear.color ? (colorCounts[gear.color] || 0) : 0;
        const statSummary = buildGearStatSummary(gear, stats.luck, { g: gValue });
        const card = document.createElement("div");
        card.className = "gear-item";
        card.innerHTML = `
          <div class="gear-summary">
            <div class="gear-meta">
              <strong>${formatGearName(gear)}</strong>
              <div class="gear-tags">
                ${renderGearTag(gearType, "type")}
                ${renderGearTag(gear.rarity, "rarity")}
                ${renderGearTag(colorLabel, "color", { primary: gear.color || "Neutral", secondary: gear.color2 })}
              </div>
              <span class="muted">Equip Slots: ${slotHint}</span>
              <span class="muted gear-stat-summary">Stats: ${statSummary}</span>
              ${consumable ? `<span class="muted">Consumable Summary: ${getConsumableSummary(gear)}</span>` : ""}
            </div>
            <div class="gear-actions">
              <button type="button" data-action="view" data-gear="${entry.gear_id}" aria-label="View details" title="View details"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="11" cy="11" r="6"></circle><path d="M16 16l5 5"></path></svg><span>Details</span></button>
              ${consumable
                ? `<button type="button" data-action="use" data-gear="${entry.gear_id}" aria-label="Use" title="Use"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M13 2L5 13h6l-1 9 9-13h-6z"></path></svg><span>Use</span></button>`
                : (gearType === "Bauble" ? "" : `<button type="button" data-action="equip" data-gear="${entry.gear_id}" ${canEquip ? "" : "disabled"} aria-label="Equip" title="Equip"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3l7 3v5c0 5-3 8-7 10-4-2-7-5-7-10V6z"></path></svg><span>Equip</span></button>`)}
              <button type="button" data-action="local" class="gear-action-wide" data-gear="${entry.gear_id}" aria-label="Move to local node storage" title="Move to local node storage"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 4v10"></path><path d="M8 10l4 4 4-4"></path><path d="M4 20h16"></path></svg><span>Local Storage</span></button>
              <button type="button" data-action="dissolve" data-gear="${entry.gear_id}" aria-label="Dissolve" title="Dissolve"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M10 3h4"></path><path d="M11 3v6l-5 8a3 3 0 0 0 2.6 4h6.8A3 3 0 0 0 18 17l-5-8V3"></path><path d="M8 14h8"></path></svg><span>Dissolve</span></button>
              <button type="button" data-action="delete" data-gear="${entry.gear_id}" aria-label="Delete" title="Delete"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 7h16"></path><path d="M9 7V4h6v3"></path><path d="M7 7l1 13h8l1-13"></path><path d="M10 11v6M14 11v6"></path></svg><span>Delete</span></button>
            </div>
          </div>
        `;
        container.appendChild(card);
      });
    }

    function renderLocalNode(stats) {
      const container = elements.localNodeSlots;
      container.innerHTML = "";
      if (elements.localNodeSlotCount) {
        elements.localNodeSlotCount.textContent = `${localNodeCount()}/${localNodeCapacity(stats)}`;
      }
      const localItems = characterGear.filter(item => item.gear_slot === "local_node");
      if (!localItems.length) {
        container.innerHTML = `<span class="muted">No gear in local node storage.</span>`;
        return;
      }
      const filteredItems = sortGearEntries(localItems.filter(entry => matchesGearFilters(entry.gear, stats, getLocalNodeFilterState())));
      if (!filteredItems.length) {
        container.innerHTML = `<span class="muted">No local node gear matches the selected filters.</span>`;
        return;
      }
      filteredItems.forEach(entry => {
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        const colorLabel = [gear.color, gear.color2].filter(Boolean).join(" / ") || "Neutral";
        const colorCounts = getEquippedColorCounts();
        const gValue = gearType === "Bauble" && gear.color ? (colorCounts[gear.color] || 0) : 0;
        const statSummary = buildGearStatSummary(gear, stats.luck, { g: gValue });
        const consumable = isConsumable(gear);
        const card = document.createElement("div");
        card.className = "gear-item";
        card.innerHTML = `
          <div class="gear-summary">
            <div class="gear-meta">
              <strong>${formatGearName(gear)}</strong>
              <div class="gear-tags">
                ${renderGearTag(gearType, "type")}
                ${renderGearTag(gear.rarity, "rarity")}
                ${renderGearTag(colorLabel, "color", { primary: gear.color || "Neutral", secondary: gear.color2 })}
              </div>
              <span class="muted">Stored in Local Node</span>
              <span class="muted gear-stat-summary">Stats: ${statSummary}</span>
              ${consumable ? `<span class="muted">Consumable Summary: ${getConsumableSummary(gear)}</span>` : ""}
            </div>
            <div class="gear-actions">
              <button type="button" data-action="view" data-gear="${entry.gear_id}" aria-label="View details" title="View details"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="11" cy="11" r="6"></circle><path d="M16 16l5 5"></path></svg><span>Details</span></button>
              <button type="button" data-action="dissolve" data-gear="${entry.gear_id}" aria-label="Dissolve" title="Dissolve"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M10 3h4"></path><path d="M11 3v6l-5 8a3 3 0 0 0 2.6 4h6.8A3 3 0 0 0 18 17l-5-8V3"></path><path d="M8 14h8"></path></svg><span>Dissolve</span></button>
              <button type="button" data-action="inventory" data-gear="${entry.gear_id}" aria-label="Move to inventory" title="Move to inventory"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 4v10"></path><path d="M8 10l4 4 4-4"></path><path d="M4 20h16"></path></svg><span>Inventory</span></button>
              <button type="button" data-action="delete" data-gear="${entry.gear_id}" aria-label="Delete" title="Delete"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 7h16"></path><path d="M9 7V4h6v3"></path><path d="M7 7l1 13h8l1-13"></path><path d="M10 11v6M14 11v6"></path></svg><span>Delete</span></button>
            </div>
          </div>
        `;
        container.appendChild(card);
      });
    }

    function renderAbilities() {
      const container = elements.abilitiesList;
      if (!container) return;
      const actives = [];
      const passives = [];
      const effects = [];

      characterGear.forEach(entry => {
        if (!entry.gear) return;
        const gear = entry.gear;
        const gearType = gear.gear_type || gear.gearType;
        if (gearType === "Bauble" && entry.gear_slot === "inventory") {
          (gear.abilities || []).forEach(ability => effects.push(ability));
          return;
        }
        if (!entry.equipped) return;
        if (gearType === "Kernel") {
          (gear.abilities || []).forEach(ability => passives.push(ability));
        } else {
          (gear.abilities || []).forEach(ability => actives.push({ ability, rarity: gear.rarity }));
        }
      });

      const renderAbilityDropdowns = (list, { showTierEnergy = false, showTierDetails = true } = {}) => {
        if (!list.length) {
          return `<p class="muted">None.</p>`;
        }
        return list
          .map(ability => {
            const abilityEntry = ability && typeof ability === "object" && "ability" in ability
              ? ability
              : { ability, rarity: null };
            const resolved = resolveAbilityDetails(abilityEntry.ability);
            const abilityName = typeof resolved === "string" ? resolved : resolved.name;
            const abilityLink = typeof resolved === "string" ? "" : resolved.link;
            const lines = parseAbilityLines(resolved).filter(Boolean);
            const tierDetails = typeof resolved === "string" ? null : resolved.tierDetails;
            const tierEntries = showTierDetails && tierDetails && typeof tierDetails === "object" && !Array.isArray(tierDetails)
              ? Object.entries(tierDetails)
              : [];
            const tierLimit = getAbilityTierLimit(abilityName, abilityEntry.rarity);
            const filteredTierEntries = tierEntries.filter(([tier]) => {
              if (tierLimit === null) return true;
              const tierNumber = getTierNumberFromLabel(tier);
              return !tierNumber || tierNumber <= tierLimit;
            });
            const detailsList = filteredTierEntries.length
              ? `<ul>${filteredTierEntries
                .map(([tier, detail]) => (
                  `<li class="ability-tier"><strong>${formatTierLabel(tier)}:</strong> ${detail}</li>`
                ))
                .join("")}</ul>`
              : (lines.length
                ? `<ul>${lines.map(line => `<li>${line}</li>`).join("")}</ul>`
                : `<p class="muted">No details.</p>`);
            return `
              <div class="ability-dropdown">
                <button type="button" class="ability-summary" aria-expanded="false">
                  ${abilityName}
                </button>
                <div class="ability-details" hidden>
                  ${detailsList}
                  ${abilityLink ? `<a href="${abilityLink}" target="_blank" rel="noopener">View full ability details</a>` : ""}
                </div>
              </div>
            `;
          })
          .join("");
      };

      const renderAbilityGroup = (title, list, options = {}) => `
        <div class="ability-group">
          <h3>${title}</h3>
          ${renderAbilityDropdowns(list, options)}
        </div>
      `;

      container.innerHTML = `
        ${renderAbilityGroup("Actives", actives, { showTierEnergy: true, showTierDetails: true })}
        ${renderAbilityGroup("Passives", passives, { showTierDetails: false })}
        ${renderAbilityGroup("Effects", effects, { showTierDetails: false })}
      `;
    }

    function inventoryCapacity(stats) {
      return Math.max(Number(stats.inventory_slots) || 0, 0);
    }

    function localNodeCapacity(stats) {
      return inventoryCapacity(stats) * 3;
    }

    function inventoryCount() {
      return characterGear.filter(entry => entry.gear_slot === "inventory").length;
    }

    function localNodeCount() {
      return characterGear.filter(entry => entry.gear_slot === "local_node").length;
    }

    function findGearEntry(gearId) {
      return characterGear.find(entry => String(entry.gear_id) === String(gearId));
    }

    async function ensurePyodide() {
      if (pyodideReady) return pyodideClient;
      elements.gearGeneratorStatus.textContent = "Loading gear generator…";
      elements.openGearGenerator.classList.add("hidden");
      try {
        const { loadPyodide } = await import("https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.mjs");
        pyodideClient = await loadPyodide();

        const pyFiles = [
          "abilityCatalog.py",
          "ability.py",
          "statbuff.py",
          "miscFunc.py",
          "gear.py",
          "helperFunc.py"
        ];

        for (const name of pyFiles) {
          const resp = await fetch(name);
          if (!resp.ok) throw new Error(`Failed to fetch ${name}: ${resp.status}`);
          const code = await resp.text();
          pyodideClient.FS.writeFile(name, code);
        }

        pyodideClient.runPython(`
          import json, random
          from gear import Gear
          from helperFunc import gearTypeMap

          def _serialize_ability(ability):
              if isinstance(ability, str):
                  return {
                      "name": ability,
                      "link": "",
                      "tierDetails": "No tier details."
                  }
              details = ability.tierDetails
              if isinstance(details, str):
                  details = { "Detail": details }
              return {
                  "name": ability.name,
                  "link": ability.link,
                  "tierDetails": details
              }

          def _serialize_gear(gear):
              stats = []
              for buff in gear.basicStatBuffs + gear.colorStatBuffs:
                  stats.append({
                      "name": buff.normalName,
                      "label": buff.name,
                      "formula": buff.formula,
                      "value": buff.calc
                  })
              abilities = [_serialize_ability(ab) for ab in gear.abilities]
              if gear.gearType == "Consumable":
                  effect_details = {"Effect": str(getattr(gear, "specificEffect", ""))}
                  abilities = [{
                      "name": f"{getattr(gear, 'consumableType', 'Consumable')} Effect",
                      "link": "",
                      "tierDetails": effect_details
                  }]
              aesthetic = getattr(gear, "aesthetic", None) or getattr(gear, "baubleAesthetic", None)
              payload = {
                  "rarity": gear.rarity,
                  "color": gear.color,
                  "color2": gear.color2,
                  "gear_type": gear.gearType,
                  "item_type": gear.specificItem,
                  "aesthetic": aesthetic,
                  "essence_value": gear.essenceValue,
                  "credit_value": gear.creditValue,
                  "abilities": abilities,
                  "stats": stats,
                  "stat_modifiers": []
              }
              if gear.gearType == "Bauble":
                  payload["stat_modifiers"] = [
                      {
                          "name": buff.normalName,
                          "label": buff.name,
                          "formula": buff.formula
                      }
                      for buff in gear.colorStatBuffs
                  ]
                  payload["stats"] = []
              return payload

          def generate_gear_json(luck:int, amount:int, gearTypeNumber:int, rarity, color, color2):
              rarity = rarity if rarity else None
              color = color if color else None
              color2 = color2 if color2 else None
              output = []
              for _ in range(amount):
                  gearType = gearTypeMap.get(gearTypeNumber)
                  if gearType is None:
                      gearType = random.choice([v for v in gearTypeMap.values() if v])
                  gear = Gear(luck, gearType, rarity, color, color2)
                  output.append(_serialize_gear(gear))
              return json.dumps(output)

          def list_abilities_json():
              import abilityCatalog
              abilities = set()
              colors = ["Neutral", "Red", "Blue", "Green", "Gray"]
              color2_options = [None, "Neutral", "Red", "Blue", "Green", "Gray"]

              for name, cls in abilityCatalog.__dict__.items():
                  if not isinstance(cls, type):
                      continue
                  if not issubclass(cls, abilityCatalog.AbilityCatalog):
                      continue
                  if cls is abilityCatalog.AbilityCatalog:
                      continue
                  for color in colors:
                      for color2 in color2_options:
                          try:
                              instance = cls(color, color2)
                          except TypeError:
                              try:
                                  instance = cls(color)
                              except Exception:
                                  continue
                          except Exception:
                              continue
                          if isinstance(instance.abilities, dict):
                              abilities.update(instance.abilities.keys())
                          elif isinstance(instance.abilities, list):
                              abilities.update(instance.abilities)
              return json.dumps(sorted(list(abilities)))

          def list_ability_details_json():
              import abilityCatalog
              colors = ["Neutral", "Red", "Blue", "Green", "Gray"]
              color2_options = [None, "Neutral", "Red", "Blue", "Green", "Gray"]
              link_suffixes = {
                  abilityCatalog.WeaponActiveCatalog: "https://xeonrapture.com/xr/XRRPG+2.0/Sub-RPGs/Webrunning+2.0/Gear+Generation/Gear+Actives#",
                  abilityCatalog.ClothingActiveCatalog: "https://xeonrapture.com/xr/XRRPG+2.0/Sub-RPGs/Webrunning+2.0/Gear+Generation/Gear+Actives#",
                  abilityCatalog.PassiveCatalog: "https://xeonrapture.com/xr/XRRPG+2.0/Sub-RPGs/Webrunning+2.0/Gear+Generation/Kernels#",
                  abilityCatalog.ConsumableEffectCatalog: "https://xeonrapture.com/xr/XRRPG+2.0/Sub-RPGs/Webrunning+2.0/Gear+Generation/Consumables#",
                  abilityCatalog.BaubleEffectCatalog: "https://xeonrapture.com/xr/XRRPG+2.0/Sub-RPGs/Webrunning+2.0/Gear+Generation/Baubles#"
              }
              ability_map = {}

              def normalize_details(details):
                  if isinstance(details, str):
                      return { "Detail": details }
                  if isinstance(details, list):
                      return { f"Detail {index + 1}": detail for index, detail in enumerate(details) }
                  if isinstance(details, dict):
                      return details
                  return { "Detail": str(details) }

              for name, cls in abilityCatalog.__dict__.items():
                  if not isinstance(cls, type):
                      continue
                  if not issubclass(cls, abilityCatalog.AbilityCatalog):
                      continue
                  if cls is abilityCatalog.AbilityCatalog:
                      continue
                  link_suffix = link_suffixes.get(cls, "")
                  for color in colors:
                      for color2 in color2_options:
                          try:
                              instance = cls(color, color2)
                          except TypeError:
                              try:
                                  instance = cls(color)
                              except Exception:
                                  continue
                          except Exception:
                              continue
                          if isinstance(instance.abilities, dict):
                              for ability_name, details in instance.abilities.items():
                                  if ability_name in ability_map:
                                      continue
                                  ability_map[ability_name] = {
                                      "name": ability_name,
                                      "link": f"{link_suffix}{ability_name.replace(' ', '+')}" if link_suffix else "",
                                      "tierDetails": normalize_details(details)
                                  }
                          elif isinstance(instance.abilities, list):
                              for ability_name in instance.abilities:
                                  if ability_name in ability_map:
                                      continue
                                  ability_map[ability_name] = {
                                      "name": ability_name,
                                      "link": f"{link_suffix}{ability_name.replace(' ', '+')}" if link_suffix else "",
                                      "tierDetails": { "Detail": "No tier details." }
                                  }
              return json.dumps(ability_map)
        `);

        pyodideReady = true;
        if (!availableAbilities.length) {
          try {
            const abilityJson = pyodideClient.runPython("list_abilities_json()");
            availableAbilities = JSON.parse(abilityJson) || [];
            refreshAbilitySelectOptions();
          } catch (abilityError) {
            console.warn("Failed to load ability list", abilityError);
          }
        }
        try {
          const abilityDetailJson = pyodideClient.runPython("list_ability_details_json()");
          const abilityDetails = JSON.parse(abilityDetailJson) || {};
          abilityDetailMap = new Map(Object.entries(abilityDetails));
        } catch (detailError) {
          console.warn("Failed to load ability details", detailError);
        }
        elements.gearGeneratorStatus.textContent = "";
        elements.openGearGenerator.classList.remove("hidden");
        pushStatus("Gear generator ready.", { tone: "success", duration: 2500 });
        return pyodideClient;
      } catch (error) {
        console.error(error);
        elements.gearGeneratorStatus.textContent = "Failed to load gear generator.";
        pushStatus("Failed to load gear generator.", { tone: "error" });
        throw error;
      }
    }

    async function openGearGeneratorModal() {
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const hasTempBuffs = tempConsumableSummary.length > 0;
      if (elements.tempBuffSection) {
        elements.tempBuffSection.classList.toggle("hidden", !hasTempBuffs);
      }
      if (elements.tempBuffSummary) {
        elements.tempBuffSummary.textContent = hasTempBuffs
          ? `Active Temp Buffs: ${tempConsumableSummary.join(" | ")}`
          : "No active temporary consumable buffs.";
      }
      if (elements.clearTempBuffs) {
        elements.clearTempBuffs.classList.toggle("hidden", !hasTempBuffs);
      }
      updateGearGeneratorLuck(stats);
      gearGeneratorModal.classList.remove("hidden");
      await ensurePyodide();
    }

    function closeGearGeneratorModal() {
      gearGeneratorModal.classList.add("hidden");
    }

    function renderGeneratedGear(stats) {
      generatedGearList.innerHTML = "";
      if (!generatedGear.length) {
        generatedGearList.innerHTML = `<span class="muted">No gear generated yet.</span>`;
        if (addAllGeneratedGearButton) {
          addAllGeneratedGearButton.disabled = true;
        }
        return;
      }
      if (addAllGeneratedGearButton) {
        addAllGeneratedGearButton.disabled = false;
      }
      const totalLuck = getGearGeneratorLuck(stats);
      const colorCounts = getEquippedColorCounts();
      generatedGear.forEach((gear, index) => {
        const card = document.createElement("div");
        card.className = "gear-item";
        const gearType = gear.gear_type || gear.gearType;
        const showTierDetails = !["Kernel", "Bauble"].includes(gearType);
        const colorLabel = [gear.color, gear.color2].filter(Boolean).join(" / ") || "Neutral";
        const gValue = gearType === "Bauble" && gear.color ? (colorCounts[gear.color] || 0) : 0;
        const statList = renderGearStatsList(gear.stats, gear.stat_modifiers, totalLuck, { g: gValue });
        const isAdded = gear.__added;
        const consumable = isConsumable(gear);
        const availableSlots = availableSlotsForGear(gear, stats);
        const swapOptions = gearType === "Bauble" ? [] : getSwapOptionsForGear(gear, stats);
        const canEquip = gearType !== "Bauble" && !consumable && (availableSlots.length || swapOptions.length);
        card.innerHTML = `
          <div class="gear-summary">
            <div class="gear-meta">
              <strong>${formatGearName(gear)}</strong>
              <div class="gear-tags">
                ${renderGearTag(gearType, "type")}
                ${renderGearTag(gear.rarity, "rarity")}
                ${renderGearTag(colorLabel, "color", { primary: gear.color || "Neutral", secondary: gear.color2 })}
              </div>
            </div>
            <div class="gear-actions">
              <button type="button" data-action="add" data-index="${index}" ${isAdded ? "disabled" : ""} aria-label="Add to inventory" title="Add to inventory">${isAdded ? '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><path d="M8 12l3 3 5-6"></path></svg><span>Added</span>' : '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 4v10"></path><path d="M8 10l4 4 4-4"></path><path d="M4 20h16"></path></svg><span>Add</span>'}</button>
              ${consumable
                ? `<button type="button" data-action="use" data-index="${index}" ${isAdded ? "" : "disabled"} aria-label="Use" title="Use"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M13 2L5 13h6l-1 9 9-13h-6z"></path></svg><span>Use</span></button>`
                : (gearType === "Bauble" ? "" : `<button type="button" data-action="equip" data-index="${index}" ${isAdded || !canEquip ? "disabled" : ""} aria-label="Equip" title="Equip">${isAdded ? '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><path d="M8 12l3 3 5-6"></path></svg><span>Equipped</span>' : '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3l7 3v5c0 5-3 8-7 10-4-2-7-5-7-10V6z"></path></svg><span>Equip</span>'}</button>`)}
              <button type="button" data-action="remove" data-index="${index}" ${!isAdded ? "disabled" : ""} aria-label="Remove from character" title="Remove from character">${isAdded ? '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 20V10"></path><path d="M8 14l4-4 4 4"></path><path d="M4 4h16"></path></svg><span>Remove</span>' : '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><rect x="7" y="6" width="3" height="12"></rect><rect x="14" y="6" width="3" height="12"></rect></svg><span>Not Added</span>'}</button>
            </div>
          </div>
          <div class="gear-details-list">
            <strong>Stats</strong>
            ${statList}
            ${consumable ? `<strong>Consumable Summary</strong><p>${getConsumableSummary(gear)}</p>` : ""}
            <strong>Abilities</strong>
            ${renderAbilityDetails(gear.abilities, { showTierDetails, gearRarity: gear.rarity })}
          </div>
        `;
        generatedGearList.appendChild(card);
      });
    }

    async function handleGenerateGear() {
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const totalLuck = getGearGeneratorLuck(stats);
      const amount = Math.max(Number(gearAmount.value) || 1, 1);
      const gearTypeValue = parseInt(gearTypeNumber.value, 10);
      const rarity = gearRarity.value;
      const color = gearColor.value;
      const color2 = gearColor2.value;

      try {
        await ensurePyodide();
        const result = pyodideClient.runPython(
          `generate_gear_json(${totalLuck}, ${amount}, ${gearTypeValue}, ${JSON.stringify(rarity)}, ${JSON.stringify(color)}, ${JSON.stringify(color2)})`
        );
        generatedGear = JSON.parse(result);
        generatedGear.forEach(gear => {
          if (!gear.name) {
            gear.name = formatGearName(gear);
          }
        });
        renderGeneratedGear(stats);
      } catch (error) {
        console.error(error);
        pushStatus("Failed to generate gear.", { tone: "error" });
      }
    }

    function buildStatOptionList(selectedValue = "") {
      return statOptions
        .map(stat => `<option value="${stat}" ${stat === selectedValue ? "selected" : ""}>${stat}</option>`)
        .join("");
    }

    function buildFormulaOptionList(selectedValue = "") {
      return baubleFormulaOptions
        .map(formula => `<option value="${formula}" ${formula === selectedValue ? "selected" : ""}>${formula}</option>`)
        .join("");
    }

    function buildAbilityOptionList(selectedValue = "") {
      const list = availableAbilities.length ? [...availableAbilities] : ["Custom Ability"];
      if (selectedValue && !list.includes(selectedValue)) {
        list.unshift(selectedValue);
      }
      return list
        .map(ability => `<option value="${ability}" ${ability === selectedValue ? "selected" : ""}>${ability}</option>`)
        .join("");
    }

    function createManualStatRow({ statName = "", value = 0, formula = "" } = {}) {
      const row = document.createElement("div");
      row.className = "manual-gear-row";
      row.innerHTML = `
        <select class="manual-gear-stat-name">
          ${buildStatOptionList(statName || statOptions[0])}
        </select>
        <div class="manual-gear-stat-value"></div>
        <button type="button" class="manual-gear-remove" aria-label="Remove" title="Remove"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M5 12h14"></path></svg><span>Remove</span></button>
      `;
      const valueContainer = row.querySelector(".manual-gear-stat-value");
      const removeButton = row.querySelector(".manual-gear-remove");
      removeButton.addEventListener("click", () => {
        row.remove();
      });
      const isBauble = manualGearType.value === "Bauble";
      if (isBauble) {
        valueContainer.innerHTML = `
          <select class="manual-gear-formula">
            ${buildFormulaOptionList(formula || baubleFormulaOptions[0])}
          </select>
        `;
      } else {
        valueContainer.innerHTML = `
          <input class="manual-gear-value" type="number" value="${value}" />
        `;
      }
      manualGearStatsList.appendChild(row);
    }

    function refreshManualStatRowsForType() {
      const isBauble = manualGearType.value === "Bauble";
      manualGearStatsList.querySelectorAll(".manual-gear-row").forEach(row => {
        const valueContainer = row.querySelector(".manual-gear-stat-value");
        if (!valueContainer) return;
        if (isBauble) {
          const currentFormula = row.querySelector(".manual-gear-formula")?.value || baubleFormulaOptions[0];
          valueContainer.innerHTML = `
            <select class="manual-gear-formula">
              ${buildFormulaOptionList(currentFormula)}
            </select>
          `;
        } else {
          const currentValue = row.querySelector(".manual-gear-value")?.value || 0;
          valueContainer.innerHTML = `<input class="manual-gear-value" type="number" value="${currentValue}" />`;
        }
      });
    }

    function createManualAbilityRow(selectedValue = "") {
      const row = document.createElement("div");
      row.className = "manual-gear-row";
      row.innerHTML = `
        <select class="manual-gear-ability">
          ${buildAbilityOptionList(selectedValue)}
        </select>
        <div class="manual-gear-stat-value"></div>
        <button type="button" class="manual-gear-remove" aria-label="Remove" title="Remove"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M5 12h14"></path></svg><span>Remove</span></button>
      `;
      const removeButton = row.querySelector(".manual-gear-remove");
      removeButton.addEventListener("click", () => {
        row.remove();
      });
      manualGearAbilitiesList.appendChild(row);
    }

    function readManualStatRows() {
      const isBauble = manualGearType.value === "Bauble";
      const rows = Array.from(manualGearStatsList.querySelectorAll(".manual-gear-row"));
      if (isBauble) {
        return rows
          .map(row => {
            const statName = row.querySelector(".manual-gear-stat-name")?.value;
            const formula = row.querySelector(".manual-gear-formula")?.value;
            if (!statName || !formula) return null;
            return { name: statName, label: statName, formula };
          })
          .filter(Boolean);
      }
      return rows
        .map(row => {
          const statName = row.querySelector(".manual-gear-stat-name")?.value;
          const rawValue = Number(row.querySelector(".manual-gear-value")?.value || 0);
          if (!statName) return null;
          return {
            name: statName,
            label: statName,
            formula: formatSignedValue(rawValue),
            value: rawValue
          };
        })
        .filter(Boolean);
    }

    function readManualAbilities() {
      return Array.from(manualGearAbilitiesList.querySelectorAll(".manual-gear-ability"))
        .map(select => select.value)
        .filter(Boolean);
    }

    function buildManualGearPayload() {
      const isBauble = manualGearType.value === "Bauble";
      const stats = isBauble ? [] : readManualStatRows();
      const statModifiers = isBauble ? readManualStatRows() : [];
      const abilities = readManualAbilities();
      const payload = {
        name: manualGearName.value.trim() || null,
        rarity: manualGearRarity.value,
        color: manualGearColor.value,
        color2: manualGearColor2.value || null,
        gear_type: manualGearType.value,
        item_type: manualGearItemType.value.trim() || null,
        aesthetic: manualGearAesthetic.value.trim() || null,
        essence_value: Number(manualGearEssence.value) || 0,
        credit_value: Number(manualGearCredit.value) || 0,
        stats,
        stat_modifiers: statModifiers,
        abilities
      };
      if (!payload.name) {
        payload.name = formatGearName(payload);
      }
      return payload;
    }

    function populateGearFilterSelects() {
      const unique = list => Array.from(new Set(list));
      const appendOptions = (select, options) => {
        if (!select) return;
        const current = select.value;
        select.querySelectorAll("option:not([value=''])").forEach(option => option.remove());
        options.forEach(option => {
          const element = document.createElement("option");
          element.value = option;
          element.textContent = option;
          select.appendChild(element);
        });
        if (options.includes(current)) {
          select.value = current;
        }
      };

      appendOptions(gearFilterRarity, unique(raritySortOrder));
      appendOptions(gearFilterType, unique(gearTypeSortOrder));
      appendOptions(gearFilterColor, unique(colorSortOrder));
      appendOptions(gearFilterStat, unique(statOptions));
      appendOptions(localGearFilterRarity, unique(raritySortOrder));
      appendOptions(localGearFilterType, unique(gearTypeSortOrder));
      appendOptions(localGearFilterColor, unique(colorSortOrder));
      appendOptions(localGearFilterStat, unique(statOptions));
    }

    function refreshAbilitySelectOptions() {
      manualGearAbilitiesList.querySelectorAll(".manual-gear-ability").forEach(select => {
        const current = select.value;
        select.innerHTML = buildAbilityOptionList(current);
      });
    }

    function resetManualGearStatus() {
      manualGearStatus.textContent = "";
    }

    function handleManualGearAdd() {
      resetManualGearStatus();
      try {
        const payload = buildManualGearPayload();
        generatedGear.unshift(payload);
        renderGeneratedGear(applyGearBonuses(currentStats(), calculateGearBonuses(currentStats())));
        manualGearStatus.textContent = "Manual gear added.";
      } catch (error) {
        console.error(error);
        manualGearStatus.textContent = "Failed to add manual gear.";
      }
    }

    async function addAllGeneratedGear() {
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const available = inventoryCapacity(stats) - inventoryCount();
      if (available <= 0) {
        pushStatus("No inventory slots available.", { tone: "warning" });
        return;
      }
      let added = 0;
      for (const gear of generatedGear) {
        if (gear.__added) continue;
        if (added >= available) break;
        const inserted = await insertGearToInventory(gear);
        if (inserted) {
          gear.__added = true;
          added += 1;
        }
      }
      if (added) {
        pushStatus(`Added ${added} gear item(s) to inventory.`, { tone: "success" });
      } else {
        pushStatus("No new gear was added.", { tone: "warning" });
      }
      renderGeneratedGear(applyGearBonuses(currentStats(), calculateGearBonuses(currentStats())));
    }

    function buildGearInsertPayload(gear) {
      return {
        name: gear.name || formatGearName(gear),
        rarity: gear.rarity,
        color: gear.color,
        color2: gear.color2 || null,
        gear_type: gear.gear_type || gear.gearType,
        aesthetic: gear.aesthetic || null,
        item_type: gear.item_type || gear.itemType || null,
        stats: gear.stats || [],
        essence_value: gear.essence_value || gear.essenceValue || 0,
        credit_value: gear.credit_value || gear.creditValue || 0,
        abilities: gear.abilities || [],
        stat_modifiers: gear.stat_modifiers || gear.statModifiers || [],
        notes: gear.notes || null
      };
    }

    function gearSignature(gear) {
      return JSON.stringify(buildGearInsertPayload(gear));
    }

    function isDuplicateGear(gear) {
      const signature = gearSignature(gear);
      return characterGear.some(entry => entry.gear && gearSignature(entry.gear) === signature);
    }

    async function insertGearToInventory(gear, options = {}) {
      if (!activeCharacter?.id) {
        pushStatus("Save the character before adding gear.", { tone: "warning" });
        return null;
      }
      if (isDuplicateGear(gear)) {
        pushStatus("That gear is already stored on this character.", { tone: "warning" });
        return null;
      }
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const slot = options.slot || "inventory";
      if (slot === "inventory" && inventoryCount() >= inventoryCapacity(stats)) {
        pushStatus("No inventory slots available.", { tone: "warning" });
        return null;
      }
      const payload = buildGearInsertPayload(gear);
      const { data, error } = await sb
        .from("webrunning_gear")
        .insert(payload)
        .select("*")
        .maybeSingle();
      if (error) throw error;

      const linkPayload = {
        character_id: activeCharacter.id,
        gear_id: data.id,
        equipped: slot !== "inventory" && slot !== "local_node",
        gear_slot: slot
      };
      const { error: linkError } = await sb
        .from("webrunning_character_gear")
        .insert(linkPayload);
      if (linkError) throw linkError;

      characterGear.push({
        gear_id: data.id,
        equipped: linkPayload.equipped,
        gear_slot: slot,
        gear: data
      });
      render();
      return data;
    }

    async function addGeneratedGear(index, action) {
      const gear = generatedGear[index];
      if (!gear) return;
      if (gear.__added) {
        pushStatus("That gear has already been added.", { tone: "warning" });
        return;
      }
      if (action === "equip") {
        const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
        const slots = availableSlotsForGear(gear, stats);
        if (!slots.length) {
          const swapOptions = getSwapOptionsForGear(gear, stats);
          if (!swapOptions.length) {
            pushStatus("No open slots for that gear.", { tone: "warning" });
            return;
          }
          if (inventoryCount() >= inventoryCapacity(stats)) {
            pushStatus("No inventory slots available to swap gear.", { tone: "warning" });
            return;
          }
          const selected = selectSwapSlot(swapOptions);
          if (!selected) {
            pushStatus("No swap targets available.", { tone: "warning" });
            return;
          }
          const inserted = await insertGearToInventory(gear, { slot: selected.slot });
          if (!inserted) return;
          await updateGearSlot(selected.entry, "inventory");
        } else {
          const inserted = await insertGearToInventory(gear, { slot: slots[0] });
          if (!inserted) return;
        }
      } else {
        const inserted = await insertGearToInventory(gear);
        if (!inserted) return;
      }
      gear.__added = true;
      pushStatus("Gear added.", { tone: "success" });
      renderGeneratedGear(applyGearBonuses(currentStats(), calculateGearBonuses(currentStats())));
    }

    async function removeGeneratedGearFromCharacter(gear) {
      if (!gear) return;
      const signature = gearSignature(gear);
      const entry = characterGear.find(item => item.gear && gearSignature(item.gear) === signature);
      if (!entry) {
        pushStatus("That gear isn't on this character.", { tone: "warning" });
        gear.__added = false;
        renderGeneratedGear(applyGearBonuses(currentStats(), calculateGearBonuses(currentStats())));
        return;
      }
      activeGearRow = entry;
      await deleteGear({ mode: "delete" });
      gear.__added = false;
      renderGeneratedGear(applyGearBonuses(currentStats(), calculateGearBonuses(currentStats())));
    }

    function getRespecBonusPointsByRarity(rarity) {
      if (rarity === "Legendary") return 2;
      if (rarity === "Rare" || rarity === "Epic") return 1;
      return 0;
    }

    function applyTempConsumableStats(gear) {
      const bonus = createEmptyBonus();
      const applied = [];
      (gear.stats || []).forEach(stat => {
        const statName = stat.name || stat.stat || stat.label;
        const value = Number(stat.value ?? stat.calc);
        if (!statName || !Number.isFinite(value) || value === 0) return;
        applyStatBonus(bonus, statName, value, "Temp Buff", null);
        applied.push(`${formatSignedValue(value)} ${statName}`);
      });
      tempConsumableBonus = mergeBonuses(tempConsumableBonus, bonus);
      if (applied.length) {
        tempConsumableSummary.push(`${formatGearName(gear)}: ${applied.join(", ")}`);
      }
    }

    function openRespecModal(baseStats, bonusPoints = 0) {
      return new Promise(resolve => {
        if (!respecModal) {
          resolve(null);
          return;
        }
        const baseTotal = (Number(baseStats.power) || 0) + (Number(baseStats.defense) || 0) + (Number(baseStats.speed) || 0) + (Number(baseStats.intelligence) || 0);
        const totalPoints = baseTotal + bonusPoints;
        const setRemaining = () => {
          const used = (Number(respecPower.value) || 0) + (Number(respecDefense.value) || 0) + (Number(respecSpeed.value) || 0) + (Number(respecIntelligence.value) || 0);
          respecPointsRemaining.textContent = String(totalPoints - used);
        };

        respecPower.value = Number(baseStats.power) || 0;
        respecDefense.value = Number(baseStats.defense) || 0;
        respecSpeed.value = Number(baseStats.speed) || 0;
        respecIntelligence.value = Number(baseStats.intelligence) || 0;
        respecModalHint.textContent = `Reallocate your current points and add ${bonusPoints} bonus point(s).`;
        respecModalMsg.textContent = "";
        setRemaining();
        respecModal.classList.remove("hidden");

        const clean = (value) => {
          [respecPower, respecDefense, respecSpeed, respecIntelligence].forEach(input => input.removeEventListener("input", setRemaining));
          respecApplyBtn.removeEventListener("click", submit);
          respecCancelBtn.removeEventListener("click", cancel);
          respecModalBackdrop?.removeEventListener("click", cancel);
          respecModal.classList.add("hidden");
          resolve(value);
        };

        const submit = () => {
          const next = {
            power: Number(respecPower.value) || 0,
            defense: Number(respecDefense.value) || 0,
            speed: Number(respecSpeed.value) || 0,
            intelligence: Number(respecIntelligence.value) || 0
          };
          const used = next.power + next.defense + next.speed + next.intelligence;
          const valid = Object.values(next).every(value => Number.isFinite(value) && value >= 0);
          if (!valid || used !== totalPoints) {
            respecModalMsg.textContent = `Allocate exactly ${totalPoints} total points.`;
            return;
          }
          clean(next);
        };

        const cancel = () => clean(null);

        [respecPower, respecDefense, respecSpeed, respecIntelligence].forEach(input => input.addEventListener("input", setRemaining));
        respecApplyBtn.addEventListener("click", submit);
        respecCancelBtn.addEventListener("click", cancel);
        respecModalBackdrop?.addEventListener("click", cancel);
      });
    }

    function openEnergyColorModal(defaultColor = "red") {
      return new Promise(resolve => {
        if (!energyModal || !energyColorSelect || !energyApplyBtn || !energyCancelBtn) {
          resolve(defaultColor);
          return;
        }

        const allowedColors = ["red", "blue", "green", "gray"];
        const fallback = allowedColors.includes(defaultColor) ? defaultColor : "red";
        energyColorSelect.value = fallback;
        energyModal.classList.remove("hidden");

        const clean = (value) => {
          energyApplyBtn.removeEventListener("click", submit);
          energyCancelBtn.removeEventListener("click", cancel);
          energyModalBackdrop?.removeEventListener("click", cancel);
          energyModal.classList.add("hidden");
          resolve(value);
        };

        const submit = () => {
          const chosen = String(energyColorSelect.value || "").trim().toLowerCase();
          clean(allowedColors.includes(chosen) ? chosen : null);
        };

        const cancel = () => clean(null);

        energyApplyBtn.addEventListener("click", submit);
        energyCancelBtn.addEventListener("click", cancel);
        energyModalBackdrop?.addEventListener("click", cancel);
      });
    }

    async function useConsumable(entry) {
      if (!entry || !entry.gear || !isConsumable(entry.gear)) return;
      if (!activeCharacter?.id || !currentUser?.id) {
        pushStatus("Save the character before using consumables.", { tone: "warning" });
        return;
      }
      const gear = entry.gear;
      const type = getConsumableType(gear).toLowerCase();
      let reminder = "Remember to apply this consumable's effects manually to yourself or an ally if needed.";

      try {
        if (type === "temp buff") {
          applyTempConsumableStats(gear);
          reminder = "Temporary buff applied. Clear temp buffs when you change nodes.";
        } else if (type === "energy") {
          const effect = getConsumableEffectText(gear).toLowerCase();
          const amount = Number((effect.match(/grants\s*(\d+)/i) || [])[1] || 0);
          const energyKeyByColor = { red: "energy_red", blue: "energy_blue", green: "energy_green", gray: "energy_gray" };
          const defaultColor = String(gear.color || "red").trim().toLowerCase();
          const chosen = await openEnergyColorModal(defaultColor);
          if (!chosen) {
            pushStatus("Energy consumable cancelled.", { tone: "warning" });
            return;
          }
          const key = energyKeyByColor[chosen];
          if (key && amount > 0) {
            activeCharacter.base_stats[key] = (Number(activeCharacter.base_stats[key]) || 0) + amount;
            const { error } = await sb.from("webrunning_characters").update({ base_stats: activeCharacter.base_stats }).eq("id", activeCharacter.id).eq("user_id", currentUser.id);
            if (error) throw error;
            reminder = `Added ${amount} ${chosen} energy and ignored energy cap.`;
          } else {
            reminder = "No energy was added because no valid color was selected.";
          }
        } else if (type === "respec stats") {
          const bonusPoints = getRespecBonusPointsByRarity(gear.rarity);
          const updated = await openRespecModal(activeCharacter.base_stats, bonusPoints);
          if (!updated) {
            pushStatus("Respec cancelled.", { tone: "warning" });
            return;
          }
          activeCharacter.base_stats.power = updated.power;
          activeCharacter.base_stats.defense = updated.defense;
          activeCharacter.base_stats.speed = updated.speed;
          activeCharacter.base_stats.intelligence = updated.intelligence;
          const { error } = await sb.from("webrunning_characters").update({ base_stats: activeCharacter.base_stats }).eq("id", activeCharacter.id).eq("user_id", currentUser.id);
          if (error) throw error;
          reminder = `Stats reallocated with ${bonusPoints} bonus point(s) from rarity.`;
        } else if (type === "local shop upgrade") {
          reminder = "Local shop upgrade consumed. Track local shop upgrades manually.";
        } else if (type === "healing") {
          reminder = "Healing consumable used. Apply healing manually to yourself or an ally.";
        } else {
          reminder = "Consumable used. Update any manual effects yourself.";
        }

        activeGearRow = entry;
        activeGearRow.__deletionMetadata = { type: "consumable_use" };
        await deleteGear({ mode: "used" });
        pushStatus(`${reminder}`, { tone: "success" });
        render();
      } catch (error) {
        console.error(error);
        pushStatus("Failed to use consumable.", { tone: "error" });
      }
    }

    async function useGeneratedConsumable(index) {
      if (!Number.isFinite(index)) return;
      const gear = generatedGear[index];
      if (!gear || !gear.__added) return;
      const signature = gearSignature(gear);
      const entry = characterGear.find(item => item.gear && gearSignature(item.gear) === signature);
      if (!entry) {
        gear.__added = false;
        renderGeneratedGear(applyGearBonuses(currentStats(), calculateGearBonuses(currentStats())));
        pushStatus("That consumable is no longer on this character.", { tone: "warning" });
        return;
      }
      await useConsumable(entry);
      gear.__added = false;
      renderGeneratedGear(applyGearBonuses(currentStats(), calculateGearBonuses(currentStats())));
    }

    async function addPastedGearFromJson() {
      pasteStatus.textContent = "";
      try {
        const parsed = JSON.parse(gearPasteInput.value.trim());
        const gearItems = Array.isArray(parsed) ? parsed : [parsed];
        let added = 0;
        for (const gear of gearItems) {
          const inserted = await insertGearToInventory(gear);
          if (inserted) {
            added += 1;
          }
        }
        gearPasteInput.value = "";
        if (added) {
          pasteStatus.textContent = "Pasted gear added.";
          pushStatus(`Added ${added} pasted gear item(s).`, { tone: "success" });
        } else {
          pasteStatus.textContent = "No gear added.";
          pushStatus("No new gear was added.", { tone: "warning" });
        }
      } catch (error) {
        console.error(error);
        pasteStatus.textContent = "Invalid JSON.";
        pushStatus("Invalid gear JSON.", { tone: "error" });
      }
    }

    function openGearDetailModal(entry) {
      if (!entry) return;
      activeGearRow = entry;
      const gear = entry.gear;
      const gearType = gear.gear_type || gear.gearType;
      const showTierDetails = !["Kernel", "Bauble"].includes(gearType);
      gearDetailTitle.textContent = formatGearName(gear);
      gearNameInput.value = gear.name || formatGearName(gear);
      gearNotesInput.value = gear.notes || "";
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const colorCounts = getEquippedColorCounts();
      const gValue = gearType === "Bauble" && gear.color ? (colorCounts[gear.color] || 0) : 0;
      const statList = renderGearStatsList(gear.stats, gear.stat_modifiers, stats.luck, { g: gValue });
      gearDetailBody.innerHTML = `
        <div>
          <strong>Summary</strong>
          <ul>
            <li>Type: ${gearType}</li>
            <li>Rarity: ${gear.rarity}</li>
            <li>Color: ${[gear.color, gear.color2].filter(Boolean).join(" / ") || "Neutral"}</li>
            <li>Item: ${gear.item_type || "Unknown"}</li>
            <li>Aesthetic: ${gear.aesthetic || "None"}</li>
            <li>Essence Value: ${gear.essence_value}</li>
          </ul>
        </div>
        <div>
          <strong>Stats</strong>
          ${statList}
        </div>
        <div>
          <strong>Abilities</strong>
          ${renderAbilityDetails(gear.abilities, { showTierDetails, gearRarity: gear.rarity })}
        </div>
      `;
      gearDetailStatus.textContent = "";
      gearDetailModal.classList.remove("hidden");
    }

    function closeGearDetailModal() {
      gearDetailModal.classList.add("hidden");
    }

    async function saveGearNameUpdate() {
      if (!activeGearRow) return;
      const newName = gearNameInput.value.trim();
      if (!newName) {
        gearDetailStatus.textContent = "Name cannot be empty.";
        pushStatus("Gear name cannot be empty.", { tone: "warning" });
        return;
      }
      const notes = gearNotesInput.value.trim();
      const { error } = await sb
        .from("webrunning_gear")
        .update({ name: newName, notes })
        .eq("id", activeGearRow.gear_id);
      if (error) {
        gearDetailStatus.textContent = error.message;
        pushStatus(error.message, { tone: "error" });
        return;
      }
      activeGearRow.gear.name = newName;
      activeGearRow.gear.notes = notes;
      gearDetailTitle.textContent = newName;
      gearDetailStatus.textContent = "Details saved.";
      pushStatus("Gear details saved.", { tone: "success" });
      render();
    }

    async function copyGearJsonToClipboard() {
      if (!activeGearRow) return;
      const gear = activeGearRow.gear;
      const payload = {
        name: gear.name,
        rarity: gear.rarity,
        color: gear.color,
        color2: gear.color2,
        gear_type: gear.gear_type,
        aesthetic: gear.aesthetic,
        item_type: gear.item_type,
        stats: gear.stats,
        essence_value: gear.essence_value,
        credit_value: gear.credit_value,
        abilities: gear.abilities,
        stat_modifiers: gear.stat_modifiers,
        notes: gear.notes || ""
      };
      try {
        await navigator.clipboard.writeText(JSON.stringify(payload, null, 2));
        gearDetailStatus.textContent = "Copied to clipboard.";
        pushStatus("Copied gear JSON to clipboard.", { tone: "success" });
      } catch (error) {
        console.error(error);
        gearDetailStatus.textContent = "Copy failed.";
        pushStatus("Copy failed.", { tone: "error" });
      }
    }

    function addDeletedGearHistory(entry, mode) {
      const snapshot = {
        id: `${Date.now()}-${Math.random().toString(16).slice(2)}`,
        deletedAt: new Date(),
        mode,
        entry: {
          gear_id: entry.gear_id,
          gear_slot: entry.gear_slot,
          equipped: entry.equipped,
          gear: entry.gear
        },
        metadata: entry.__deletionMetadata ? { ...entry.__deletionMetadata } : null
      };
      if (entry.__deletionMetadata) {
        delete entry.__deletionMetadata;
      }
      deletedGearHistory.unshift(snapshot);
      renderDeletedGearHistory();
      return snapshot;
    }

    function renderDeletedGearHistory() {
      if (!elements.deletedGearHistory) return;
      if (!deletedGearHistory.length) {
        elements.deletedGearHistory.innerHTML = `<span class="muted">No deleted gear yet.</span>`;
        return;
      }
      elements.deletedGearHistory.innerHTML = deletedGearHistory
        .map(record => `
          <div class="deletion-history-item">
            <div>
              <strong>${formatGearName(record.entry.gear)}</strong>
              <div class="muted">${record.deletedAt.toLocaleString()}</div>
            </div>
            <button type="button" data-action="restore" data-record="${record.id}" aria-label="Restore" title="Restore"><svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M9 8L4 12l5 4"></path><path d="M4 12h8a6 6 0 1 1 0 12"></path></svg><span>Restore</span></button>
          </div>
        `)
        .join("");
    }

    function resolveRestoreSlot(entry, stats) {
      const gearType = entry.gear.gear_type || entry.gear.gearType;
      if (entry.gear_slot === "inventory") {
        if (inventoryCount() < inventoryCapacity(stats)) return "inventory";
        return null;
      }
      if (entry.gear_slot === "local_node") {
        if (localNodeCount() < localNodeCapacity(stats)) return "local_node";
        return null;
      }
      const available = availableSlotsForGear(entry.gear, stats);
      if (available.includes(entry.gear_slot)) return entry.gear_slot;
      if (available.length) return available[0];
      return gearType === "Bauble" ? "inventory" : null;
    }

    async function restoreDeletedGear(recordId) {
      const recordIndex = deletedGearHistory.findIndex(record => record.id === recordId);
      if (recordIndex === -1) return;
      const record = deletedGearHistory[recordIndex];
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const slot = resolveRestoreSlot(record.entry, stats);
      if (!slot) {
        pushStatus("No available slot to restore that gear.", { tone: "warning" });
        return;
      }
      try {
        const inserted = await insertGearToInventory(record.entry.gear, { slot });
        if (!inserted) return;
        deletedGearHistory.splice(recordIndex, 1);
        renderDeletedGearHistory();
        pushStatus("Gear restored.", { tone: "success" });
      } catch (error) {
        console.error(error);
        pushStatus("Failed to restore gear.", { tone: "error" });
      }
    }

    async function deleteGear({ mode = "delete" } = {}) {
      if (!activeGearRow) return;
      const gear = activeGearRow.gear;
      try {
        if (mode === "dissolve") {
          const updatedEssence = (activeCharacter.base_stats?.essence || 0) + (gear.essence_value || 0);
          const { error: characterError } = await sb
            .from("webrunning_characters")
            .update({ base_stats: { ...activeCharacter.base_stats, essence: updatedEssence } })
            .eq("id", activeCharacter.id)
            .eq("user_id", currentUser.id);
          if (characterError) throw characterError;
          activeCharacter.base_stats.essence = updatedEssence;
          pushStatus(`Added ${gear.essence_value || 0} essence to your bank.`, { tone: "success" });
        }

        const { error: linkError } = await sb
          .from("webrunning_character_gear")
          .delete()
          .eq("character_id", activeCharacter.id)
          .eq("gear_id", activeGearRow.gear_id);
        if (linkError) throw linkError;

        const { error: gearError } = await sb
          .from("webrunning_gear")
          .delete()
          .eq("id", activeGearRow.gear_id);
        if (gearError) throw gearError;

        const deletedRecord = addDeletedGearHistory(activeGearRow, mode);
        characterGear = characterGear.filter(entry => entry.gear_id !== activeGearRow.gear_id);
        generatedGear.forEach(item => {
          if (item && gearSignature(item) === gearSignature(gear)) {
            item.__added = false;
          }
        });
        closeGearDetailModal();
        render();
        const deletedMessage = mode === "used" ? "Consumable used." : "Gear deleted.";
        pushStatus(deletedMessage, {
          tone: "warning",
          actionLabel: "Undo",
          onAction: () => restoreDeletedGear(deletedRecord.id),
          duration: 8000
        });
      } catch (error) {
        console.error(error);
        gearDetailStatus.textContent = "Failed to delete gear.";
        pushStatus("Failed to delete gear.", { tone: "error" });
      }
    }

    async function updateGearSlot(entry, slot) {
      const equipped = slot !== "inventory" && slot !== "local_node";
      const { error } = await sb
        .from("webrunning_character_gear")
        .update({ gear_slot: slot, equipped })
        .eq("character_id", activeCharacter.id)
        .eq("gear_id", entry.gear_id);
      if (error) throw error;
      entry.gear_slot = slot;
      entry.equipped = equipped;
      render();
    }

    async function equipGear(entry) {
      if (!entry) return;
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const availableSlots = availableSlotsForGear(entry.gear, stats);
      if (!availableSlots.length) {
        const swapOptions = getSwapOptionsForGear(entry.gear, stats);
        if (!swapOptions.length) {
          pushStatus("No open slots for that gear.", { tone: "warning" });
          return;
        }
        if (inventoryCount() >= inventoryCapacity(stats)) {
          pushStatus("No inventory slots available to swap gear.", { tone: "warning" });
          return;
        }
        const selected = selectSwapSlot(swapOptions);
        if (!selected) {
          pushStatus("No swap targets available.", { tone: "warning" });
          return;
        }
        await updateGearSlot(entry, selected.slot);
        await updateGearSlot(selected.entry, "inventory");
        return;
      }
      await updateGearSlot(entry, availableSlots[0]);
    }

    async function moveGearToInventory(entry) {
      if (!entry) return;
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      if (inventoryCount() >= inventoryCapacity(stats)) {
        pushStatus("No inventory slots available.", { tone: "warning" });
        return;
      }
      await updateGearSlot(entry, "inventory");
    }

    async function moveGearToLocalNode(entry) {
      if (!entry) return;
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      if (localNodeCount() >= localNodeCapacity(stats)) {
        pushStatus("No local node slots available.", { tone: "warning" });
        return;
      }
      await updateGearSlot(entry, "local_node");
    }

    function updateDerived(stats, gearBonus) {
      const derived = deriveSecondaryStats(stats);
      const derivedBonus = gearBonus?.derived || {};
      const sources = gearBonus?.sources || createEmptyBonusSources();
      const statusStacks = getStatusStacks(stats);
      const statusAdjustments = {
        attackPlus: -statusStacks.poison,
        damagePlus: -statusStacks.poison,
        defenseDc: -statusStacks.freeze,
        armor: -statusStacks.freeze
      };
      const totalPerception = derived.perception + (derivedBonus.perception || 0);
      const aoeMultiplier = getAoeBuffMultiplier();
      const aoeRange = (totalPerception * aoeMultiplier) + (derivedBonus.aoeRange || 0);

      const attackSources = combineSourceLists(
        sources.derived.attackPlus,
        sources.base.power,
        statusStacks.poison ? [{ label: "Poison", value: statusAdjustments.attackPlus }] : []
      );
      const damageSources = combineSourceLists(
        sources.derived.damagePlus,
        sources.base.power,
        statusStacks.poison ? [{ label: "Poison", value: statusAdjustments.damagePlus }] : []
      );
      const defenseDcSources = combineSourceLists(
        sources.derived.defenseDc,
        sources.base.defense,
        statusStacks.freeze ? [{ label: "Freeze", value: statusAdjustments.defenseDc }] : []
      );
      const armorSources = combineSourceLists(
        sources.derived.armor,
        sources.base.defense,
        statusStacks.freeze ? [{ label: "Freeze", value: statusAdjustments.armor }] : []
      );
      const initiativeSources = combineSourceLists(sources.derived.initiative, sources.base.speed);
      const movementSources = combineSourceLists(sources.derived.movementSpeed, scaleSourceList(sources.base.speed, 2));
      const rangeSources = combineSourceLists(sources.derived.range, sources.base.speed);
      const perceptionSources = combineSourceLists(sources.derived.perception, scaleSourceList(sources.base.intelligence, 2));
      const aoeRangeSources = combineSourceLists(sources.derived.aoeRange, scaleSourceList(sources.base.intelligence, 2 * aoeMultiplier));
      const hackingSources = combineSourceLists(sources.derived.hacking, sources.base.intelligence);

      const limits = getLevelLimits(stats.level);
      const attackTotal = derived.attackPlus + (derivedBonus.attackPlus || 0) + statusAdjustments.attackPlus;
      const comboTotal = derived.damagePlus + (derivedBonus.damagePlus || 0) + statusAdjustments.damagePlus;
      const defenseDcTotal = derived.defenseDc + (derivedBonus.defenseDc || 0) + statusAdjustments.defenseDc;
      const defenseDcDisplay = applyDisplayLimit(defenseDcTotal, limits.defenseDc);

      setStatDisplay(
        elements.displayAttackPlus,
        attackTotal,
        summarizeSources(attackSources),
        {
          rawValue: attackTotal
        }
      );
      setStatDisplay(
        elements.displayDamagePlus,
        comboTotal,
        summarizeSources(damageSources),
        {
          rawValue: comboTotal
        }
      );
      setStatDisplay(elements.displayAttackDamageLimit, limits.attackDamage ?? "None", "");
      setStatDisplay(elements.displayComboDamageLimit, limits.comboDamage ?? "None", "");
      setStatDisplay(
        elements.displayDefenseDc,
        defenseDcTotal,
        summarizeSources(defenseDcSources),
        {
          displayValue: defenseDcDisplay.displayValue,
          limit: defenseDcDisplay.limit,
          limitLabel: "Limit:",
          rawValue: defenseDcTotal,
          showRawValue: Number.isFinite(defenseDcDisplay.limit)
        }
      );
      setStatDisplay(
        elements.displayArmor,
        derived.armor + (derivedBonus.armor || 0) + statusAdjustments.armor,
        summarizeSources(armorSources)
      );
      setStatDisplay(
        elements.displayInitiative,
        derived.initiative + (derivedBonus.initiative || 0),
        summarizeSources(initiativeSources)
      );
      setStatDisplay(
        elements.displayMovementSpeed,
        derived.movementSpeed + (derivedBonus.movementSpeed || 0),
        summarizeSources(movementSources)
      );
      setStatDisplay(
        elements.displayRange,
        derived.range + (derivedBonus.range || 0),
        summarizeSources(rangeSources)
      );
      setStatDisplay(
        elements.displayPerception,
        totalPerception,
        summarizeSources(perceptionSources)
      );
      setStatDisplay(
        elements.displayAoeRange,
        aoeRange,
        summarizeSources(aoeRangeSources)
      );
      setStatDisplay(
        elements.displayHacking,
        derived.hacking + (derivedBonus.hacking || 0),
        summarizeSources(hackingSources)
      );

      if (elements.displayDamageTaken) {
        elements.displayDamageTaken.textContent = formatSignedValue(statusStacks.burn);
      }
      if (elements.displayStatusDefenseDc) {
        elements.displayStatusDefenseDc.textContent = formatSignedValue(statusAdjustments.defenseDc);
      }
      if (elements.displayStatusArmor) {
        elements.displayStatusArmor.textContent = formatSignedValue(statusAdjustments.armor);
      }
      if (elements.displayStatusAttackPlus) {
        elements.displayStatusAttackPlus.textContent = formatSignedValue(statusAdjustments.attackPlus);
      }
      if (elements.displayStatusDamagePlus) {
        elements.displayStatusDamagePlus.textContent = formatSignedValue(statusAdjustments.damagePlus);
      }
    }

    function render() {
      const baseStats = currentStats();
      const gearBonus = calculateGearBonuses(baseStats);
      const stats = applyGearBonuses(baseStats, gearBonus);

      elements.displayName.textContent = activeCharacter?.name || "";
      elements.displayLevel.textContent = stats.level;
      elements.inputXp.value = baseStats.xp;
      const sources = gearBonus?.sources || createEmptyBonusSources();
      const limits = getLevelLimits(stats.level);
      const luckDisplay = applyDisplayLimit(stats.luck, limits.luck);
      const hpDisplay = applyDisplayLimit(stats.hp, limits.hp);
      setStatDisplay(elements.displayLuck, stats.luck, summarizeSources(sources.base.luck), {
        displayValue: luckDisplay.displayValue,
        limit: luckDisplay.limit,
        limitLabel: "Limit:",
        rawValue: stats.luck,
        showRawValue: Number.isFinite(luckDisplay.limit)
      });
      setStatDisplay(elements.displayHp, stats.hp, summarizeSources(sources.base.hp), {
        displayValue: hpDisplay.displayValue,
        limit: hpDisplay.limit,
        limitLabel: "Limit:",
        rawValue: stats.hp,
        showRawValue: Number.isFinite(hpDisplay.limit)
      });
      setStatDisplay(elements.displayEnergyCap, stats.energy_cap, summarizeSources(sources.base.energy_cap));
      elements.inputEssence.value = baseStats.essence;
      elements.inputCurrentHp.value = baseStats.current_hp;
      elements.inputEnergyRed.value = baseStats.energy_red;
      elements.inputEnergyBlue.value = baseStats.energy_blue;
      elements.inputEnergyGreen.value = baseStats.energy_green;
      elements.inputEnergyGray.value = baseStats.energy_gray;
      setStatDisplay(elements.displayInventorySlots, stats.inventory_slots, summarizeSources(sources.base.inventory_slots));
      setStatDisplay(elements.displayKernelSlots, stats.kernel_slots, summarizeSources(sources.base.kernel_slots));
      if (elements.adventuringPlusesColumn && elements.displayAdventuringPluses) {
        const adventuringPluses = summarizeAdventuringPluses(gearBonus?.adventuringPluses || []);
        if (adventuringPluses.length) {
          elements.adventuringPlusesColumn.classList.remove("hidden");
          elements.displayAdventuringPluses.innerHTML = `<ul>${adventuringPluses
            .map(plus => `<li>${formatSignedValue(plus.value)} ${plus.name}</li>`)
            .join("")}</ul>`;
        } else {
          elements.adventuringPlusesColumn.classList.add("hidden");
          elements.displayAdventuringPluses.textContent = "";
        }
      }

      elements.inputPower.value = baseStats.power;
      elements.inputDefense.value = baseStats.defense;
      elements.inputSpeed.value = baseStats.speed;
      elements.inputIntelligence.value = baseStats.intelligence;
      elements.inputStatusBurn.value = baseStats.status_burn;
      elements.inputStatusFreeze.value = baseStats.status_freeze;
      elements.inputStatusPoison.value = baseStats.status_poison;

      updateDerived(stats, gearBonus);
      renderGearSections(stats);
      renderAbilities();
      renderDeletedGearHistory();
      const hasTempBuffs = tempConsumableSummary.length > 0;
      if (elements.tempBuffSection) {
        elements.tempBuffSection.classList.toggle("hidden", !hasTempBuffs);
      }
      if (elements.tempBuffSummary) {
        elements.tempBuffSummary.textContent = hasTempBuffs
          ? `Active Temp Buffs: ${tempConsumableSummary.join(" | ")}`
          : "No active temporary consumable buffs.";
      }
      if (elements.clearTempBuffs) {
        elements.clearTempBuffs.classList.toggle("hidden", !hasTempBuffs);
      }
      updateGearGeneratorLuck(stats);
    }

    async function requireUser() {
      const { data: { user } } = await sb.auth.getUser();
      if (!user) {
        pushStatus("Not logged in.", { tone: "error" });
        throw new Error("No user");
      }
      return user;
    }

    function formatSaveTimestamp(date = new Date()) {
      return date.toLocaleString(undefined, {
        month: "short",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      });
    }

    function updateSaveStatus(label) {
      pushStatus(`${label} ${formatSaveTimestamp()}`, { tone: "success" });
    }

    function markDirty() {
      isDirty = true;
    }

    async function autoSaveCharacter() {
      if (!isDirty || isSaving) return;
      await saveCharacter({ mode: "auto" });
    }

    function startAutosave() {
      if (autosaveTimer) {
        clearInterval(autosaveTimer);
      }
      autosaveTimer = setInterval(autoSaveCharacter, 45000);
    }

    async function loadCharacter() {
      try {
        currentUser = await requireUser();
        const params = new URLSearchParams(window.location.search);
        const characterId = params.get("id");
        let query = sb
          .from("webrunning_characters")
          .select("id, name, base_stats, status_effects, notes")
          .eq("user_id", currentUser.id);

        if (characterId) {
          query = query.eq("id", characterId);
        } else {
          query = query.order("created_at", { ascending: true }).limit(1);
        }

        const { data, error } = await query.maybeSingle();

        if (error) throw error;

        activeCharacter = data || {
          id: null,
          name: "",
          base_stats: { ...defaults },
          status_effects: null
        };

        if (activeCharacter.status_effects) {
          activeCharacter.status_effects = normalizeStatusEffects(activeCharacter.status_effects);
        }
        if (activeCharacter.base_stats) {
          activeCharacter.base_stats = mergeStatusEffectsIntoStats(
            activeCharacter.base_stats,
            activeCharacter.status_effects
          );
        }

        elements.nameInput.value = activeCharacter.name || "";
        if (elements.notesInput) {
          elements.notesInput.value = activeCharacter.notes || "";
        }
        render();
        if (activeCharacter.id) {
          await loadCharacterGear();
        }
      } catch (e) {
        console.error(e);
        pushStatus("Failed to load character.", { tone: "error" });
      }
    }

    async function loadCharacterGear() {
      if (!activeCharacter?.id) return;
      try {
        const { data, error } = await sb
          .from("webrunning_character_gear")
          .select("gear_id, equipped, gear_slot, gear:webrunning_gear(*)")
          .eq("character_id", activeCharacter.id);
        if (error) throw error;
        characterGear = (data || []).map(row => ({
          gear_id: row.gear_id,
          equipped: row.equipped,
          gear_slot: row.gear_slot,
          gear: row.gear
        }));
        render();
      } catch (error) {
        console.error(error);
        pushStatus("Failed to load gear.", { tone: "error" });
      }
    }

    function readBaseStatsFromForm() {
      const stats = currentStats();
      stats.xp = Number(elements.inputXp.value) || 0;
      stats.essence = Number(elements.inputEssence.value) || 0;
      stats.current_hp = Number(elements.inputCurrentHp.value) || 0;
      stats.energy_red = Number(elements.inputEnergyRed.value) || 0;
      stats.energy_blue = Number(elements.inputEnergyBlue.value) || 0;
      stats.energy_gray = Number(elements.inputEnergyGray.value) || 0;
      stats.energy_green = Number(elements.inputEnergyGreen.value) || 0;
      stats.power = Number(elements.inputPower.value) || 0;
      stats.defense = Number(elements.inputDefense.value) || 0;
      stats.speed = Number(elements.inputSpeed.value) || 0;
      stats.intelligence = Number(elements.inputIntelligence.value) || 0;
      stats.status_burn = Number(elements.inputStatusBurn.value) || 0;
      stats.status_freeze = Number(elements.inputStatusFreeze.value) || 0;
      stats.status_poison = Number(elements.inputStatusPoison.value) || 0;
      return stats;
    }

    async function saveCharacter({ mode = "manual" } = {}) {
      if (isSaving) return;
      const name = elements.nameInput.value.trim();
      if (!name) {
        if (mode === "manual") {
          pushStatus("Name cannot be empty.", { tone: "warning" });
        }
        return;
      }

      if (!/^[a-zA-Z0-9 _-]+$/.test(name)) {
        if (mode === "manual") {
          pushStatus("Invalid characters in name.", { tone: "warning" });
        }
        return;
      }

      try {
        isSaving = true;
        currentUser = await requireUser();
        const baseStats = readBaseStatsFromForm();
        const notes = elements.notesInput ? elements.notesInput.value.trim() : "";

        if (activeCharacter?.id) {
          const { error } = await sb
            .from("webrunning_characters")
            .update({
              name,
              base_stats: baseStats,
              status_effects: getStatusEffectsPayload(baseStats),
              notes
            })
            .eq("id", activeCharacter.id)
            .eq("user_id", currentUser.id);
          if (error) throw error;
        } else {
          const { data, error } = await sb
            .from("webrunning_characters")
            .insert({
              user_id: currentUser.id,
              name,
              base_stats: baseStats,
              status_effects: getStatusEffectsPayload(baseStats),
              notes
            })
            .select("id, name, base_stats, status_effects, notes")
            .maybeSingle();
          if (error) throw error;
          activeCharacter = data;
          if (activeCharacter?.status_effects) {
            activeCharacter.status_effects = normalizeStatusEffects(activeCharacter.status_effects);
            activeCharacter.base_stats = mergeStatusEffectsIntoStats(
              activeCharacter.base_stats,
              activeCharacter.status_effects
            );
          }
        }

        isDirty = false;
        activeCharacter.name = name;
        activeCharacter.base_stats = baseStats;
        activeCharacter.status_effects = getStatusEffectsPayload(baseStats);
        activeCharacter.notes = notes;
        render();
        updateSaveStatus(mode === "auto" ? "Autosaved:" : "Saved:");
      } catch (e) {
        console.error(e);
        pushStatus(e.message, { tone: "error" });
      } finally {
        isSaving = false;
      }
    }

    function populateLevelSelect() {
      targetLevelSelect.innerHTML = "";
      const stats = currentStats();
      levelTable.forEach(entry => {
        const option = document.createElement("option");
        option.value = entry.level;
        option.textContent = entry.level === stats.level ? `Level ${entry.level} (Current)` : `Level ${entry.level}`;
        targetLevelSelect.appendChild(option);
      });
      targetLevelSelect.value = String(stats.level);
    }

    function getLevelEntry(level) {
      return levelTable.find(entry => entry.level === Number(level));
    }

    function calculatePointDelta(startLevel, targetLevel) {
      if (targetLevel === startLevel) return 0;
      const minLevel = Math.min(startLevel, targetLevel);
      const maxLevel = Math.max(startLevel, targetLevel);
      const points = levelTable
        .filter(entry => entry.level > minLevel && entry.level <= maxLevel)
        .reduce((sum, entry) => sum + (entry.statPoints || 0), 0);
      return targetLevel > startLevel ? points : -points;
    }

    function updateLevelPreview() {
      const stats = currentStats();
      const targetLevel = Number(targetLevelSelect.value);
      const entry = getLevelEntry(targetLevel);
      if (!entry) {
        levelPreview.innerHTML = "";
        return;
      }
      const pointDelta = calculatePointDelta(stats.level, targetLevel);
      const pointsLabel = pointDelta > 0
        ? "Stat Points to allocate"
        : pointDelta < 0
          ? "Stat Points to remove"
          : "Stat Points";
      const pointsValue = Math.abs(pointDelta);
      levelPreview.innerHTML = `
        <li>Level: ${stats.level} → ${entry.level}</li>
        <li>XP: ${stats.xp} (manual)</li>
        <li>Base HP: ${stats.hp} → ${entry.baseHp}</li>
        <li>Energy Cap: ${stats.energy_cap} → ${entry.energyCap}</li>
        <li>Kernel Slots: ${stats.kernel_slots} → ${entry.kernelSlots}</li>
        <li>Inventory Slots: ${stats.inventory_slots} → ${entry.inventorySlots}</li>
        <li>Luck: ${stats.luck} → ${entry.baseLuck}</li>
        <li>${pointsLabel}: ${pointsValue}</li>
      `;
      updateRemainingPoints(pointsValue);
    }

    function updateRemainingPoints(availablePoints) {
      const allocated =
        (Number(levelPower.value) || 0) +
        (Number(levelDefense.value) || 0) +
        (Number(levelSpeed.value) || 0) +
        (Number(levelIntelligence.value) || 0);
      pointsRemaining.textContent = Math.max(availablePoints - allocated, 0);
    }

    function resetLevelInputs() {
      levelPower.value = 0;
      levelDefense.value = 0;
      levelSpeed.value = 0;
      levelIntelligence.value = 0;
      levelError.textContent = "";
    }

    function openLevelModal() {
      populateLevelSelect();
      if (!targetLevelSelect.options.length) {
        pushStatus("No other levels available.", { tone: "warning" });
        return;
      }
      resetLevelInputs();
      updateLevelPreview();
      modal.classList.remove("hidden");
    }

    function closeLevelModal() {
      modal.classList.add("hidden");
    }

    function initCollapsibles() {
      document.querySelectorAll("[data-collapsible]").forEach(section => {
        const button = section.querySelector(".collapse-toggle");
        if (!button) return;
        const updateCollapseButton = collapsed => {
          button.innerHTML = collapsed
            ? '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><circle cx="12" cy="12" r="2.5"></circle></svg>'
            : '<svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12s4-6 10-6 10 6 10 6-4 6-10 6-10-6-10-6z"></path><path d="M4 6l16 12"></path></svg>';
          button.setAttribute("aria-label", collapsed ? "Show section" : "Hide section");
          button.setAttribute("title", collapsed ? "Show section" : "Hide section");
        };
        const isCollapsed = section.classList.contains("collapsed");
        updateCollapseButton(isCollapsed);
        button.addEventListener("click", () => {
          const nowCollapsed = section.classList.toggle("collapsed");
          updateCollapseButton(nowCollapsed);
        });
      });
    }

    async function applyLevelUp() {
      const stats = currentStats();
      const targetLevel = Number(targetLevelSelect.value);
      const entry = getLevelEntry(targetLevel);
      if (!entry) return;

      const pointDelta = calculatePointDelta(stats.level, targetLevel);
      const requiredPoints = Math.abs(pointDelta);
      const powerPoints = Number(levelPower.value) || 0;
      const defensePoints = Number(levelDefense.value) || 0;
      const speedPoints = Number(levelSpeed.value) || 0;
      const intelligencePoints = Number(levelIntelligence.value) || 0;
      const totalAllocated = powerPoints + defensePoints + speedPoints + intelligencePoints;

      if (totalAllocated !== requiredPoints) {
        levelError.textContent = pointDelta > 0
          ? "Allocate all available stat points before applying."
          : pointDelta < 0
            ? "Remove all required stat points before applying."
            : "No stat points are required for this level.";
        return;
      }

      if (
        pointDelta < 0 &&
        (stats.power - powerPoints < 0 ||
          stats.defense - defensePoints < 0 ||
          stats.speed - speedPoints < 0 ||
          stats.intelligence - intelligencePoints < 0)
      ) {
        levelError.textContent = "Cannot remove more stat points than you currently have.";
        return;
      }

      const updatedStats = {
        ...stats,
        level: entry.level,
        hp: entry.baseHp,
        energy_cap: entry.energyCap,
        kernel_slots: entry.kernelSlots,
        inventory_slots: entry.inventorySlots,
        luck: entry.baseLuck,
        power: stats.power + (pointDelta >= 0 ? powerPoints : -powerPoints),
        defense: stats.defense + (pointDelta >= 0 ? defensePoints : -defensePoints),
        speed: stats.speed + (pointDelta >= 0 ? speedPoints : -speedPoints),
        intelligence: stats.intelligence + (pointDelta >= 0 ? intelligencePoints : -intelligencePoints)
      };
      updatedStats.current_hp = Math.min(updatedStats.current_hp ?? updatedStats.hp, updatedStats.hp);

      try {
        currentUser = await requireUser();
        if (!activeCharacter?.id) {
          levelError.textContent = "Save the character before leveling up.";
          return;
        }
        const { error } = await sb
          .from("webrunning_characters")
          .update({ base_stats: updatedStats })
          .eq("id", activeCharacter.id)
          .eq("user_id", currentUser.id);
        if (error) throw error;

        activeCharacter.base_stats = updatedStats;
        render();
        closeLevelModal();
      } catch (e) {
        console.error(e);
        levelError.textContent = e.message;
      }
    }

    [
      elements.inputXp,
      elements.inputEssence,
      elements.inputCurrentHp,
      elements.inputEnergyRed,
      elements.inputEnergyBlue,
      elements.inputEnergyGreen,
      elements.inputEnergyGray,
      elements.inputPower,
      elements.inputDefense,
      elements.inputSpeed,
      elements.inputIntelligence,
      elements.inputStatusBurn,
      elements.inputStatusFreeze,
      elements.inputStatusPoison
    ]
      .forEach(input => {
        input.addEventListener("input", () => {
          markDirty();
          const stats = readBaseStatsFromForm();
          if (activeCharacter) {
            activeCharacter.base_stats = stats;
          }
          render();
        });
      });

    [levelPower, levelDefense, levelSpeed, levelIntelligence].forEach(input => {
      input.addEventListener("input", () => {
        const stats = currentStats();
        const targetLevel = Number(targetLevelSelect.value);
        const pointDelta = calculatePointDelta(stats.level, targetLevel);
        updateRemainingPoints(Math.abs(pointDelta));
      });
    });

    targetLevelSelect.addEventListener("change", () => {
      resetLevelInputs();
      updateLevelPreview();
    });

    document.getElementById("levelUpButton").addEventListener("click", openLevelModal);
    document.getElementById("confirmLevelUp").addEventListener("click", applyLevelUp);
    document.getElementById("cancelLevelUp").addEventListener("click", closeLevelModal);
    modalBackdrop.addEventListener("click", closeLevelModal);
    elements.saveButton.addEventListener("click", saveCharacter);
    elements.nameInput.addEventListener("input", markDirty);
    if (elements.notesInput) {
      elements.notesInput.addEventListener("input", () => {
        markDirty();
        if (activeCharacter) {
          activeCharacter.notes = elements.notesInput.value;
        }
      });
    }

    elements.openGearGenerator.addEventListener("click", openGearGeneratorModal);
    closeGearGenerator.addEventListener("click", closeGearGeneratorModal);
    gearGeneratorBackdrop.addEventListener("click", closeGearGeneratorModal);
    generateGearButton.addEventListener("click", handleGenerateGear);
    addAllGeneratedGearButton.addEventListener("click", addAllGeneratedGear);
    gearBonusLuck.addEventListener("input", () => {
      const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
      const hasTempBuffs = tempConsumableSummary.length > 0;
      if (elements.tempBuffSection) {
        elements.tempBuffSection.classList.toggle("hidden", !hasTempBuffs);
      }
      if (elements.tempBuffSummary) {
        elements.tempBuffSummary.textContent = hasTempBuffs
          ? `Active Temp Buffs: ${tempConsumableSummary.join(" | ")}`
          : "No active temporary consumable buffs.";
      }
      if (elements.clearTempBuffs) {
        elements.clearTempBuffs.classList.toggle("hidden", !hasTempBuffs);
      }
      updateGearGeneratorLuck(stats);
    });
    addPastedGear.addEventListener("click", addPastedGearFromJson);
    addManualGearButton.addEventListener("click", handleManualGearAdd);
    addManualGearStat.addEventListener("click", () => createManualStatRow());
    addManualGearAbility.addEventListener("click", () => createManualAbilityRow());
    manualGearType.addEventListener("change", refreshManualStatRowsForType);

    [
      gearSortField,
      gearSortDirection,
      gearFilterRarity,
      gearFilterType,
      gearFilterColor,
      gearFilterStat,
      gearFilterFreeSlot,
      localGearFilterRarity,
      localGearFilterType,
      localGearFilterColor,
      localGearFilterStat,
      localGearFilterFreeSlot
    ]
      .forEach(select => {
        if (!select) return;
        select.addEventListener("change", () => {
          const stats = applyGearBonuses(currentStats(), calculateGearBonuses(currentStats()));
          renderGearSections(stats);
        });
      });

    generatedGearList.addEventListener("click", event => {
      const button = event.target.closest("button");
      if (!button) return;
      const action = button.dataset.action;
      const index = Number(button.dataset.index);
      if (action === "add") {
        addGeneratedGear(index, "add");
      } else if (action === "equip") {
        addGeneratedGear(index, "equip");
      } else if (action === "use") {
        useGeneratedConsumable(index);
      } else if (action === "remove") {
        if (!Number.isFinite(index)) return;
        removeGeneratedGearFromCharacter(generatedGear[index]);
      }
    });

    function handleGearListClick(event) {
      const button = event.target.closest("button");
      if (!button) return;
      const action = button.dataset.action;
      const gearId = button.dataset.gear;
      if (!action || !gearId) return;
      const entry = findGearEntry(gearId);
      if (!entry) return;
      if (action === "view") {
        openGearDetailModal(entry);
      } else if (action === "equip") {
        equipGear(entry);
      } else if (action === "use") {
        useConsumable(entry);
      } else if (action === "unequip" || action === "inventory") {
        moveGearToInventory(entry);
      } else if (action === "local") {
        moveGearToLocalNode(entry);
      } else if (action === "dissolve") {
        activeGearRow = entry;
        deleteGear({ mode: "dissolve" });
      } else if (action === "delete") {
        activeGearRow = entry;
        deleteGear({ mode: "delete" });
      }
    }

    elements.equippedSlots.addEventListener("click", handleGearListClick);
    elements.inventorySlots.addEventListener("click", handleGearListClick);
    elements.localNodeSlots.addEventListener("click", handleGearListClick);

    if (elements.clearTempBuffs) {
      elements.clearTempBuffs.addEventListener("click", () => {
        tempConsumableBonus = createEmptyBonus();
        tempConsumableSummary = [];
        pushStatus("Temporary consumable buffs cleared.", { tone: "success" });
        render();
      });
    }
    if (elements.abilitiesList) {
      const closeAbilityDropdowns = (exception = null) => {
        elements.abilitiesList.querySelectorAll(".ability-dropdown.is-open").forEach(dropdown => {
          if (dropdown === exception) return;
          dropdown.classList.remove("is-open");
          const toggle = dropdown.querySelector(".ability-summary");
          const details = dropdown.querySelector(".ability-details");
          if (toggle) {
            toggle.setAttribute("aria-expanded", "false");
          }
          if (details) {
            details.hidden = true;
          }
        });
      };

      elements.abilitiesList.addEventListener("click", event => {
        const target = event.target instanceof Element ? event.target : null;
        const button = target ? target.closest(".ability-summary") : null;
        if (!button) return;
        const dropdown = button.closest(".ability-dropdown");
        if (!dropdown) return;
        const isOpen = !dropdown.classList.contains("is-open");
        closeAbilityDropdowns(dropdown);
        const details = dropdown.querySelector(".ability-details");
        dropdown.classList.toggle("is-open", isOpen);
        button.setAttribute("aria-expanded", String(isOpen));
        if (details) {
          details.hidden = !isOpen;
        }
      });

      document.addEventListener("click", event => {
        if (!elements.abilitiesList.contains(event.target)) {
          closeAbilityDropdowns();
        }
      });

      document.addEventListener("keydown", event => {
        if (event.key === "Escape") {
          closeAbilityDropdowns();
        }
      });
    }

    closeGearDetail.addEventListener("click", closeGearDetailModal);
    gearDetailBackdrop.addEventListener("click", closeGearDetailModal);
    saveGearName.addEventListener("click", saveGearNameUpdate);
    gearNameInput.addEventListener("change", saveGearNameUpdate);
    gearNameInput.addEventListener("blur", saveGearNameUpdate);
    gearNotesInput.addEventListener("change", saveGearNameUpdate);
    gearNotesInput.addEventListener("blur", saveGearNameUpdate);
    copyGearJson.addEventListener("click", copyGearJsonToClipboard);
    deleteGearButton.addEventListener("click", () => deleteGear({ mode: "delete" }));
    dissolveGearButton.addEventListener("click", () => deleteGear({ mode: "dissolve" }));

    if (elements.deletedGearHistory) {
      elements.deletedGearHistory.addEventListener("click", event => {
        const button = event.target.closest("button");
        if (!button) return;
        const action = button.dataset.action;
        if (action !== "restore") return;
        const recordId = button.dataset.record;
        restoreDeletedGear(recordId);
      });
    }

    window.addEventListener("DOMContentLoaded", () => {
      populateGearFilterSelects();
      if (manualGearStatsList && !manualGearStatsList.children.length) {
        createManualStatRow();
      }
      if (manualGearAbilitiesList && !manualGearAbilitiesList.children.length) {
        createManualAbilityRow();
      }
      loadCharacter();
      initCollapsibles();
      startAutosave();
      ensurePyodide().catch(() => {});
    });
  </script>
</body>
</html>
